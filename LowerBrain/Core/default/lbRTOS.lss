
lbRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001a0  00800200  00004e38  00004ecc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004e38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000095d  008003a0  008003a0  0000506c  2**0
                  ALLOC
  3 .debug_aranges 00000180  00000000  00000000  0000506c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000144a  00000000  00000000  000051ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000459c  00000000  00000000  00006636  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000131f  00000000  00000000  0000abd2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000387c  00000000  00000000  0000bef1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f70  00000000  00000000  0000f770  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001eda  00000000  00000000  000106e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002140  00000000  00000000  000125ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000146fa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a0 00 	jmp	0x140	; 0x140 <__ctors_end>
       4:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
       8:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
       c:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      10:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      14:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      18:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      1c:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      20:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      24:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      28:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      2c:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      30:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      34:	0c 94 30 14 	jmp	0x2860	; 0x2860 <__vector_13>
      38:	0c 94 5d 14 	jmp	0x28ba	; 0x28ba <__vector_14>
      3c:	0c 94 4f 12 	jmp	0x249e	; 0x249e <__vector_15>
      40:	0c 94 a9 13 	jmp	0x2752	; 0x2752 <__vector_16>
      44:	0c 94 7d 0d 	jmp	0x1afa	; 0x1afa <__vector_17>
      48:	0c 94 d6 13 	jmp	0x27ac	; 0x27ac <__vector_18>
      4c:	0c 94 03 14 	jmp	0x2806	; 0x2806 <__vector_19>
      50:	0c 94 0f 12 	jmp	0x241e	; 0x241e <__vector_20>
      54:	0c 94 4f 13 	jmp	0x269e	; 0x269e <__vector_21>
      58:	0c 94 7c 13 	jmp	0x26f8	; 0x26f8 <__vector_22>
      5c:	0c 94 bc 11 	jmp	0x2378	; 0x2378 <__vector_23>
      60:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      64:	0c 94 26 18 	jmp	0x304c	; 0x304c <__vector_25>
      68:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      6c:	0c 94 83 19 	jmp	0x3306	; 0x3306 <__vector_27>
      70:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      74:	0c 94 3d 1c 	jmp	0x387a	; 0x387a <__vector_29>
      78:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      7c:	0c 94 8a 14 	jmp	0x2914	; 0x2914 <__vector_31>
      80:	0c 94 b7 14 	jmp	0x296e	; 0x296e <__vector_32>
      84:	0c 94 e4 14 	jmp	0x29c8	; 0x29c8 <__vector_33>
      88:	0c 94 11 15 	jmp	0x2a22	; 0x2a22 <__vector_34>
      8c:	0c 94 8f 12 	jmp	0x251e	; 0x251e <__vector_35>
      90:	0c 94 01 18 	jmp	0x3002	; 0x3002 <__vector_36>
      94:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      98:	0c 94 5e 19 	jmp	0x32bc	; 0x32bc <__vector_38>
      9c:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      a0:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      a4:	0c 94 3e 15 	jmp	0x2a7c	; 0x2a7c <__vector_41>
      a8:	0c 94 6b 15 	jmp	0x2ad6	; 0x2ad6 <__vector_42>
      ac:	0c 94 98 15 	jmp	0x2b30	; 0x2b30 <__vector_43>
      b0:	0c 94 c5 15 	jmp	0x2b8a	; 0x2b8a <__vector_44>
      b4:	0c 94 cf 12 	jmp	0x259e	; 0x259e <__vector_45>
      b8:	0c 94 f2 15 	jmp	0x2be4	; 0x2be4 <__vector_46>
      bc:	0c 94 1f 16 	jmp	0x2c3e	; 0x2c3e <__vector_47>
      c0:	0c 94 4c 16 	jmp	0x2c98	; 0x2c98 <__vector_48>
      c4:	0c 94 79 16 	jmp	0x2cf2	; 0x2cf2 <__vector_49>
      c8:	0c 94 0f 13 	jmp	0x261e	; 0x261e <__vector_50>
      cc:	0c 94 dc 17 	jmp	0x2fb8	; 0x2fb8 <__vector_51>
      d0:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      d4:	0c 94 39 19 	jmp	0x3272	; 0x3272 <__vector_53>
      d8:	0c 94 b7 17 	jmp	0x2f6e	; 0x2f6e <__vector_54>
      dc:	0c 94 bd 00 	jmp	0x17a	; 0x17a <__bad_interrupt>
      e0:	0c 94 14 19 	jmp	0x3228	; 0x3228 <__vector_56>

000000e4 <__c.2845>:
      e4:	49 6e 69 74 69 61 6c 69 7a 61 74 69 6f 6e 20 43     Initialization C
      f4:	6f 6d 70 6c 65 74 65 20 0d 0a 00                    omplete ...

000000ff <__c.2840>:
      ff:	2e 00                                               ..

00000101 <TimerPrescaleFactor>:
     101:	00 00 01 00 08 00 40 00 00 01 00 04                 ......@.....

0000010d <Timer2PrescaleFactor>:
     10d:	00 00 01 00 08 00 20 00 40 00 80 00 00 01 00 04     ...... .@.......

0000011d <__c.1991>:
     11d:	42 41 44 5f 76 65 63 74 20 63 61 6c 6c 65 64 21     BAD_vect called!
	...

0000012e <HexChars>:
     12e:	30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46     0123456789ABCDEF
	...

00000140 <__ctors_end>:
     140:	11 24       	eor	r1, r1
     142:	1f be       	out	0x3f, r1	; 63
     144:	cf ef       	ldi	r28, 0xFF	; 255
     146:	d1 e2       	ldi	r29, 0x21	; 33
     148:	de bf       	out	0x3e, r29	; 62
     14a:	cd bf       	out	0x3d, r28	; 61

0000014c <__do_copy_data>:
     14c:	13 e0       	ldi	r17, 0x03	; 3
     14e:	a0 e0       	ldi	r26, 0x00	; 0
     150:	b2 e0       	ldi	r27, 0x02	; 2
     152:	e8 e3       	ldi	r30, 0x38	; 56
     154:	fe e4       	ldi	r31, 0x4E	; 78
     156:	02 c0       	rjmp	.+4      	; 0x15c <.do_copy_data_start>

00000158 <.do_copy_data_loop>:
     158:	05 90       	lpm	r0, Z+
     15a:	0d 92       	st	X+, r0

0000015c <.do_copy_data_start>:
     15c:	a0 3a       	cpi	r26, 0xA0	; 160
     15e:	b1 07       	cpc	r27, r17
     160:	d9 f7       	brne	.-10     	; 0x158 <.do_copy_data_loop>

00000162 <__do_clear_bss>:
     162:	1c e0       	ldi	r17, 0x0C	; 12
     164:	a0 ea       	ldi	r26, 0xA0	; 160
     166:	b3 e0       	ldi	r27, 0x03	; 3
     168:	01 c0       	rjmp	.+2      	; 0x16c <.do_clear_bss_start>

0000016a <.do_clear_bss_loop>:
     16a:	1d 92       	st	X+, r1

0000016c <.do_clear_bss_start>:
     16c:	ad 3f       	cpi	r26, 0xFD	; 253
     16e:	b1 07       	cpc	r27, r17
     170:	e1 f7       	brne	.-8      	; 0x16a <.do_clear_bss_loop>
     172:	0e 94 8f 04 	call	0x91e	; 0x91e <main>
     176:	0c 94 1a 27 	jmp	0x4e34	; 0x4e34 <_exit>

0000017a <__bad_interrupt>:
     17a:	0c 94 a6 16 	jmp	0x2d4c	; 0x2d4c <__vector_default>

0000017e <PWM_Init_timer1_LED>:

//OC1B  pin B6 (attached to green LED)
void PWM_Init_timer1_LED(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     17e:	89 30       	cpi	r24, 0x09	; 9
     180:	49 f4       	brne	.+18     	; 0x194 <PWM_Init_timer1_LED+0x16>
	{	// 9bit mode
		sbi(TCCR1A,PWM11);
     182:	80 91 80 00 	lds	r24, 0x0080
     186:	82 60       	ori	r24, 0x02	; 2
     188:	80 93 80 00 	sts	0x0080, r24
		cbi(TCCR1A,PWM10);
     18c:	80 91 80 00 	lds	r24, 0x0080
     190:	8e 7f       	andi	r24, 0xFE	; 254
     192:	0e c0       	rjmp	.+28     	; 0x1b0 <PWM_Init_timer1_LED+0x32>
	}
	else if( bitRes == 10 )
     194:	8a 30       	cpi	r24, 0x0A	; 10
     196:	21 f4       	brne	.+8      	; 0x1a0 <PWM_Init_timer1_LED+0x22>
	{	// 10bit mode
		sbi(TCCR1A,PWM11);
     198:	80 91 80 00 	lds	r24, 0x0080
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	03 c0       	rjmp	.+6      	; 0x1a6 <PWM_Init_timer1_LED+0x28>
		sbi(TCCR1A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR1A,PWM11);
     1a0:	80 91 80 00 	lds	r24, 0x0080
     1a4:	8d 7f       	andi	r24, 0xFD	; 253
     1a6:	80 93 80 00 	sts	0x0080, r24
		sbi(TCCR1A,PWM10);
     1aa:	80 91 80 00 	lds	r24, 0x0080
     1ae:	81 60       	ori	r24, 0x01	; 1
     1b0:	80 93 80 00 	sts	0x0080, r24
	}
	// clear output compare values
	OCR1B = 0;
     1b4:	10 92 8b 00 	sts	0x008B, r1
     1b8:	10 92 8a 00 	sts	0x008A, r1
}
     1bc:	08 95       	ret

000001be <PWM_Init_timer2_H6>:
//pin H6, timer2
void PWM_Init_timer2_H6(u08 bitRes)
{
	// enable timer2 as 8,9,10bit PWM
	if(bitRes == 9)
     1be:	89 30       	cpi	r24, 0x09	; 9
     1c0:	49 f4       	brne	.+18     	; 0x1d4 <PWM_Init_timer2_H6+0x16>
	{	// 9bit mode
		sbi(TCCR2A,PWM11);
     1c2:	80 91 b0 00 	lds	r24, 0x00B0
     1c6:	82 60       	ori	r24, 0x02	; 2
     1c8:	80 93 b0 00 	sts	0x00B0, r24
		cbi(TCCR2A,PWM10);
     1cc:	80 91 b0 00 	lds	r24, 0x00B0
     1d0:	8e 7f       	andi	r24, 0xFE	; 254
     1d2:	0e c0       	rjmp	.+28     	; 0x1f0 <PWM_Init_timer2_H6+0x32>
	}
	else if( bitRes == 10 )
     1d4:	8a 30       	cpi	r24, 0x0A	; 10
     1d6:	21 f4       	brne	.+8      	; 0x1e0 <PWM_Init_timer2_H6+0x22>
	{	// 10bit mode
		sbi(TCCR2A,PWM11);
     1d8:	80 91 b0 00 	lds	r24, 0x00B0
     1dc:	82 60       	ori	r24, 0x02	; 2
     1de:	03 c0       	rjmp	.+6      	; 0x1e6 <PWM_Init_timer2_H6+0x28>
		sbi(TCCR2A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR2A,PWM11);
     1e0:	80 91 b0 00 	lds	r24, 0x00B0
     1e4:	8d 7f       	andi	r24, 0xFD	; 253
     1e6:	80 93 b0 00 	sts	0x00B0, r24
		sbi(TCCR2A,PWM10);
     1ea:	80 91 b0 00 	lds	r24, 0x00B0
     1ee:	81 60       	ori	r24, 0x01	; 1
     1f0:	80 93 b0 00 	sts	0x00B0, r24
	}
	// clear output compare values
	OCR2B = 0;
     1f4:	10 92 b4 00 	sts	0x00B4, r1
}
     1f8:	08 95       	ret

000001fa <PWM_Init_timer3_E3>:
//pin E3
void PWM_Init_timer3_E3(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     1fa:	89 30       	cpi	r24, 0x09	; 9
     1fc:	49 f4       	brne	.+18     	; 0x210 <PWM_Init_timer3_E3+0x16>
	{	// 9bit mode
		sbi(TCCR3A,PWM11);
     1fe:	80 91 90 00 	lds	r24, 0x0090
     202:	82 60       	ori	r24, 0x02	; 2
     204:	80 93 90 00 	sts	0x0090, r24
		cbi(TCCR3A,PWM10);
     208:	80 91 90 00 	lds	r24, 0x0090
     20c:	8e 7f       	andi	r24, 0xFE	; 254
     20e:	0e c0       	rjmp	.+28     	; 0x22c <PWM_Init_timer3_E3+0x32>
	}
	else if( bitRes == 10 )
     210:	8a 30       	cpi	r24, 0x0A	; 10
     212:	21 f4       	brne	.+8      	; 0x21c <PWM_Init_timer3_E3+0x22>
	{	// 10bit mode
		sbi(TCCR3A,PWM11);
     214:	80 91 90 00 	lds	r24, 0x0090
     218:	82 60       	ori	r24, 0x02	; 2
     21a:	03 c0       	rjmp	.+6      	; 0x222 <PWM_Init_timer3_E3+0x28>
		sbi(TCCR3A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3A,PWM11);
     21c:	80 91 90 00 	lds	r24, 0x0090
     220:	8d 7f       	andi	r24, 0xFD	; 253
     222:	80 93 90 00 	sts	0x0090, r24
		sbi(TCCR3A,PWM10);
     226:	80 91 90 00 	lds	r24, 0x0090
     22a:	81 60       	ori	r24, 0x01	; 1
     22c:	80 93 90 00 	sts	0x0090, r24
	}
	// clear output compare values
	OCR3A = 0;
     230:	10 92 99 00 	sts	0x0099, r1
     234:	10 92 98 00 	sts	0x0098, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     238:	08 95       	ret

0000023a <PWM_Init_timer3_E4>:
//pin E4
void PWM_Init_timer3_E4(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     23a:	89 30       	cpi	r24, 0x09	; 9
     23c:	49 f4       	brne	.+18     	; 0x250 <PWM_Init_timer3_E4+0x16>
	{	// 9bit mode
		sbi(TCCR3B,PWM11);
     23e:	80 91 91 00 	lds	r24, 0x0091
     242:	82 60       	ori	r24, 0x02	; 2
     244:	80 93 91 00 	sts	0x0091, r24
		cbi(TCCR3B,PWM10);
     248:	80 91 91 00 	lds	r24, 0x0091
     24c:	8e 7f       	andi	r24, 0xFE	; 254
     24e:	0e c0       	rjmp	.+28     	; 0x26c <PWM_Init_timer3_E4+0x32>
	}
	else if( bitRes == 10 )
     250:	8a 30       	cpi	r24, 0x0A	; 10
     252:	21 f4       	brne	.+8      	; 0x25c <PWM_Init_timer3_E4+0x22>
	{	// 10bit mode
		sbi(TCCR3B,PWM11);
     254:	80 91 91 00 	lds	r24, 0x0091
     258:	82 60       	ori	r24, 0x02	; 2
     25a:	03 c0       	rjmp	.+6      	; 0x262 <PWM_Init_timer3_E4+0x28>
		sbi(TCCR3B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3B,PWM11);
     25c:	80 91 91 00 	lds	r24, 0x0091
     260:	8d 7f       	andi	r24, 0xFD	; 253
     262:	80 93 91 00 	sts	0x0091, r24
		sbi(TCCR3B,PWM10);
     266:	80 91 91 00 	lds	r24, 0x0091
     26a:	81 60       	ori	r24, 0x01	; 1
     26c:	80 93 91 00 	sts	0x0091, r24
	}
	// clear output compare values
	OCR3B = 0;
     270:	10 92 9b 00 	sts	0x009B, r1
     274:	10 92 9a 00 	sts	0x009A, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     278:	08 95       	ret

0000027a <PWM_Init_timer3_E5>:
//pin E5
void PWM_Init_timer3_E5(u08 bitRes)
{
	// enable timer3 as 8,9,10bit PWM
	if(bitRes == 9)
     27a:	89 30       	cpi	r24, 0x09	; 9
     27c:	49 f4       	brne	.+18     	; 0x290 <PWM_Init_timer3_E5+0x16>
	{	// 9bit mode
		sbi(TCCR3C,PWM11);
     27e:	80 91 92 00 	lds	r24, 0x0092
     282:	82 60       	ori	r24, 0x02	; 2
     284:	80 93 92 00 	sts	0x0092, r24
		cbi(TCCR3C,PWM10);
     288:	80 91 92 00 	lds	r24, 0x0092
     28c:	8e 7f       	andi	r24, 0xFE	; 254
     28e:	0e c0       	rjmp	.+28     	; 0x2ac <PWM_Init_timer3_E5+0x32>
	}
	else if( bitRes == 10 )
     290:	8a 30       	cpi	r24, 0x0A	; 10
     292:	21 f4       	brne	.+8      	; 0x29c <PWM_Init_timer3_E5+0x22>
	{	// 10bit mode
		sbi(TCCR3C,PWM11);
     294:	80 91 92 00 	lds	r24, 0x0092
     298:	82 60       	ori	r24, 0x02	; 2
     29a:	03 c0       	rjmp	.+6      	; 0x2a2 <PWM_Init_timer3_E5+0x28>
		sbi(TCCR3C,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR3C,PWM11);
     29c:	80 91 92 00 	lds	r24, 0x0092
     2a0:	8d 7f       	andi	r24, 0xFD	; 253
     2a2:	80 93 92 00 	sts	0x0092, r24
		sbi(TCCR3C,PWM10);
     2a6:	80 91 92 00 	lds	r24, 0x0092
     2aa:	81 60       	ori	r24, 0x01	; 1
     2ac:	80 93 92 00 	sts	0x0092, r24
	}
	// clear output compare values
	OCR3C = 0;
     2b0:	10 92 9d 00 	sts	0x009D, r1
     2b4:	10 92 9c 00 	sts	0x009C, r1
	//timer3PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2b8:	08 95       	ret

000002ba <PWM_Init_timer4_H3>:
//pin H3, timer4
void PWM_Init_timer4_H3(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     2ba:	89 30       	cpi	r24, 0x09	; 9
     2bc:	49 f4       	brne	.+18     	; 0x2d0 <PWM_Init_timer4_H3+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     2be:	80 91 a0 00 	lds	r24, 0x00A0
     2c2:	82 60       	ori	r24, 0x02	; 2
     2c4:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     2c8:	80 91 a0 00 	lds	r24, 0x00A0
     2cc:	8e 7f       	andi	r24, 0xFE	; 254
     2ce:	0e c0       	rjmp	.+28     	; 0x2ec <PWM_Init_timer4_H3+0x32>
	}
	else if( bitRes == 10 )
     2d0:	8a 30       	cpi	r24, 0x0A	; 10
     2d2:	21 f4       	brne	.+8      	; 0x2dc <PWM_Init_timer4_H3+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     2d4:	80 91 a0 00 	lds	r24, 0x00A0
     2d8:	82 60       	ori	r24, 0x02	; 2
     2da:	03 c0       	rjmp	.+6      	; 0x2e2 <PWM_Init_timer4_H3+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     2dc:	80 91 a0 00 	lds	r24, 0x00A0
     2e0:	8d 7f       	andi	r24, 0xFD	; 253
     2e2:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     2e6:	80 91 a0 00 	lds	r24, 0x00A0
     2ea:	81 60       	ori	r24, 0x01	; 1
     2ec:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4A = 0;
     2f0:	10 92 a9 00 	sts	0x00A9, r1
     2f4:	10 92 a8 00 	sts	0x00A8, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     2f8:	08 95       	ret

000002fa <PWM_Init_timer4_H4>:
//pin H4, timer4
void PWM_Init_timer4_H4(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     2fa:	89 30       	cpi	r24, 0x09	; 9
     2fc:	49 f4       	brne	.+18     	; 0x310 <PWM_Init_timer4_H4+0x16>
	{	// 9bit mode
		sbi(TCCR4B,PWM11);
     2fe:	80 91 a1 00 	lds	r24, 0x00A1
     302:	82 60       	ori	r24, 0x02	; 2
     304:	80 93 a1 00 	sts	0x00A1, r24
		cbi(TCCR4B,PWM10);
     308:	80 91 a1 00 	lds	r24, 0x00A1
     30c:	8e 7f       	andi	r24, 0xFE	; 254
     30e:	0e c0       	rjmp	.+28     	; 0x32c <PWM_Init_timer4_H4+0x32>
	}
	else if( bitRes == 10 )
     310:	8a 30       	cpi	r24, 0x0A	; 10
     312:	21 f4       	brne	.+8      	; 0x31c <PWM_Init_timer4_H4+0x22>
	{	// 10bit mode
		sbi(TCCR4B,PWM11);
     314:	80 91 a1 00 	lds	r24, 0x00A1
     318:	82 60       	ori	r24, 0x02	; 2
     31a:	03 c0       	rjmp	.+6      	; 0x322 <PWM_Init_timer4_H4+0x28>
		sbi(TCCR4B,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4B,PWM11);
     31c:	80 91 a1 00 	lds	r24, 0x00A1
     320:	8d 7f       	andi	r24, 0xFD	; 253
     322:	80 93 a1 00 	sts	0x00A1, r24
		sbi(TCCR4B,PWM10);
     326:	80 91 a1 00 	lds	r24, 0x00A1
     32a:	81 60       	ori	r24, 0x01	; 1
     32c:	80 93 a1 00 	sts	0x00A1, r24
	}
	// clear output compare values
	OCR4B = 0;
     330:	10 92 ab 00 	sts	0x00AB, r1
     334:	10 92 aa 00 	sts	0x00AA, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     338:	08 95       	ret

0000033a <PWM_Init_timer4_H5>:
//pin H5, timer4
void PWM_Init_timer4_H5(u08 bitRes)
{
	// enable timer4 as 8,9,10bit PWM
	if(bitRes == 9)
     33a:	89 30       	cpi	r24, 0x09	; 9
     33c:	49 f4       	brne	.+18     	; 0x350 <PWM_Init_timer4_H5+0x16>
	{	// 9bit mode
		sbi(TCCR4A,PWM11);
     33e:	80 91 a0 00 	lds	r24, 0x00A0
     342:	82 60       	ori	r24, 0x02	; 2
     344:	80 93 a0 00 	sts	0x00A0, r24
		cbi(TCCR4A,PWM10);
     348:	80 91 a0 00 	lds	r24, 0x00A0
     34c:	8e 7f       	andi	r24, 0xFE	; 254
     34e:	0e c0       	rjmp	.+28     	; 0x36c <PWM_Init_timer4_H5+0x32>
	}
	else if( bitRes == 10 )
     350:	8a 30       	cpi	r24, 0x0A	; 10
     352:	21 f4       	brne	.+8      	; 0x35c <PWM_Init_timer4_H5+0x22>
	{	// 10bit mode
		sbi(TCCR4A,PWM11);
     354:	80 91 a0 00 	lds	r24, 0x00A0
     358:	82 60       	ori	r24, 0x02	; 2
     35a:	03 c0       	rjmp	.+6      	; 0x362 <PWM_Init_timer4_H5+0x28>
		sbi(TCCR4A,PWM10);
	}
	else
	{	// default 8bit mode
		cbi(TCCR4A,PWM11);
     35c:	80 91 a0 00 	lds	r24, 0x00A0
     360:	8d 7f       	andi	r24, 0xFD	; 253
     362:	80 93 a0 00 	sts	0x00A0, r24
		sbi(TCCR4A,PWM10);
     366:	80 91 a0 00 	lds	r24, 0x00A0
     36a:	81 60       	ori	r24, 0x01	; 1
     36c:	80 93 a0 00 	sts	0x00A0, r24
	}
	// clear output compare values
	OCR4C = 0;
     370:	10 92 ad 00 	sts	0x00AD, r1
     374:	10 92 ac 00 	sts	0x00AC, r1
	//timer4PWMInitICR(20000);// 20mS PWM cycle time for RC servos
}
     378:	08 95       	ret

0000037a <timer1PWMInitICR>:
// include support for arbitrary top-count PWM
// on new AVR processors that support it
void timer1PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR1A,WGM10);
     37a:	e0 e8       	ldi	r30, 0x80	; 128
     37c:	f0 e0       	ldi	r31, 0x00	; 0
     37e:	20 81       	ld	r18, Z
     380:	2e 7f       	andi	r18, 0xFE	; 254
     382:	20 83       	st	Z, r18
	sbi(TCCR1A,WGM11);
     384:	20 81       	ld	r18, Z
     386:	22 60       	ori	r18, 0x02	; 2
     388:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM12);
     38a:	e1 e8       	ldi	r30, 0x81	; 129
     38c:	f0 e0       	ldi	r31, 0x00	; 0
     38e:	20 81       	ld	r18, Z
     390:	28 60       	ori	r18, 0x08	; 8
     392:	20 83       	st	Z, r18
	sbi(TCCR1B,WGM13);
     394:	20 81       	ld	r18, Z
     396:	20 61       	ori	r18, 0x10	; 16
     398:	20 83       	st	Z, r18
	
	// set top count value
	ICR1 = topcount;
     39a:	90 93 87 00 	sts	0x0087, r25
     39e:	80 93 86 00 	sts	0x0086, r24
	
	// clear output compare values
	OCR1A = 0;
     3a2:	10 92 89 00 	sts	0x0089, r1
     3a6:	10 92 88 00 	sts	0x0088, r1
	OCR1B = 0;
     3aa:	10 92 8b 00 	sts	0x008B, r1
     3ae:	10 92 8a 00 	sts	0x008A, r1
	OCR1C = 0;
     3b2:	10 92 8d 00 	sts	0x008D, r1
     3b6:	10 92 8c 00 	sts	0x008C, r1
}
     3ba:	08 95       	ret

000003bc <timer3PWMInitICR>:
void timer3PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR3A,WGM10);
     3bc:	e0 e9       	ldi	r30, 0x90	; 144
     3be:	f0 e0       	ldi	r31, 0x00	; 0
     3c0:	20 81       	ld	r18, Z
     3c2:	2e 7f       	andi	r18, 0xFE	; 254
     3c4:	20 83       	st	Z, r18
	sbi(TCCR3A,WGM11);
     3c6:	20 81       	ld	r18, Z
     3c8:	22 60       	ori	r18, 0x02	; 2
     3ca:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM12);
     3cc:	e1 e9       	ldi	r30, 0x91	; 145
     3ce:	f0 e0       	ldi	r31, 0x00	; 0
     3d0:	20 81       	ld	r18, Z
     3d2:	28 60       	ori	r18, 0x08	; 8
     3d4:	20 83       	st	Z, r18
	sbi(TCCR3B,WGM13);
     3d6:	20 81       	ld	r18, Z
     3d8:	20 61       	ori	r18, 0x10	; 16
     3da:	20 83       	st	Z, r18
	
	// set top count value
	ICR3 = topcount;
     3dc:	90 93 97 00 	sts	0x0097, r25
     3e0:	80 93 96 00 	sts	0x0096, r24
	
	// clear output compare values
	OCR3A = 0;
     3e4:	10 92 99 00 	sts	0x0099, r1
     3e8:	10 92 98 00 	sts	0x0098, r1
	OCR3B = 0;
     3ec:	10 92 9b 00 	sts	0x009B, r1
     3f0:	10 92 9a 00 	sts	0x009A, r1
	OCR3C = 0;
     3f4:	10 92 9d 00 	sts	0x009D, r1
     3f8:	10 92 9c 00 	sts	0x009C, r1
}
     3fc:	08 95       	ret

000003fe <timer4PWMInitICR>:
void timer4PWMInitICR(u16 topcount)
{
	// set PWM mode with ICR top-count
	cbi(TCCR4A,WGM10);
     3fe:	e0 ea       	ldi	r30, 0xA0	; 160
     400:	f0 e0       	ldi	r31, 0x00	; 0
     402:	20 81       	ld	r18, Z
     404:	2e 7f       	andi	r18, 0xFE	; 254
     406:	20 83       	st	Z, r18
	sbi(TCCR4A,WGM11);
     408:	20 81       	ld	r18, Z
     40a:	22 60       	ori	r18, 0x02	; 2
     40c:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM12);
     40e:	e1 ea       	ldi	r30, 0xA1	; 161
     410:	f0 e0       	ldi	r31, 0x00	; 0
     412:	20 81       	ld	r18, Z
     414:	28 60       	ori	r18, 0x08	; 8
     416:	20 83       	st	Z, r18
	sbi(TCCR4B,WGM13);
     418:	20 81       	ld	r18, Z
     41a:	20 61       	ori	r18, 0x10	; 16
     41c:	20 83       	st	Z, r18
	
	// set top count value
	ICR4 = topcount;
     41e:	90 93 a7 00 	sts	0x00A7, r25
     422:	80 93 a6 00 	sts	0x00A6, r24
	
	// clear output compare values
	OCR4A = 0;
     426:	10 92 a9 00 	sts	0x00A9, r1
     42a:	10 92 a8 00 	sts	0x00A8, r1
	OCR4B = 0;
     42e:	10 92 ab 00 	sts	0x00AB, r1
     432:	10 92 aa 00 	sts	0x00AA, r1
	OCR4C = 0;
     436:	10 92 ad 00 	sts	0x00AD, r1
     43a:	10 92 ac 00 	sts	0x00AC, r1
}
     43e:	08 95       	ret

00000440 <PWM_timer1_On_LED>:
#endif

//on commands
void PWM_timer1_On_LED(void)
{
	sbi(TCCR1A,COM1B1);
     440:	e0 e8       	ldi	r30, 0x80	; 128
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	80 81       	ld	r24, Z
     446:	80 62       	ori	r24, 0x20	; 32
     448:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     44a:	80 81       	ld	r24, Z
     44c:	8f 7e       	andi	r24, 0xEF	; 239
     44e:	80 83       	st	Z, r24
}
     450:	08 95       	ret

00000452 <PWM_timer2_On_H6>:
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     452:	e0 eb       	ldi	r30, 0xB0	; 176
     454:	f0 e0       	ldi	r31, 0x00	; 0
     456:	80 81       	ld	r24, Z
     458:	80 62       	ori	r24, 0x20	; 32
     45a:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     45c:	80 81       	ld	r24, Z
     45e:	8f 7e       	andi	r24, 0xEF	; 239
     460:	80 83       	st	Z, r24
}
     462:	08 95       	ret

00000464 <PWM_timer3_On_E3>:
void PWM_timer3_On_E3(void)
{
	sbi(TCCR3A,COM3A1);
     464:	e0 e9       	ldi	r30, 0x90	; 144
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	80 81       	ld	r24, Z
     46a:	80 68       	ori	r24, 0x80	; 128
     46c:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     46e:	80 81       	ld	r24, Z
     470:	8f 7b       	andi	r24, 0xBF	; 191
     472:	80 83       	st	Z, r24
}
     474:	08 95       	ret

00000476 <PWM_timer3_On_E4>:
void PWM_timer3_On_E4(void)
{
	sbi(TCCR3A,COM3B1);
     476:	e0 e9       	ldi	r30, 0x90	; 144
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	80 81       	ld	r24, Z
     47c:	80 62       	ori	r24, 0x20	; 32
     47e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     480:	80 81       	ld	r24, Z
     482:	8f 7e       	andi	r24, 0xEF	; 239
     484:	80 83       	st	Z, r24
}
     486:	08 95       	ret

00000488 <PWM_timer3_On_E5>:
void PWM_timer3_On_E5(void)
{
	sbi(TCCR3A,COM3C1);
     488:	e0 e9       	ldi	r30, 0x90	; 144
     48a:	f0 e0       	ldi	r31, 0x00	; 0
     48c:	80 81       	ld	r24, Z
     48e:	88 60       	ori	r24, 0x08	; 8
     490:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     492:	80 81       	ld	r24, Z
     494:	8b 7f       	andi	r24, 0xFB	; 251
     496:	80 83       	st	Z, r24
}
     498:	08 95       	ret

0000049a <PWM_timer4_On_H3>:
void PWM_timer4_On_H3(void)
{
	sbi(TCCR4A,COM4A1);
     49a:	e0 ea       	ldi	r30, 0xA0	; 160
     49c:	f0 e0       	ldi	r31, 0x00	; 0
     49e:	80 81       	ld	r24, Z
     4a0:	80 68       	ori	r24, 0x80	; 128
     4a2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     4a4:	80 81       	ld	r24, Z
     4a6:	8f 7b       	andi	r24, 0xBF	; 191
     4a8:	80 83       	st	Z, r24
}
     4aa:	08 95       	ret

000004ac <PWM_timer4_On_H4>:
void PWM_timer4_On_H4(void)
{
	sbi(TCCR4A,COM4B1);
     4ac:	e0 ea       	ldi	r30, 0xA0	; 160
     4ae:	f0 e0       	ldi	r31, 0x00	; 0
     4b0:	80 81       	ld	r24, Z
     4b2:	80 62       	ori	r24, 0x20	; 32
     4b4:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     4b6:	80 81       	ld	r24, Z
     4b8:	8f 7e       	andi	r24, 0xEF	; 239
     4ba:	80 83       	st	Z, r24
}
     4bc:	08 95       	ret

000004be <PWM_timer4_On_H5>:
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     4be:	e0 ea       	ldi	r30, 0xA0	; 160
     4c0:	f0 e0       	ldi	r31, 0x00	; 0
     4c2:	80 81       	ld	r24, Z
     4c4:	88 60       	ori	r24, 0x08	; 8
     4c6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     4c8:	80 81       	ld	r24, Z
     4ca:	8b 7f       	andi	r24, 0xFB	; 251
     4cc:	80 83       	st	Z, r24
}
     4ce:	08 95       	ret

000004d0 <PWM_timer1_Off_LED>:

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     4d0:	e0 e8       	ldi	r30, 0x80	; 128
     4d2:	f0 e0       	ldi	r31, 0x00	; 0
     4d4:	80 81       	ld	r24, Z
     4d6:	8f 7d       	andi	r24, 0xDF	; 223
     4d8:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     4da:	80 81       	ld	r24, Z
     4dc:	8f 7e       	andi	r24, 0xEF	; 239
     4de:	80 83       	st	Z, r24
}
     4e0:	08 95       	ret

000004e2 <PWM_timer2_Off_H6>:
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     4e2:	e0 eb       	ldi	r30, 0xB0	; 176
     4e4:	f0 e0       	ldi	r31, 0x00	; 0
     4e6:	80 81       	ld	r24, Z
     4e8:	8f 7d       	andi	r24, 0xDF	; 223
     4ea:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     4ec:	80 81       	ld	r24, Z
     4ee:	8f 7e       	andi	r24, 0xEF	; 239
     4f0:	80 83       	st	Z, r24
}
     4f2:	08 95       	ret

000004f4 <PWM_timer3_Off_E3>:
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     4f4:	e0 e9       	ldi	r30, 0x90	; 144
     4f6:	f0 e0       	ldi	r31, 0x00	; 0
     4f8:	80 81       	ld	r24, Z
     4fa:	8f 77       	andi	r24, 0x7F	; 127
     4fc:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     4fe:	80 81       	ld	r24, Z
     500:	8f 7b       	andi	r24, 0xBF	; 191
     502:	80 83       	st	Z, r24
}
     504:	08 95       	ret

00000506 <PWM_timer3_Off_E4>:
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     506:	e0 e9       	ldi	r30, 0x90	; 144
     508:	f0 e0       	ldi	r31, 0x00	; 0
     50a:	80 81       	ld	r24, Z
     50c:	8f 7d       	andi	r24, 0xDF	; 223
     50e:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     510:	80 81       	ld	r24, Z
     512:	8f 7e       	andi	r24, 0xEF	; 239
     514:	80 83       	st	Z, r24
}
     516:	08 95       	ret

00000518 <PWM_timer3_Off_E5>:
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     518:	e0 e9       	ldi	r30, 0x90	; 144
     51a:	f0 e0       	ldi	r31, 0x00	; 0
     51c:	80 81       	ld	r24, Z
     51e:	87 7f       	andi	r24, 0xF7	; 247
     520:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     522:	80 81       	ld	r24, Z
     524:	8b 7f       	andi	r24, 0xFB	; 251
     526:	80 83       	st	Z, r24
}
     528:	08 95       	ret

0000052a <PWM_timer4_Off_H3>:
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     52a:	e0 ea       	ldi	r30, 0xA0	; 160
     52c:	f0 e0       	ldi	r31, 0x00	; 0
     52e:	80 81       	ld	r24, Z
     530:	8f 77       	andi	r24, 0x7F	; 127
     532:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     534:	80 81       	ld	r24, Z
     536:	8f 7b       	andi	r24, 0xBF	; 191
     538:	80 83       	st	Z, r24
}
     53a:	08 95       	ret

0000053c <PWM_timer4_Off_H4>:
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     53c:	e0 ea       	ldi	r30, 0xA0	; 160
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	80 81       	ld	r24, Z
     542:	8f 7d       	andi	r24, 0xDF	; 223
     544:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     546:	80 81       	ld	r24, Z
     548:	8f 7e       	andi	r24, 0xEF	; 239
     54a:	80 83       	st	Z, r24
}
     54c:	08 95       	ret

0000054e <PWM_timer4_Off_H5>:
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     54e:	e0 ea       	ldi	r30, 0xA0	; 160
     550:	f0 e0       	ldi	r31, 0x00	; 0
     552:	80 81       	ld	r24, Z
     554:	87 7f       	andi	r24, 0xF7	; 247
     556:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     558:	80 81       	ld	r24, Z
     55a:	8b 7f       	andi	r24, 0xFB	; 251
     55c:	80 83       	st	Z, r24
}
     55e:	08 95       	ret

00000560 <PWM_timer1_Off_All>:


void PWM_timer1_Off_All(void)
{
	cbi(TCCR1A,PWM11);
     560:	e0 e8       	ldi	r30, 0x80	; 128
     562:	f0 e0       	ldi	r31, 0x00	; 0
     564:	80 81       	ld	r24, Z
     566:	8d 7f       	andi	r24, 0xFD	; 253
     568:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM10);
     56a:	80 81       	ld	r24, Z
     56c:	8e 7f       	andi	r24, 0xFE	; 254
     56e:	80 83       	st	Z, r24
}

//off commands
void PWM_timer1_Off_LED(void)
{
	cbi(TCCR1A,COM1B1);
     570:	80 81       	ld	r24, Z
     572:	8f 7d       	andi	r24, 0xDF	; 223
     574:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B0);
     576:	80 81       	ld	r24, Z
     578:	8f 7e       	andi	r24, 0xEF	; 239
     57a:	80 83       	st	Z, r24
	cbi(TCCR1A,PWM11);
	cbi(TCCR1A,PWM10);
	//timer2PWMAOff();
	PWM_timer1_Off_LED();
	//timer2PWMCOff();
}
     57c:	08 95       	ret

0000057e <PWM_timer2_Off_All>:
void PWM_timer2_Off_All(void)
{
	cbi(TCCR2A,PWM11);
     57e:	e0 eb       	ldi	r30, 0xB0	; 176
     580:	f0 e0       	ldi	r31, 0x00	; 0
     582:	80 81       	ld	r24, Z
     584:	8d 7f       	andi	r24, 0xFD	; 253
     586:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM10);
     588:	80 81       	ld	r24, Z
     58a:	8e 7f       	andi	r24, 0xFE	; 254
     58c:	80 83       	st	Z, r24
	cbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_Off_H6(void)
{
	cbi(TCCR2A,COM2B1);
     58e:	80 81       	ld	r24, Z
     590:	8f 7d       	andi	r24, 0xDF	; 223
     592:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     594:	80 81       	ld	r24, Z
     596:	8f 7e       	andi	r24, 0xEF	; 239
     598:	80 83       	st	Z, r24
	cbi(TCCR2A,PWM11);
	cbi(TCCR2A,PWM10);
	//timer2PWMAOff();
	PWM_timer2_Off_H6();
	//timer2PWMCOff();
}
     59a:	08 95       	ret

0000059c <PWM_timer3_Off_All>:
void PWM_timer3_Off_All(void)
{
	cbi(TCCR3A,PWM11);
     59c:	e0 e9       	ldi	r30, 0x90	; 144
     59e:	f0 e0       	ldi	r31, 0x00	; 0
     5a0:	80 81       	ld	r24, Z
     5a2:	8d 7f       	andi	r24, 0xFD	; 253
     5a4:	80 83       	st	Z, r24
	cbi(TCCR3A,PWM10);
     5a6:	80 81       	ld	r24, Z
     5a8:	8e 7f       	andi	r24, 0xFE	; 254
     5aa:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B1);
	cbi(TCCR2A,COM2B0);
}
void PWM_timer3_Off_E3(void)
{
	cbi(TCCR3A,COM3A1);
     5ac:	80 81       	ld	r24, Z
     5ae:	8f 77       	andi	r24, 0x7F	; 127
     5b0:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3A0);
     5b2:	80 81       	ld	r24, Z
     5b4:	8f 7b       	andi	r24, 0xBF	; 191
     5b6:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E4(void)
{
	cbi(TCCR3A,COM3B1);
     5b8:	80 81       	ld	r24, Z
     5ba:	8f 7d       	andi	r24, 0xDF	; 223
     5bc:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3B0);
     5be:	80 81       	ld	r24, Z
     5c0:	8f 7e       	andi	r24, 0xEF	; 239
     5c2:	80 83       	st	Z, r24
}
void PWM_timer3_Off_E5(void)
{
	cbi(TCCR3A,COM3C1);
     5c4:	80 81       	ld	r24, Z
     5c6:	87 7f       	andi	r24, 0xF7	; 247
     5c8:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C0);
     5ca:	80 81       	ld	r24, Z
     5cc:	8b 7f       	andi	r24, 0xFB	; 251
     5ce:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer3_Off_E3();
	PWM_timer3_Off_E4();
	PWM_timer3_Off_E5();
	//timer2PWMCOff();
}
     5d0:	08 95       	ret

000005d2 <PWM_timer4_Off_All>:
void PWM_timer4_Off_All(void)
{
	cbi(TCCR4A,PWM11);
     5d2:	e0 ea       	ldi	r30, 0xA0	; 160
     5d4:	f0 e0       	ldi	r31, 0x00	; 0
     5d6:	80 81       	ld	r24, Z
     5d8:	8d 7f       	andi	r24, 0xFD	; 253
     5da:	80 83       	st	Z, r24
	cbi(TCCR4A,PWM10);
     5dc:	80 81       	ld	r24, Z
     5de:	8e 7f       	andi	r24, 0xFE	; 254
     5e0:	80 83       	st	Z, r24
	cbi(TCCR3A,COM3C1);
	cbi(TCCR3A,COM3C0);
}
void PWM_timer4_Off_H3(void)
{
	cbi(TCCR4A,COM4A1);
     5e2:	80 81       	ld	r24, Z
     5e4:	8f 77       	andi	r24, 0x7F	; 127
     5e6:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4A0);
     5e8:	80 81       	ld	r24, Z
     5ea:	8f 7b       	andi	r24, 0xBF	; 191
     5ec:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H4(void)
{
	cbi(TCCR4A,COM4B1);
     5ee:	80 81       	ld	r24, Z
     5f0:	8f 7d       	andi	r24, 0xDF	; 223
     5f2:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4B0);
     5f4:	80 81       	ld	r24, Z
     5f6:	8f 7e       	andi	r24, 0xEF	; 239
     5f8:	80 83       	st	Z, r24
}
void PWM_timer4_Off_H5(void)
{
	cbi(TCCR4A,COM4C1);
     5fa:	80 81       	ld	r24, Z
     5fc:	87 7f       	andi	r24, 0xF7	; 247
     5fe:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     600:	80 81       	ld	r24, Z
     602:	8b 7f       	andi	r24, 0xFB	; 251
     604:	80 83       	st	Z, r24
	//timer2PWMAOff();
	PWM_timer4_Off_H3();
	PWM_timer4_Off_H4();
	PWM_timer4_Off_H5();
	//timer2PWMCOff();
}
     606:	08 95       	ret

00000608 <PWM_timer1_Set_LED>:
// this PWM output is generated on OC2B pin
// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
     608:	90 93 8b 00 	sts	0x008B, r25
     60c:	80 93 8a 00 	sts	0x008A, r24
     610:	08 95       	ret

00000612 <PWM_timer2_Set_H6>:
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     612:	80 93 b4 00 	sts	0x00B4, r24
     616:	08 95       	ret

00000618 <PWM_timer3_Set_E3>:
void PWM_timer3_Set_E3(u16 pwmDuty)
	{OCR3A = pwmDuty;}
     618:	90 93 99 00 	sts	0x0099, r25
     61c:	80 93 98 00 	sts	0x0098, r24
     620:	08 95       	ret

00000622 <PWM_timer3_Set_E4>:
void PWM_timer3_Set_E4(u16 pwmDuty)
	{OCR3B = pwmDuty;}
     622:	90 93 9b 00 	sts	0x009B, r25
     626:	80 93 9a 00 	sts	0x009A, r24
     62a:	08 95       	ret

0000062c <PWM_timer3_Set_E5>:
void PWM_timer3_Set_E5(u16 pwmDuty)
	{OCR3C = pwmDuty;}
     62c:	90 93 9d 00 	sts	0x009D, r25
     630:	80 93 9c 00 	sts	0x009C, r24
     634:	08 95       	ret

00000636 <PWM_timer4_Set_H3>:
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
     636:	90 93 a9 00 	sts	0x00A9, r25
     63a:	80 93 a8 00 	sts	0x00A8, r24
     63e:	08 95       	ret

00000640 <PWM_timer4_Set_H4>:
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
     640:	90 93 ab 00 	sts	0x00AB, r25
     644:	80 93 aa 00 	sts	0x00AA, r24
     648:	08 95       	ret

0000064a <PWM_timer4_Set_H5>:
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     64a:	90 93 ad 00 	sts	0x00AD, r25
     64e:	80 93 ac 00 	sts	0x00AC, r24
     652:	08 95       	ret

00000654 <configure_ports>:
	//cbi(DDRG, PG5);  //set G5 as input pin

	//ANALOG PORTS
	//useful for sensors, SharpIR, photoresistors, etc.
	//analog ports can be configured as digital ports if desired
	DDRF = 0b00000000;  //configure all F ports for input				0x00
     654:	10 ba       	out	0x10, r1	; 16
	PORTF = 0b00000000; //make sure pull-up resistors are turned off	0x00
     656:	11 ba       	out	0x11, r1	; 17
	DDRK = 0b00000000;  //configure all K ports for input				0x00
     658:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0b00000000; //make sure pull-up resistors are turned off	0x00
     65c:	10 92 08 01 	sts	0x0108, r1

	//DIGITAL PORTS
	//useful for servos, PWM, LED's, UART, interrupts, timers
	DDRA = 0b11111111;  //configure ports for output
     660:	9f ef       	ldi	r25, 0xFF	; 255
     662:	91 b9       	out	0x01, r25	; 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTB reserved for programmer (use programmer pins if you know what you are doing)
	DDRB = _BV (PB6);	//PB6 is LED, hold low to turn it on
     664:	80 e4       	ldi	r24, 0x40	; 64
     666:	84 b9       	out	0x04, r24	; 4
	DDRC = 0b11111111;  //configure ports for output
     668:	97 b9       	out	0x07, r25	; 7
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 	
	sbi(PORTD, PD0); // SCL pull-up
     66a:	58 9a       	sbi	0x0b, 0	; 11
	sbi(PORTD, PD1); // SDA pull-up
     66c:	59 9a       	sbi	0x0b, 1	; 11
	DDRD = 0b11110011;  //configure ports for output
     66e:	83 ef       	ldi	r24, 0xF3	; 243
     670:	8a b9       	out	0x0a, r24	; 10
	//       ||||\______3: serial TXD1, output -> 1
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: timer0
	DDRE = 0b11111110;  //configure ports for output
     672:	8e ef       	ldi	r24, 0xFE	; 254
     674:	8d b9       	out	0x0d, r24	; 13
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//cbi(PORTG, PG5);  // disable pull-up resistor for Axon v1e and earlier
	sbi(PORTG, PG5);  // enable pull-up resistor for v1f and later
     676:	a5 9a       	sbi	0x14, 5	; 20
	cbi(DDRG, PG5);	//PG5 is for the button, make a digital input
     678:	9d 98       	cbi	0x13, 5	; 19
	//note that button actions are inverted between both versions!!!
	DDRH = 0b11111110;  //configure ports for output
     67a:	80 93 01 01 	sts	0x0101, r24
	//       ||||\______3: 
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	DDRJ = 0b11111110;  //configure ports for output
     67e:	80 93 04 01 	sts	0x0104, r24
	//       |||\_______4: 
	//       ||\________5: 
	//       |\_________6: 
	//       \__________7: 
	//PORTL has no headers
	};
     682:	08 95       	ret

00000684 <delay_cycles>:
void delay_cycles(unsigned long int cycles)
	{
	cycles=cycles;//doubled frequency but too lazy to change times
	while(cycles > 0)
		cycles--;
	}
     684:	08 95       	ret

00000686 <LED_off>:


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     686:	2e 9a       	sbi	0x05, 6	; 5
     688:	08 95       	ret

0000068a <LED_on>:
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     68a:	2e 98       	cbi	0x05, 6	; 5
     68c:	08 95       	ret

0000068e <button_pressed>:


//*****************BUTTON****************
int button_pressed(void)
	{
	return (bit_is_clear(PING, 5));
     68e:	22 b3       	in	r18, 0x12	; 18
     690:	30 e0       	ldi	r19, 0x00	; 0
     692:	85 e0       	ldi	r24, 0x05	; 5
     694:	36 95       	lsr	r19
     696:	27 95       	ror	r18
     698:	8a 95       	dec	r24
     69a:	e1 f7       	brne	.-8      	; 0x694 <button_pressed+0x6>
     69c:	20 95       	com	r18
     69e:	30 95       	com	r19
     6a0:	21 70       	andi	r18, 0x01	; 1
     6a2:	30 70       	andi	r19, 0x00	; 0
	//return ((PING) & (1<<PG5));//old version, went high when button pushed
	}
     6a4:	c9 01       	movw	r24, r18
     6a6:	08 95       	ret

000006a8 <cos_SoR>:
signed int angtable[73]={100,100,98,97,94,91,87,82,77,71,64,57,50,42,34,26,17,9,0,-9,-17,-26,-34,-42,-50,-57,-64,-71,-77,-82,-87,-91,-94,-97,-98,-100,
						 -100,-100,-98,-97,-94,-91,-87,-82,-77,-71,-64,-57,-50,-42,-34,-26,-17,-9,0,9,17,26,34,42,50,57,64,71,77,82,87,91,94,97,98,100,100};

signed int cos_SoR(long signed int degrees)//returns cos*100
	{
	if (degrees >= 0)//positive angles
     6a8:	97 fd       	sbrc	r25, 7
     6aa:	10 c0       	rjmp	.+32     	; 0x6cc <cos_SoR+0x24>
		return angtable[degrees/5];
     6ac:	25 e0       	ldi	r18, 0x05	; 5
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	40 e0       	ldi	r20, 0x00	; 0
     6b2:	50 e0       	ldi	r21, 0x00	; 0
     6b4:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <__divmodsi4>
     6b8:	da 01       	movw	r26, r20
     6ba:	c9 01       	movw	r24, r18
     6bc:	88 0f       	add	r24, r24
     6be:	99 1f       	adc	r25, r25
     6c0:	80 50       	subi	r24, 0x00	; 0
     6c2:	9e 4f       	sbci	r25, 0xFE	; 254
     6c4:	fc 01       	movw	r30, r24
     6c6:	20 81       	ld	r18, Z
     6c8:	31 81       	ldd	r19, Z+1	; 0x01
     6ca:	17 c0       	rjmp	.+46     	; 0x6fa <cos_SoR+0x52>
	else
		return -angtable[72-(-degrees)/5];
     6cc:	25 e0       	ldi	r18, 0x05	; 5
     6ce:	30 e0       	ldi	r19, 0x00	; 0
     6d0:	40 e0       	ldi	r20, 0x00	; 0
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <__divmodsi4>
     6d8:	da 01       	movw	r26, r20
     6da:	c9 01       	movw	r24, r18
     6dc:	88 5b       	subi	r24, 0xB8	; 184
     6de:	9f 4f       	sbci	r25, 0xFF	; 255
     6e0:	af 4f       	sbci	r26, 0xFF	; 255
     6e2:	bf 4f       	sbci	r27, 0xFF	; 255
     6e4:	88 0f       	add	r24, r24
     6e6:	99 1f       	adc	r25, r25
     6e8:	80 50       	subi	r24, 0x00	; 0
     6ea:	9e 4f       	sbci	r25, 0xFE	; 254
     6ec:	fc 01       	movw	r30, r24
     6ee:	80 81       	ld	r24, Z
     6f0:	91 81       	ldd	r25, Z+1	; 0x01
     6f2:	22 27       	eor	r18, r18
     6f4:	33 27       	eor	r19, r19
     6f6:	28 1b       	sub	r18, r24
     6f8:	39 0b       	sbc	r19, r25
	}
     6fa:	c9 01       	movw	r24, r18
     6fc:	08 95       	ret

000006fe <sin_SoR>:

signed int sin_SoR(long signed int degrees)//returns sin*100
	{
	degrees=degrees - 90;//phase shift 90 degrees
     6fe:	6a 55       	subi	r22, 0x5A	; 90
     700:	70 40       	sbci	r23, 0x00	; 0
     702:	80 40       	sbci	r24, 0x00	; 0
     704:	90 40       	sbci	r25, 0x00	; 0

	if (degrees >= 0)//positive angles
     706:	97 fd       	sbrc	r25, 7
     708:	10 c0       	rjmp	.+32     	; 0x72a <sin_SoR+0x2c>
		return angtable[degrees/5];
     70a:	25 e0       	ldi	r18, 0x05	; 5
     70c:	30 e0       	ldi	r19, 0x00	; 0
     70e:	40 e0       	ldi	r20, 0x00	; 0
     710:	50 e0       	ldi	r21, 0x00	; 0
     712:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <__divmodsi4>
     716:	da 01       	movw	r26, r20
     718:	c9 01       	movw	r24, r18
     71a:	88 0f       	add	r24, r24
     71c:	99 1f       	adc	r25, r25
     71e:	80 50       	subi	r24, 0x00	; 0
     720:	9e 4f       	sbci	r25, 0xFE	; 254
     722:	fc 01       	movw	r30, r24
     724:	20 81       	ld	r18, Z
     726:	31 81       	ldd	r19, Z+1	; 0x01
     728:	17 c0       	rjmp	.+46     	; 0x758 <sin_SoR+0x5a>
	else
		return -angtable[72-(-degrees)/5];
     72a:	25 e0       	ldi	r18, 0x05	; 5
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	40 e0       	ldi	r20, 0x00	; 0
     730:	50 e0       	ldi	r21, 0x00	; 0
     732:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <__divmodsi4>
     736:	da 01       	movw	r26, r20
     738:	c9 01       	movw	r24, r18
     73a:	88 5b       	subi	r24, 0xB8	; 184
     73c:	9f 4f       	sbci	r25, 0xFF	; 255
     73e:	af 4f       	sbci	r26, 0xFF	; 255
     740:	bf 4f       	sbci	r27, 0xFF	; 255
     742:	88 0f       	add	r24, r24
     744:	99 1f       	adc	r25, r25
     746:	80 50       	subi	r24, 0x00	; 0
     748:	9e 4f       	sbci	r25, 0xFE	; 254
     74a:	fc 01       	movw	r30, r24
     74c:	80 81       	ld	r24, Z
     74e:	91 81       	ldd	r25, Z+1	; 0x01
     750:	22 27       	eor	r18, r18
     752:	33 27       	eor	r19, r19
     754:	28 1b       	sub	r18, r24
     756:	39 0b       	sbc	r19, r25
	}
     758:	c9 01       	movw	r24, r18
     75a:	08 95       	ret

0000075c <tan_SoR>:

signed int tan_SoR(long signed int degrees)//returns tan * 10
	{
     75c:	cf 92       	push	r12
     75e:	df 92       	push	r13
     760:	ef 92       	push	r14
     762:	ff 92       	push	r15
     764:	0f 93       	push	r16
     766:	1f 93       	push	r17
     768:	6b 01       	movw	r12, r22
     76a:	7c 01       	movw	r14, r24
	//tan(x) = sin(x)/cos(x)
	if (degrees == 90 || degrees == -90 || degrees == 270 || degrees == -270)//blows up
     76c:	8a e5       	ldi	r24, 0x5A	; 90
     76e:	c8 16       	cp	r12, r24
     770:	d1 04       	cpc	r13, r1
     772:	e1 04       	cpc	r14, r1
     774:	f1 04       	cpc	r15, r1
     776:	a1 f1       	breq	.+104    	; 0x7e0 <tan_SoR+0x84>
     778:	86 ea       	ldi	r24, 0xA6	; 166
     77a:	c8 16       	cp	r12, r24
     77c:	8f ef       	ldi	r24, 0xFF	; 255
     77e:	d8 06       	cpc	r13, r24
     780:	8f ef       	ldi	r24, 0xFF	; 255
     782:	e8 06       	cpc	r14, r24
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	f8 06       	cpc	r15, r24
     788:	59 f1       	breq	.+86     	; 0x7e0 <tan_SoR+0x84>
     78a:	8e e0       	ldi	r24, 0x0E	; 14
     78c:	c8 16       	cp	r12, r24
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	d8 06       	cpc	r13, r24
     792:	80 e0       	ldi	r24, 0x00	; 0
     794:	e8 06       	cpc	r14, r24
     796:	80 e0       	ldi	r24, 0x00	; 0
     798:	f8 06       	cpc	r15, r24
     79a:	11 f1       	breq	.+68     	; 0x7e0 <tan_SoR+0x84>
     79c:	82 ef       	ldi	r24, 0xF2	; 242
     79e:	c8 16       	cp	r12, r24
     7a0:	8e ef       	ldi	r24, 0xFE	; 254
     7a2:	d8 06       	cpc	r13, r24
     7a4:	8f ef       	ldi	r24, 0xFF	; 255
     7a6:	e8 06       	cpc	r14, r24
     7a8:	8f ef       	ldi	r24, 0xFF	; 255
     7aa:	f8 06       	cpc	r15, r24
     7ac:	c9 f0       	breq	.+50     	; 0x7e0 <tan_SoR+0x84>
		return 0;//what else should I return?!?!?
	return sin_SoR(degrees)/cos_SoR(degrees)*10;
     7ae:	c7 01       	movw	r24, r14
     7b0:	b6 01       	movw	r22, r12
     7b2:	0e 94 7f 03 	call	0x6fe	; 0x6fe <sin_SoR>
     7b6:	8c 01       	movw	r16, r24
     7b8:	c7 01       	movw	r24, r14
     7ba:	b6 01       	movw	r22, r12
     7bc:	0e 94 54 03 	call	0x6a8	; 0x6a8 <cos_SoR>
     7c0:	bc 01       	movw	r22, r24
     7c2:	c8 01       	movw	r24, r16
     7c4:	0e 94 93 26 	call	0x4d26	; 0x4d26 <__divmodhi4>
     7c8:	cb 01       	movw	r24, r22
     7ca:	9b 01       	movw	r18, r22
     7cc:	73 e0       	ldi	r23, 0x03	; 3
     7ce:	22 0f       	add	r18, r18
     7d0:	33 1f       	adc	r19, r19
     7d2:	7a 95       	dec	r23
     7d4:	e1 f7       	brne	.-8      	; 0x7ce <tan_SoR+0x72>
     7d6:	88 0f       	add	r24, r24
     7d8:	99 1f       	adc	r25, r25
     7da:	28 0f       	add	r18, r24
     7dc:	39 1f       	adc	r19, r25
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <tan_SoR+0x88>
     7e0:	20 e0       	ldi	r18, 0x00	; 0
     7e2:	30 e0       	ldi	r19, 0x00	; 0
	}
     7e4:	c9 01       	movw	r24, r18
     7e6:	1f 91       	pop	r17
     7e8:	0f 91       	pop	r16
     7ea:	ff 90       	pop	r15
     7ec:	ef 90       	pop	r14
     7ee:	df 90       	pop	r13
     7f0:	cf 90       	pop	r12
     7f2:	08 95       	ret

000007f4 <prvPWMSetup>:
#include <SoR_Utils.h>


void prvPWMSetup(){

	PWM_Init_timer2_H6(8);
     7f4:	88 e0       	ldi	r24, 0x08	; 8
     7f6:	0e 94 df 00 	call	0x1be	; 0x1be <PWM_Init_timer2_H6>
	PWM_Init_timer4_H5(10);
     7fa:	8a e0       	ldi	r24, 0x0A	; 10
     7fc:	0e 94 9d 01 	call	0x33a	; 0x33a <PWM_Init_timer4_H5>
	sbi(TCCR1A,COM1B1);
	cbi(TCCR1A,COM1B0);
}
void PWM_timer2_On_H6(void)
{
	sbi(TCCR2A,COM2B1);
     800:	e0 eb       	ldi	r30, 0xB0	; 176
     802:	f0 e0       	ldi	r31, 0x00	; 0
     804:	80 81       	ld	r24, Z
     806:	80 62       	ori	r24, 0x20	; 32
     808:	80 83       	st	Z, r24
	cbi(TCCR2A,COM2B0);
     80a:	80 81       	ld	r24, Z
     80c:	8f 7e       	andi	r24, 0xEF	; 239
     80e:	80 83       	st	Z, r24
	sbi(TCCR4A,COM4B1);
	cbi(TCCR4A,COM4B0);
}
void PWM_timer4_On_H5(void)
{
	sbi(TCCR4A,COM4C1);
     810:	e0 ea       	ldi	r30, 0xA0	; 160
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	80 81       	ld	r24, Z
     816:	88 60       	ori	r24, 0x08	; 8
     818:	80 83       	st	Z, r24
	cbi(TCCR4A,COM4C0);
     81a:	80 81       	ld	r24, Z
     81c:	8b 7f       	andi	r24, 0xFB	; 251
     81e:	80 83       	st	Z, r24
//			pwmDuty should be in the range 0-511 for 9bit PWM
//			pwmDuty should be in the range 0-1023 for 10bit PWM
void PWM_timer1_Set_LED(u16 pwmDuty)
	{OCR1B = pwmDuty;}
void PWM_timer2_Set_H6(u16 pwmDuty)
	{OCR2B = pwmDuty;}
     820:	10 92 b4 00 	sts	0x00B4, r1
void PWM_timer4_Set_H3(u16 pwmDuty)
	{OCR4A = pwmDuty;}
void PWM_timer4_Set_H4(u16 pwmDuty)
	{OCR4B = pwmDuty;}
void PWM_timer4_Set_H5(u16 pwmDuty)
	{OCR4C = pwmDuty;}
     824:	10 92 ad 00 	sts	0x00AD, r1
     828:	10 92 ac 00 	sts	0x00AC, r1
	PWM_timer2_On_H6();
	PWM_timer4_On_H5();
	PWM_timer2_Set_H6(0);	
	PWM_timer4_Set_H5(0);	

}
     82c:	08 95       	ret

0000082e <prvSetupHardware>:


void prvSetupHardware(){
     82e:	0f 93       	push	r16
     830:	1f 93       	push	r17
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
	delay_cycles(65535);
	delay_cycles(65535);
	
	

	uartInit();  // initialize the UART (serial port)
     836:	0e 94 08 1b 	call	0x3610	; 0x3610 <uartInit>
    uartSetBaudRate(0, 38400); // set UARTE speed, for Bluetooth
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	40 e0       	ldi	r20, 0x00	; 0
     83e:	56 e9       	ldi	r21, 0x96	; 150
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
    uartSetBaudRate(1, 115200); // set UARTD speed, for USB connection, up to 500k, try 115200 if it doesn't work
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	40 e0       	ldi	r20, 0x00	; 0
     84c:	52 ec       	ldi	r21, 0xC2	; 194
     84e:	61 e0       	ldi	r22, 0x01	; 1
     850:	70 e0       	ldi	r23, 0x00	; 0
     852:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
    uartSetBaudRate(2, 38400); // set UARTH speed
     856:	82 e0       	ldi	r24, 0x02	; 2
     858:	40 e0       	ldi	r20, 0x00	; 0
     85a:	56 e9       	ldi	r21, 0x96	; 150
     85c:	60 e0       	ldi	r22, 0x00	; 0
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
    uartSetBaudRate(3, 38400); // set UARTJ speed, for Blackfin
     864:	83 e0       	ldi	r24, 0x03	; 3
     866:	40 e0       	ldi	r20, 0x00	; 0
     868:	56 e9       	ldi	r21, 0x96	; 150
     86a:	60 e0       	ldi	r22, 0x00	; 0
     86c:	70 e0       	ldi	r23, 0x00	; 0
     86e:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
	//G=Ground, T=Tx (connect to external Rx), R=Rx (connect to external Tx)

	rprintfInit(uart1SendByte);// initialize rprintf system and configure uart1 (USB) for rprintf
     872:	8b e5       	ldi	r24, 0x5B	; 91
     874:	97 e1       	ldi	r25, 0x17	; 23
     876:	0e 94 4c 1c 	call	0x3898	; 0x3898 <rprintfInit>

	configure_ports(); // configure which ports are analog, digital, etc.
     87a:	0e 94 2a 03 	call	0x654	; 0x654 <configure_ports>
//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
void LED_on(void)
	{PORT_OFF(PORTB,6);}
     87e:	2e 98       	cbi	0x05, 6	; 5
	LED_on();

	//rprintf("\r\nSystem Warmed Up");

	// initialize the timer system
 	init_timer0(TIMER_CLK_1024);
     880:	85 e0       	ldi	r24, 0x05	; 5
     882:	0e 94 ee 10 	call	0x21dc	; 0x21dc <init_timer0>
// 	init_timer1(TIMER_CLK_64); // Timer 1 is initialized by FreeRTOS
 	init_timer2(TIMER2_CLK_64);
     886:	84 e0       	ldi	r24, 0x04	; 4
     888:	0e 94 0e 11 	call	0x221c	; 0x221c <init_timer2>
 	init_timer3(TIMER_CLK_64);
     88c:	83 e0       	ldi	r24, 0x03	; 3
     88e:	0e 94 1e 11 	call	0x223c	; 0x223c <init_timer3>
 	init_timer4(TIMER_CLK_64);
     892:	83 e0       	ldi	r24, 0x03	; 3
     894:	0e 94 30 11 	call	0x2260	; 0x2260 <init_timer4>
 	init_timer5(TIMER_CLK_64);
     898:	83 e0       	ldi	r24, 0x03	; 3
     89a:	0e 94 42 11 	call	0x2284	; 0x2284 <init_timer5>

	a2dInit(); // initialize analog to digital converter (ADC)
     89e:	0e 94 c1 1b 	call	0x3782	; 0x3782 <a2dInit>
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
     8a2:	85 e0       	ldi	r24, 0x05	; 5
     8a4:	0e 94 e6 1b 	call	0x37cc	; 0x37cc <a2dSetPrescaler>
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	0e 94 ed 1b 	call	0x37da	; 0x37da <a2dSetReference>
     8ae:	10 e0       	ldi	r17, 0x00	; 0
	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     8b0:	01 e0       	ldi	r16, 0x01	; 1
     8b2:	cf ef       	ldi	r28, 0xFF	; 255
     8b4:	d0 e0       	ldi	r29, 0x00	; 0
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
		{
		j=a2dConvert8bit(i);//read each ADC once to get it working accurately
     8b6:	81 2f       	mov	r24, r17
     8b8:	0e 94 36 1c 	call	0x386c	; 0x386c <a2dConvert8bit>
		delay_cycles(5000); //keep LED on long enough to see Axon reseting
		rprintf(".");
     8bc:	00 d0       	rcall	.+0      	; 0x8be <prvSetupHardware+0x90>
     8be:	0f 92       	push	r0
     8c0:	ed b7       	in	r30, 0x3d	; 61
     8c2:	fe b7       	in	r31, 0x3e	; 62
     8c4:	01 83       	std	Z+1, r16	; 0x01
     8c6:	d3 83       	std	Z+3, r29	; 0x03
     8c8:	c2 83       	std	Z+2, r28	; 0x02
     8ca:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <rprintf1RamRom>
     8ce:	1f 5f       	subi	r17, 0xFF	; 255
	a2dInit(); // initialize analog to digital converter (ADC)
	a2dSetPrescaler(ADC_PRESCALE_DIV32); // configure ADC scaling
	a2dSetReference(ADC_REFERENCE_AVCC); // configure ADC reference voltage

	//let system stabelize for X time
	for(i=0;i<16;i++)
     8d0:	0f 90       	pop	r0
     8d2:	0f 90       	pop	r0
     8d4:	0f 90       	pop	r0
     8d6:	10 31       	cpi	r17, 0x10	; 16
     8d8:	71 f7       	brne	.-36     	; 0x8b6 <prvSetupHardware+0x88>


//***************STATUS LED**************
//tank test
void LED_off(void)
	{PORT_ON(PORTB,6);}
     8da:	2e 9a       	sbi	0x05, 6	; 5
		rprintf(".");
		}

	LED_off();

	rprintf("Initialization Complete \r\n");
     8dc:	00 d0       	rcall	.+0      	; 0x8de <prvSetupHardware+0xb0>
     8de:	0f 92       	push	r0
     8e0:	ed b7       	in	r30, 0x3d	; 61
     8e2:	fe b7       	in	r31, 0x3e	; 62
     8e4:	01 83       	std	Z+1, r16	; 0x01
     8e6:	84 ee       	ldi	r24, 0xE4	; 228
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	93 83       	std	Z+3, r25	; 0x03
     8ec:	82 83       	std	Z+2, r24	; 0x02
     8ee:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <rprintf1RamRom>

	//reset all timers to zero
	reset_timer0();
     8f2:	0f 90       	pop	r0
     8f4:	0f 90       	pop	r0
     8f6:	0f 90       	pop	r0
     8f8:	0e 94 a4 10 	call	0x2148	; 0x2148 <reset_timer0>
	reset_timer1();
     8fc:	0e 94 ae 10 	call	0x215c	; 0x215c <reset_timer1>
	reset_timer2();
     900:	0e 94 bb 10 	call	0x2176	; 0x2176 <reset_timer2>
	reset_timer3();
     904:	0e 94 c6 10 	call	0x218c	; 0x218c <reset_timer3>
	reset_timer4();
     908:	0e 94 d3 10 	call	0x21a6	; 0x21a6 <reset_timer4>
	reset_timer5();
     90c:	0e 94 e0 10 	call	0x21c0	; 0x21c0 <reset_timer5>



	/********PWM Setup***********/
	prvPWMSetup();
     910:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <prvPWMSetup>

}
     914:	df 91       	pop	r29
     916:	cf 91       	pop	r28
     918:	1f 91       	pop	r17
     91a:	0f 91       	pop	r16
     91c:	08 95       	ret

0000091e <main>:


int main(void)
{

	prvSetupHardware();
     91e:	0e 94 17 04 	call	0x82e	; 0x82e <prvSetupHardware>

	
	vTaskStartScheduler();
     922:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <vTaskStartScheduler>
     926:	ff cf       	rjmp	.-2      	; 0x926 <main+0x8>

00000928 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     928:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     92a:	9c 01       	movw	r18, r24
     92c:	2d 5f       	subi	r18, 0xFD	; 253
     92e:	3f 4f       	sbci	r19, 0xFF	; 255
     930:	32 83       	std	Z+2, r19	; 0x02
     932:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     934:	8f ef       	ldi	r24, 0xFF	; 255
     936:	9f ef       	ldi	r25, 0xFF	; 255
     938:	94 83       	std	Z+4, r25	; 0x04
     93a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     93c:	36 83       	std	Z+6, r19	; 0x06
     93e:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     940:	30 87       	std	Z+8, r19	; 0x08
     942:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = 0;
     944:	10 82       	st	Z, r1
}
     946:	08 95       	ret

00000948 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     948:	fc 01       	movw	r30, r24
     94a:	11 86       	std	Z+9, r1	; 0x09
     94c:	10 86       	std	Z+8, r1	; 0x08
}
     94e:	08 95       	ret

00000950 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	ac 01       	movw	r20, r24
     956:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     958:	ec 01       	movw	r28, r24
     95a:	29 81       	ldd	r18, Y+1	; 0x01
     95c:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     95e:	f9 01       	movw	r30, r18
     960:	82 81       	ldd	r24, Z+2	; 0x02
     962:	93 81       	ldd	r25, Z+3	; 0x03
     964:	13 96       	adiw	r26, 0x03	; 3
     966:	9c 93       	st	X, r25
     968:	8e 93       	st	-X, r24
     96a:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     96c:	89 81       	ldd	r24, Y+1	; 0x01
     96e:	9a 81       	ldd	r25, Y+2	; 0x02
     970:	15 96       	adiw	r26, 0x05	; 5
     972:	9c 93       	st	X, r25
     974:	8e 93       	st	-X, r24
     976:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     978:	02 80       	ldd	r0, Z+2	; 0x02
     97a:	f3 81       	ldd	r31, Z+3	; 0x03
     97c:	e0 2d       	mov	r30, r0
     97e:	75 83       	std	Z+5, r23	; 0x05
     980:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     982:	e9 01       	movw	r28, r18
     984:	7b 83       	std	Y+3, r23	; 0x03
     986:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     988:	fa 01       	movw	r30, r20
     98a:	72 83       	std	Z+2, r23	; 0x02
     98c:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     98e:	19 96       	adiw	r26, 0x09	; 9
     990:	5c 93       	st	X, r21
     992:	4e 93       	st	-X, r20
     994:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     996:	80 81       	ld	r24, Z
     998:	8f 5f       	subi	r24, 0xFF	; 255
     99a:	80 83       	st	Z, r24
}
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	08 95       	ret

000009a2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     9a2:	cf 93       	push	r28
     9a4:	df 93       	push	r29
     9a6:	9c 01       	movw	r18, r24
     9a8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     9aa:	48 81       	ld	r20, Y
     9ac:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9ae:	8f ef       	ldi	r24, 0xFF	; 255
     9b0:	4f 3f       	cpi	r20, 0xFF	; 255
     9b2:	58 07       	cpc	r21, r24
     9b4:	21 f4       	brne	.+8      	; 0x9be <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9b6:	f9 01       	movw	r30, r18
     9b8:	a7 81       	ldd	r26, Z+7	; 0x07
     9ba:	b0 85       	ldd	r27, Z+8	; 0x08
     9bc:	10 c0       	rjmp	.+32     	; 0x9de <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     9be:	d9 01       	movw	r26, r18
     9c0:	13 96       	adiw	r26, 0x03	; 3
     9c2:	04 c0       	rjmp	.+8      	; 0x9cc <vListInsert+0x2a>
     9c4:	12 96       	adiw	r26, 0x02	; 2
     9c6:	0d 90       	ld	r0, X+
     9c8:	bc 91       	ld	r27, X
     9ca:	a0 2d       	mov	r26, r0
     9cc:	12 96       	adiw	r26, 0x02	; 2
     9ce:	ed 91       	ld	r30, X+
     9d0:	fc 91       	ld	r31, X
     9d2:	13 97       	sbiw	r26, 0x03	; 3
     9d4:	80 81       	ld	r24, Z
     9d6:	91 81       	ldd	r25, Z+1	; 0x01
     9d8:	48 17       	cp	r20, r24
     9da:	59 07       	cpc	r21, r25
     9dc:	98 f7       	brcc	.-26     	; 0x9c4 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     9de:	12 96       	adiw	r26, 0x02	; 2
     9e0:	ed 91       	ld	r30, X+
     9e2:	fc 91       	ld	r31, X
     9e4:	13 97       	sbiw	r26, 0x03	; 3
     9e6:	fb 83       	std	Y+3, r31	; 0x03
     9e8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     9ea:	d5 83       	std	Z+5, r29	; 0x05
     9ec:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9ee:	bd 83       	std	Y+5, r27	; 0x05
     9f0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     9f2:	13 96       	adiw	r26, 0x03	; 3
     9f4:	dc 93       	st	X, r29
     9f6:	ce 93       	st	-X, r28
     9f8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9fa:	39 87       	std	Y+9, r19	; 0x09
     9fc:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9fe:	f9 01       	movw	r30, r18
     a00:	80 81       	ld	r24, Z
     a02:	8f 5f       	subi	r24, 0xFF	; 255
     a04:	80 83       	st	Z, r24
}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	ed 91       	ld	r30, X+
     a16:	fc 91       	ld	r31, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	14 96       	adiw	r26, 0x04	; 4
     a1c:	8d 91       	ld	r24, X+
     a1e:	9c 91       	ld	r25, X
     a20:	15 97       	sbiw	r26, 0x05	; 5
     a22:	95 83       	std	Z+5, r25	; 0x05
     a24:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a26:	14 96       	adiw	r26, 0x04	; 4
     a28:	cd 91       	ld	r28, X+
     a2a:	dc 91       	ld	r29, X
     a2c:	15 97       	sbiw	r26, 0x05	; 5
     a2e:	fb 83       	std	Y+3, r31	; 0x03
     a30:	ea 83       	std	Y+2, r30	; 0x02
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     a32:	18 96       	adiw	r26, 0x08	; 8
     a34:	ed 91       	ld	r30, X+
     a36:	fc 91       	ld	r31, X
     a38:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a3a:	81 81       	ldd	r24, Z+1	; 0x01
     a3c:	92 81       	ldd	r25, Z+2	; 0x02
     a3e:	8a 17       	cp	r24, r26
     a40:	9b 07       	cpc	r25, r27
     a42:	11 f4       	brne	.+4      	; 0xa48 <vListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a44:	d2 83       	std	Z+2, r29	; 0x02
     a46:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a48:	19 96       	adiw	r26, 0x09	; 9
     a4a:	1c 92       	st	X, r1
     a4c:	1e 92       	st	-X, r1
     a4e:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     a50:	80 81       	ld	r24, Z
     a52:	81 50       	subi	r24, 0x01	; 1
     a54:	80 83       	st	Z, r24
}
     a56:	df 91       	pop	r29
     a58:	cf 91       	pop	r28
     a5a:	08 95       	ret

00000a5c <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
     a5c:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
     a5e:	0f b6       	in	r0, 0x3f	; 63
     a60:	f8 94       	cli
     a62:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
     a64:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     a66:	0f 90       	pop	r0
     a68:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     a6a:	08 95       	ret

00000a6c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
     a6c:	fc 01       	movw	r30, r24
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
     a6e:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
     a70:	08 95       	ret

00000a72 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
     a72:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     a74:	82 8d       	ldd	r24, Z+26	; 0x1a
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	88 23       	and	r24, r24
     a7a:	09 f4       	brne	.+2      	; 0xa7e <xQueueIsQueueEmptyFromISR+0xc>
     a7c:	91 e0       	ldi	r25, 0x01	; 1

	return xReturn;
}
     a7e:	89 2f       	mov	r24, r25
     a80:	08 95       	ret

00000a82 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
     a82:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     a84:	92 8d       	ldd	r25, Z+26	; 0x1a
     a86:	20 e0       	ldi	r18, 0x00	; 0
     a88:	83 8d       	ldd	r24, Z+27	; 0x1b
     a8a:	98 17       	cp	r25, r24
     a8c:	09 f4       	brne	.+2      	; 0xa90 <xQueueIsQueueFullFromISR+0xe>
     a8e:	21 e0       	ldi	r18, 0x01	; 1

	return xReturn;
}
     a90:	82 2f       	mov	r24, r18
     a92:	08 95       	ret

00000a94 <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	8c 01       	movw	r16, r24
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
     a9a:	fc 01       	movw	r30, r24
     a9c:	80 81       	ld	r24, Z
     a9e:	91 81       	ldd	r25, Z+1	; 0x01
     aa0:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>
	vPortFree( pxQueue );
     aa4:	c8 01       	movw	r24, r16
     aa6:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>
}
     aaa:	1f 91       	pop	r17
     aac:	0f 91       	pop	r16
     aae:	08 95       	ret

00000ab0 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
     ab0:	0f 93       	push	r16
     ab2:	1f 93       	push	r17
     ab4:	cf 93       	push	r28
     ab6:	df 93       	push	r29
     ab8:	ec 01       	movw	r28, r24
     aba:	fb 01       	movw	r30, r22
     abc:	8a 01       	movw	r16, r20
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     abe:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ac0:	88 23       	and	r24, r24
     ac2:	81 f1       	breq	.+96     	; 0xb24 <xQueueReceiveFromISR+0x74>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     ac4:	48 81       	ld	r20, Y
     ac6:	59 81       	ldd	r21, Y+1	; 0x01
     ac8:	41 15       	cp	r20, r1
     aca:	51 05       	cpc	r21, r1
     acc:	a9 f0       	breq	.+42     	; 0xaf8 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     ace:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ad0:	2e 81       	ldd	r18, Y+6	; 0x06
     ad2:	3f 81       	ldd	r19, Y+7	; 0x07
     ad4:	28 0f       	add	r18, r24
     ad6:	31 1d       	adc	r19, r1
     ad8:	3f 83       	std	Y+7, r19	; 0x07
     ada:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     adc:	8a 81       	ldd	r24, Y+2	; 0x02
     ade:	9b 81       	ldd	r25, Y+3	; 0x03
     ae0:	28 17       	cp	r18, r24
     ae2:	39 07       	cpc	r19, r25
     ae4:	10 f0       	brcs	.+4      	; 0xaea <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     ae6:	5f 83       	std	Y+7, r21	; 0x07
     ae8:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     aea:	4c 8d       	ldd	r20, Y+28	; 0x1c
     aec:	6e 81       	ldd	r22, Y+6	; 0x06
     aee:	7f 81       	ldd	r23, Y+7	; 0x07
     af0:	cf 01       	movw	r24, r30
     af2:	50 e0       	ldi	r21, 0x00	; 0
     af4:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
     af8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     afa:	81 50       	subi	r24, 0x01	; 1
     afc:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
     afe:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b00:	8f 3f       	cpi	r24, 0xFF	; 255
     b02:	69 f4       	brne	.+26     	; 0xb1e <xQueueReceiveFromISR+0x6e>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     b04:	88 85       	ldd	r24, Y+8	; 0x08
     b06:	88 23       	and	r24, r24
     b08:	61 f0       	breq	.+24     	; 0xb22 <xQueueReceiveFromISR+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b0a:	ce 01       	movw	r24, r28
     b0c:	08 96       	adiw	r24, 0x08	; 8
     b0e:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     b12:	88 23       	and	r24, r24
     b14:	31 f0       	breq	.+12     	; 0xb22 <xQueueReceiveFromISR+0x72>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
     b16:	81 e0       	ldi	r24, 0x01	; 1
     b18:	f8 01       	movw	r30, r16
     b1a:	80 83       	st	Z, r24
     b1c:	03 c0       	rjmp	.+6      	; 0xb24 <xQueueReceiveFromISR+0x74>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
     b1e:	8f 5f       	subi	r24, 0xFF	; 255
     b20:	8d 8f       	std	Y+29, r24	; 0x1d
     b22:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	08 95       	ret

00000b2e <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	ec 01       	movw	r28, r24
     b34:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     b36:	4c 8d       	ldd	r20, Y+28	; 0x1c
     b38:	44 23       	and	r20, r20
     b3a:	a1 f1       	breq	.+104    	; 0xba4 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     b3c:	88 23       	and	r24, r24
     b3e:	b1 f4       	brne	.+44     	; 0xb6c <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b40:	8c 81       	ldd	r24, Y+4	; 0x04
     b42:	9d 81       	ldd	r25, Y+5	; 0x05
     b44:	50 e0       	ldi	r21, 0x00	; 0
     b46:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     b4a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b4c:	2c 81       	ldd	r18, Y+4	; 0x04
     b4e:	3d 81       	ldd	r19, Y+5	; 0x05
     b50:	28 0f       	add	r18, r24
     b52:	31 1d       	adc	r19, r1
     b54:	3d 83       	std	Y+5, r19	; 0x05
     b56:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     b58:	8a 81       	ldd	r24, Y+2	; 0x02
     b5a:	9b 81       	ldd	r25, Y+3	; 0x03
     b5c:	28 17       	cp	r18, r24
     b5e:	39 07       	cpc	r19, r25
     b60:	08 f1       	brcs	.+66     	; 0xba4 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     b62:	88 81       	ld	r24, Y
     b64:	99 81       	ldd	r25, Y+1	; 0x01
     b66:	9d 83       	std	Y+5, r25	; 0x05
     b68:	8c 83       	std	Y+4, r24	; 0x04
     b6a:	1c c0       	rjmp	.+56     	; 0xba4 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	9f 81       	ldd	r25, Y+7	; 0x07
     b70:	50 e0       	ldi	r21, 0x00	; 0
     b72:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     b76:	8c 8d       	ldd	r24, Y+28	; 0x1c
     b78:	90 e0       	ldi	r25, 0x00	; 0
     b7a:	44 27       	eor	r20, r20
     b7c:	55 27       	eor	r21, r21
     b7e:	48 1b       	sub	r20, r24
     b80:	59 0b       	sbc	r21, r25
     b82:	8e 81       	ldd	r24, Y+6	; 0x06
     b84:	9f 81       	ldd	r25, Y+7	; 0x07
     b86:	84 0f       	add	r24, r20
     b88:	95 1f       	adc	r25, r21
     b8a:	9f 83       	std	Y+7, r25	; 0x07
     b8c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     b8e:	28 81       	ld	r18, Y
     b90:	39 81       	ldd	r19, Y+1	; 0x01
     b92:	82 17       	cp	r24, r18
     b94:	93 07       	cpc	r25, r19
     b96:	30 f4       	brcc	.+12     	; 0xba4 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     b98:	8a 81       	ldd	r24, Y+2	; 0x02
     b9a:	9b 81       	ldd	r25, Y+3	; 0x03
     b9c:	84 0f       	add	r24, r20
     b9e:	95 1f       	adc	r25, r21
     ba0:	9f 83       	std	Y+7, r25	; 0x07
     ba2:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     ba4:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ba6:	8f 5f       	subi	r24, 0xFF	; 255
     ba8:	8a 8f       	std	Y+26, r24	; 0x1a
}
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	08 95       	ret

00000bb0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     bb0:	0f 93       	push	r16
     bb2:	1f 93       	push	r17
     bb4:	cf 93       	push	r28
     bb6:	df 93       	push	r29
     bb8:	ec 01       	movw	r28, r24
     bba:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     bbc:	9a 8d       	ldd	r25, Y+26	; 0x1a
     bbe:	8b 8d       	ldd	r24, Y+27	; 0x1b
     bc0:	98 17       	cp	r25, r24
     bc2:	10 f0       	brcs	.+4      	; 0xbc8 <xQueueGenericSendFromISR+0x18>
     bc4:	80 e0       	ldi	r24, 0x00	; 0
     bc6:	17 c0       	rjmp	.+46     	; 0xbf6 <xQueueGenericSendFromISR+0x46>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     bc8:	ce 01       	movw	r24, r28
     bca:	42 2f       	mov	r20, r18
     bcc:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     bd0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bd2:	8f 3f       	cpi	r24, 0xFF	; 255
     bd4:	69 f4       	brne	.+26     	; 0xbf0 <xQueueGenericSendFromISR+0x40>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     bd6:	89 89       	ldd	r24, Y+17	; 0x11
     bd8:	88 23       	and	r24, r24
     bda:	61 f0       	breq	.+24     	; 0xbf4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bdc:	ce 01       	movw	r24, r28
     bde:	41 96       	adiw	r24, 0x11	; 17
     be0:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     be4:	88 23       	and	r24, r24
     be6:	31 f0       	breq	.+12     	; 0xbf4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	f8 01       	movw	r30, r16
     bec:	80 83       	st	Z, r24
     bee:	03 c0       	rjmp	.+6      	; 0xbf6 <xQueueGenericSendFromISR+0x46>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     bf0:	8f 5f       	subi	r24, 0xFF	; 255
     bf2:	8e 8f       	std	Y+30, r24	; 0x1e
     bf4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     bf6:	df 91       	pop	r29
     bf8:	cf 91       	pop	r28
     bfa:	1f 91       	pop	r17
     bfc:	0f 91       	pop	r16
     bfe:	08 95       	ret

00000c00 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     c00:	0f 93       	push	r16
     c02:	1f 93       	push	r17
     c04:	cf 93       	push	r28
     c06:	df 93       	push	r29
     c08:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     c0a:	0f b6       	in	r0, 0x3f	; 63
     c0c:	f8 94       	cli
     c0e:	0f 92       	push	r0
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c10:	8c 01       	movw	r16, r24
     c12:	0f 5e       	subi	r16, 0xEF	; 239
     c14:	1f 4f       	sbci	r17, 0xFF	; 255
     c16:	0d c0       	rjmp	.+26     	; 0xc32 <prvUnlockQueue+0x32>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     c18:	89 89       	ldd	r24, Y+17	; 0x11
     c1a:	88 23       	and	r24, r24
     c1c:	69 f0       	breq	.+26     	; 0xc38 <prvUnlockQueue+0x38>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c1e:	c8 01       	movw	r24, r16
     c20:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     c24:	88 23       	and	r24, r24
     c26:	11 f0       	breq	.+4      	; 0xc2c <prvUnlockQueue+0x2c>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     c28:	0e 94 b4 08 	call	0x1168	; 0x1168 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     c2c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c2e:	81 50       	subi	r24, 0x01	; 1
     c30:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c32:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c34:	18 16       	cp	r1, r24
     c36:	84 f3       	brlt	.-32     	; 0xc18 <prvUnlockQueue+0x18>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     c38:	8f ef       	ldi	r24, 0xFF	; 255
     c3a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     c3c:	0f 90       	pop	r0
     c3e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c46:	8e 01       	movw	r16, r28
     c48:	08 5f       	subi	r16, 0xF8	; 248
     c4a:	1f 4f       	sbci	r17, 0xFF	; 255
     c4c:	0d c0       	rjmp	.+26     	; 0xc68 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
     c4e:	88 85       	ldd	r24, Y+8	; 0x08
     c50:	88 23       	and	r24, r24
     c52:	69 f0       	breq	.+26     	; 0xc6e <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     c5a:	88 23       	and	r24, r24
     c5c:	11 f0       	breq	.+4      	; 0xc62 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
     c5e:	0e 94 b4 08 	call	0x1168	; 0x1168 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     c62:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c64:	81 50       	subi	r24, 0x01	; 1
     c66:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c68:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c6a:	18 16       	cp	r1, r24
     c6c:	84 f3       	brlt	.-32     	; 0xc4e <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     c6e:	8f ef       	ldi	r24, 0xFF	; 255
     c70:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     c72:	0f 90       	pop	r0
     c74:	0f be       	out	0x3f, r0	; 63
}
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	1f 91       	pop	r17
     c7c:	0f 91       	pop	r16
     c7e:	08 95       	ret

00000c80 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     c80:	7f 92       	push	r7
     c82:	8f 92       	push	r8
     c84:	9f 92       	push	r9
     c86:	af 92       	push	r10
     c88:	bf 92       	push	r11
     c8a:	cf 92       	push	r12
     c8c:	df 92       	push	r13
     c8e:	ef 92       	push	r14
     c90:	ff 92       	push	r15
     c92:	0f 93       	push	r16
     c94:	1f 93       	push	r17
     c96:	df 93       	push	r29
     c98:	cf 93       	push	r28
     c9a:	00 d0       	rcall	.+0      	; 0xc9c <xQueueGenericReceive+0x1c>
     c9c:	00 d0       	rcall	.+0      	; 0xc9e <xQueueGenericReceive+0x1e>
     c9e:	0f 92       	push	r0
     ca0:	cd b7       	in	r28, 0x3d	; 61
     ca2:	de b7       	in	r29, 0x3e	; 62
     ca4:	8c 01       	movw	r16, r24
     ca6:	96 2e       	mov	r9, r22
     ca8:	87 2e       	mov	r8, r23
     caa:	5d 83       	std	Y+5, r21	; 0x05
     cac:	4c 83       	std	Y+4, r20	; 0x04
     cae:	72 2e       	mov	r7, r18
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     cb0:	91 e1       	ldi	r25, 0x11	; 17
     cb2:	c9 2e       	mov	r12, r25
     cb4:	d1 2c       	mov	r13, r1
     cb6:	c0 0e       	add	r12, r16
     cb8:	d1 1e       	adc	r13, r17
     cba:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     cbc:	7e 01       	movw	r14, r28
     cbe:	08 94       	sec
     cc0:	e1 1c       	adc	r14, r1
     cc2:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cc4:	84 e0       	ldi	r24, 0x04	; 4
     cc6:	a8 2e       	mov	r10, r24
     cc8:	b1 2c       	mov	r11, r1
     cca:	ac 0e       	add	r10, r28
     ccc:	bd 1e       	adc	r11, r29
     cce:	01 c0       	rjmp	.+2      	; 0xcd2 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     cd0:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     cd2:	0f b6       	in	r0, 0x3f	; 63
     cd4:	f8 94       	cli
     cd6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     cd8:	f8 01       	movw	r30, r16
     cda:	82 8d       	ldd	r24, Z+26	; 0x1a
     cdc:	88 23       	and	r24, r24
     cde:	09 f4       	brne	.+2      	; 0xce2 <xQueueGenericReceive+0x62>
     ce0:	3e c0       	rjmp	.+124    	; 0xd5e <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     ce2:	e6 80       	ldd	r14, Z+6	; 0x06
     ce4:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     ce6:	40 81       	ld	r20, Z
     ce8:	51 81       	ldd	r21, Z+1	; 0x01
     cea:	41 15       	cp	r20, r1
     cec:	51 05       	cpc	r21, r1
     cee:	b1 f0       	breq	.+44     	; 0xd1c <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     cf0:	84 8d       	ldd	r24, Z+28	; 0x1c
     cf2:	97 01       	movw	r18, r14
     cf4:	28 0f       	add	r18, r24
     cf6:	31 1d       	adc	r19, r1
     cf8:	37 83       	std	Z+7, r19	; 0x07
     cfa:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     cfc:	82 81       	ldd	r24, Z+2	; 0x02
     cfe:	93 81       	ldd	r25, Z+3	; 0x03
     d00:	28 17       	cp	r18, r24
     d02:	39 07       	cpc	r19, r25
     d04:	10 f0       	brcs	.+4      	; 0xd0a <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     d06:	57 83       	std	Z+7, r21	; 0x07
     d08:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     d0a:	f8 01       	movw	r30, r16
     d0c:	44 8d       	ldd	r20, Z+28	; 0x1c
     d0e:	66 81       	ldd	r22, Z+6	; 0x06
     d10:	77 81       	ldd	r23, Z+7	; 0x07
     d12:	89 2d       	mov	r24, r9
     d14:	98 2d       	mov	r25, r8
     d16:	50 e0       	ldi	r21, 0x00	; 0
     d18:	0e 94 60 26 	call	0x4cc0	; 0x4cc0 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
     d1c:	77 20       	and	r7, r7
     d1e:	71 f4       	brne	.+28     	; 0xd3c <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     d20:	f8 01       	movw	r30, r16
     d22:	82 8d       	ldd	r24, Z+26	; 0x1a
     d24:	81 50       	subi	r24, 0x01	; 1
     d26:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d28:	80 85       	ldd	r24, Z+8	; 0x08
     d2a:	88 23       	and	r24, r24
     d2c:	a1 f0       	breq	.+40     	; 0xd56 <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     d2e:	c8 01       	movw	r24, r16
     d30:	08 96       	adiw	r24, 0x08	; 8
     d32:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     d36:	81 30       	cpi	r24, 0x01	; 1
     d38:	71 f4       	brne	.+28     	; 0xd56 <xQueueGenericReceive+0xd6>
     d3a:	0b c0       	rjmp	.+22     	; 0xd52 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     d3c:	f8 01       	movw	r30, r16
     d3e:	f7 82       	std	Z+7, r15	; 0x07
     d40:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
     d42:	81 89       	ldd	r24, Z+17	; 0x11
     d44:	88 23       	and	r24, r24
     d46:	39 f0       	breq	.+14     	; 0xd56 <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d48:	c6 01       	movw	r24, r12
     d4a:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     d4e:	88 23       	and	r24, r24
     d50:	11 f0       	breq	.+4      	; 0xd56 <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     d52:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     d56:	0f 90       	pop	r0
     d58:	0f be       	out	0x3f, r0	; 63
     d5a:	81 e0       	ldi	r24, 0x01	; 1
     d5c:	4a c0       	rjmp	.+148    	; 0xdf2 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     d5e:	8c 81       	ldd	r24, Y+4	; 0x04
     d60:	9d 81       	ldd	r25, Y+5	; 0x05
     d62:	89 2b       	or	r24, r25
     d64:	19 f4       	brne	.+6      	; 0xd6c <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     d66:	0f 90       	pop	r0
     d68:	0f be       	out	0x3f, r0	; 63
     d6a:	42 c0       	rjmp	.+132    	; 0xdf0 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
     d6c:	22 23       	and	r18, r18
     d6e:	19 f4       	brne	.+6      	; 0xd76 <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     d70:	c7 01       	movw	r24, r14
     d72:	0e 94 6f 08 	call	0x10de	; 0x10de <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     d76:	0f 90       	pop	r0
     d78:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     d7a:	0e 94 13 08 	call	0x1026	; 0x1026 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     d7e:	0f b6       	in	r0, 0x3f	; 63
     d80:	f8 94       	cli
     d82:	0f 92       	push	r0
     d84:	f8 01       	movw	r30, r16
     d86:	85 8d       	ldd	r24, Z+29	; 0x1d
     d88:	8f 3f       	cpi	r24, 0xFF	; 255
     d8a:	09 f4       	brne	.+2      	; 0xd8e <xQueueGenericReceive+0x10e>
     d8c:	15 8e       	std	Z+29, r1	; 0x1d
     d8e:	f8 01       	movw	r30, r16
     d90:	86 8d       	ldd	r24, Z+30	; 0x1e
     d92:	8f 3f       	cpi	r24, 0xFF	; 255
     d94:	09 f4       	brne	.+2      	; 0xd98 <xQueueGenericReceive+0x118>
     d96:	16 8e       	std	Z+30, r1	; 0x1e
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     d9c:	c7 01       	movw	r24, r14
     d9e:	b5 01       	movw	r22, r10
     da0:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <xTaskCheckForTimeOut>
     da4:	88 23       	and	r24, r24
     da6:	f9 f4       	brne	.+62     	; 0xde6 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     da8:	0f b6       	in	r0, 0x3f	; 63
     daa:	f8 94       	cli
     dac:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     dae:	f8 01       	movw	r30, r16
     db0:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     db2:	0f 90       	pop	r0
     db4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
     db6:	88 23       	and	r24, r24
     db8:	81 f4       	brne	.+32     	; 0xdda <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     dba:	6c 81       	ldd	r22, Y+4	; 0x04
     dbc:	7d 81       	ldd	r23, Y+5	; 0x05
     dbe:	c6 01       	movw	r24, r12
     dc0:	0e 94 71 09 	call	0x12e2	; 0x12e2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     dc4:	c8 01       	movw	r24, r16
     dc6:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
				if( !xTaskResumeAll() )
     dca:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     dce:	88 23       	and	r24, r24
     dd0:	09 f0       	breq	.+2      	; 0xdd4 <xQueueGenericReceive+0x154>
     dd2:	7e cf       	rjmp	.-260    	; 0xcd0 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
     dd4:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
     dd8:	7b cf       	rjmp	.-266    	; 0xcd0 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     dda:	c8 01       	movw	r24, r16
     ddc:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     de0:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     de4:	75 cf       	rjmp	.-278    	; 0xcd0 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     de6:	c8 01       	movw	r24, r16
     de8:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     dec:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     df0:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
     df2:	0f 90       	pop	r0
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	0f 90       	pop	r0
     dfa:	0f 90       	pop	r0
     dfc:	cf 91       	pop	r28
     dfe:	df 91       	pop	r29
     e00:	1f 91       	pop	r17
     e02:	0f 91       	pop	r16
     e04:	ff 90       	pop	r15
     e06:	ef 90       	pop	r14
     e08:	df 90       	pop	r13
     e0a:	cf 90       	pop	r12
     e0c:	bf 90       	pop	r11
     e0e:	af 90       	pop	r10
     e10:	9f 90       	pop	r9
     e12:	8f 90       	pop	r8
     e14:	7f 90       	pop	r7
     e16:	08 95       	ret

00000e18 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
     e18:	7f 92       	push	r7
     e1a:	8f 92       	push	r8
     e1c:	9f 92       	push	r9
     e1e:	af 92       	push	r10
     e20:	bf 92       	push	r11
     e22:	cf 92       	push	r12
     e24:	df 92       	push	r13
     e26:	ef 92       	push	r14
     e28:	ff 92       	push	r15
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	00 d0       	rcall	.+0      	; 0xe34 <xQueueGenericSend+0x1c>
     e34:	00 d0       	rcall	.+0      	; 0xe36 <xQueueGenericSend+0x1e>
     e36:	0f 92       	push	r0
     e38:	cd b7       	in	r28, 0x3d	; 61
     e3a:	de b7       	in	r29, 0x3e	; 62
     e3c:	8c 01       	movw	r16, r24
     e3e:	6b 01       	movw	r12, r22
     e40:	5d 83       	std	Y+5, r21	; 0x05
     e42:	4c 83       	std	Y+4, r20	; 0x04
     e44:	72 2e       	mov	r7, r18
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e46:	48 e0       	ldi	r20, 0x08	; 8
     e48:	e4 2e       	mov	r14, r20
     e4a:	f1 2c       	mov	r15, r1
     e4c:	e8 0e       	add	r14, r24
     e4e:	f9 1e       	adc	r15, r25
     e50:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e52:	5e 01       	movw	r10, r28
     e54:	08 94       	sec
     e56:	a1 1c       	adc	r10, r1
     e58:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e5a:	34 e0       	ldi	r19, 0x04	; 4
     e5c:	83 2e       	mov	r8, r19
     e5e:	91 2c       	mov	r9, r1
     e60:	8c 0e       	add	r8, r28
     e62:	9d 1e       	adc	r9, r29
     e64:	01 c0       	rjmp	.+2      	; 0xe68 <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e66:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e68:	0f b6       	in	r0, 0x3f	; 63
     e6a:	f8 94       	cli
     e6c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e6e:	f8 01       	movw	r30, r16
     e70:	92 8d       	ldd	r25, Z+26	; 0x1a
     e72:	83 8d       	ldd	r24, Z+27	; 0x1b
     e74:	98 17       	cp	r25, r24
     e76:	a8 f4       	brcc	.+42     	; 0xea2 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e78:	c8 01       	movw	r24, r16
     e7a:	b6 01       	movw	r22, r12
     e7c:	47 2d       	mov	r20, r7
     e7e:	0e 94 97 05 	call	0xb2e	; 0xb2e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e82:	f8 01       	movw	r30, r16
     e84:	81 89       	ldd	r24, Z+17	; 0x11
     e86:	88 23       	and	r24, r24
     e88:	41 f0       	breq	.+16     	; 0xe9a <xQueueGenericSend+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     e8a:	c8 01       	movw	r24, r16
     e8c:	41 96       	adiw	r24, 0x11	; 17
     e8e:	0e 94 b8 08 	call	0x1170	; 0x1170 <xTaskRemoveFromEventList>
     e92:	81 30       	cpi	r24, 0x01	; 1
     e94:	11 f4       	brne	.+4      	; 0xe9a <xQueueGenericSend+0x82>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
     e96:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
     e9a:	0f 90       	pop	r0
     e9c:	0f be       	out	0x3f, r0	; 63
     e9e:	81 e0       	ldi	r24, 0x01	; 1
     ea0:	4c c0       	rjmp	.+152    	; 0xf3a <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     ea2:	8c 81       	ldd	r24, Y+4	; 0x04
     ea4:	9d 81       	ldd	r25, Y+5	; 0x05
     ea6:	89 2b       	or	r24, r25
     ea8:	19 f4       	brne	.+6      	; 0xeb0 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     eaa:	0f 90       	pop	r0
     eac:	0f be       	out	0x3f, r0	; 63
     eae:	44 c0       	rjmp	.+136    	; 0xf38 <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
     eb0:	22 23       	and	r18, r18
     eb2:	19 f4       	brne	.+6      	; 0xeba <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     eb4:	c5 01       	movw	r24, r10
     eb6:	0e 94 6f 08 	call	0x10de	; 0x10de <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ebe:	0e 94 13 08 	call	0x1026	; 0x1026 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	0f 92       	push	r0
     ec8:	f8 01       	movw	r30, r16
     eca:	85 8d       	ldd	r24, Z+29	; 0x1d
     ecc:	8f 3f       	cpi	r24, 0xFF	; 255
     ece:	09 f4       	brne	.+2      	; 0xed2 <xQueueGenericSend+0xba>
     ed0:	15 8e       	std	Z+29, r1	; 0x1d
     ed2:	f8 01       	movw	r30, r16
     ed4:	86 8d       	ldd	r24, Z+30	; 0x1e
     ed6:	8f 3f       	cpi	r24, 0xFF	; 255
     ed8:	09 f4       	brne	.+2      	; 0xedc <xQueueGenericSend+0xc4>
     eda:	16 8e       	std	Z+30, r1	; 0x1e
     edc:	0f 90       	pop	r0
     ede:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ee0:	c5 01       	movw	r24, r10
     ee2:	b4 01       	movw	r22, r8
     ee4:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <xTaskCheckForTimeOut>
     ee8:	88 23       	and	r24, r24
     eea:	09 f5       	brne	.+66     	; 0xf2e <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     eec:	0f b6       	in	r0, 0x3f	; 63
     eee:	f8 94       	cli
     ef0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
     ef2:	f8 01       	movw	r30, r16
     ef4:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     ef6:	0f 90       	pop	r0
     ef8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
     efa:	f8 01       	movw	r30, r16
     efc:	83 8d       	ldd	r24, Z+27	; 0x1b
     efe:	98 17       	cp	r25, r24
     f00:	81 f4       	brne	.+32     	; 0xf22 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f02:	6c 81       	ldd	r22, Y+4	; 0x04
     f04:	7d 81       	ldd	r23, Y+5	; 0x05
     f06:	c7 01       	movw	r24, r14
     f08:	0e 94 71 09 	call	0x12e2	; 0x12e2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f0c:	c8 01       	movw	r24, r16
     f0e:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
     f12:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     f16:	88 23       	and	r24, r24
     f18:	09 f0       	breq	.+2      	; 0xf1c <xQueueGenericSend+0x104>
     f1a:	a5 cf       	rjmp	.-182    	; 0xe66 <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
     f1c:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
     f20:	a2 cf       	rjmp	.-188    	; 0xe66 <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f22:	c8 01       	movw	r24, r16
     f24:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f28:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     f2c:	9c cf       	rjmp	.-200    	; 0xe66 <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f2e:	c8 01       	movw	r24, r16
     f30:	0e 94 00 06 	call	0xc00	; 0xc00 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f34:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
     f38:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	0f 90       	pop	r0
     f40:	0f 90       	pop	r0
     f42:	0f 90       	pop	r0
     f44:	cf 91       	pop	r28
     f46:	df 91       	pop	r29
     f48:	1f 91       	pop	r17
     f4a:	0f 91       	pop	r16
     f4c:	ff 90       	pop	r15
     f4e:	ef 90       	pop	r14
     f50:	df 90       	pop	r13
     f52:	cf 90       	pop	r12
     f54:	bf 90       	pop	r11
     f56:	af 90       	pop	r10
     f58:	9f 90       	pop	r9
     f5a:	8f 90       	pop	r8
     f5c:	7f 90       	pop	r7
     f5e:	08 95       	ret

00000f60 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     f60:	8f 92       	push	r8
     f62:	9f 92       	push	r9
     f64:	af 92       	push	r10
     f66:	bf 92       	push	r11
     f68:	cf 92       	push	r12
     f6a:	df 92       	push	r13
     f6c:	ef 92       	push	r14
     f6e:	ff 92       	push	r15
     f70:	0f 93       	push	r16
     f72:	1f 93       	push	r17
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
     f78:	98 2e       	mov	r9, r24
     f7a:	86 2e       	mov	r8, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     f7c:	88 23       	and	r24, r24
     f7e:	09 f4       	brne	.+2      	; 0xf82 <xQueueCreate+0x22>
     f80:	42 c0       	rjmp	.+132    	; 0x1006 <xQueueCreate+0xa6>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     f82:	8f e1       	ldi	r24, 0x1F	; 31
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <pvPortMalloc>
     f8a:	8c 01       	movw	r16, r24
     f8c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f8e:	00 97       	sbiw	r24, 0x00	; 0
     f90:	e1 f1       	breq	.+120    	; 0x100a <xQueueCreate+0xaa>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     f92:	c9 2c       	mov	r12, r9
     f94:	dd 24       	eor	r13, r13
     f96:	a8 2c       	mov	r10, r8
     f98:	bb 24       	eor	r11, r11
     f9a:	ac 9c       	mul	r10, r12
     f9c:	70 01       	movw	r14, r0
     f9e:	ad 9c       	mul	r10, r13
     fa0:	f0 0c       	add	r15, r0
     fa2:	bc 9c       	mul	r11, r12
     fa4:	f0 0c       	add	r15, r0
     fa6:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     fa8:	c7 01       	movw	r24, r14
     faa:	01 96       	adiw	r24, 0x01	; 1
     fac:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <pvPortMalloc>
     fb0:	9c 01       	movw	r18, r24
     fb2:	99 83       	std	Y+1, r25	; 0x01
     fb4:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     fb6:	00 97       	sbiw	r24, 0x00	; 0
     fb8:	19 f1       	breq	.+70     	; 0x1000 <xQueueCreate+0xa0>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
     fba:	e8 0e       	add	r14, r24
     fbc:	f9 1e       	adc	r15, r25
     fbe:	fb 82       	std	Y+3, r15	; 0x03
     fc0:	ea 82       	std	Y+2, r14	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
     fc2:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
     fc4:	9d 83       	std	Y+5, r25	; 0x05
     fc6:	8c 83       	std	Y+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
     fc8:	08 94       	sec
     fca:	c1 08       	sbc	r12, r1
     fcc:	d1 08       	sbc	r13, r1
     fce:	ca 9c       	mul	r12, r10
     fd0:	c0 01       	movw	r24, r0
     fd2:	cb 9c       	mul	r12, r11
     fd4:	90 0d       	add	r25, r0
     fd6:	da 9c       	mul	r13, r10
     fd8:	90 0d       	add	r25, r0
     fda:	11 24       	eor	r1, r1
     fdc:	28 0f       	add	r18, r24
     fde:	39 1f       	adc	r19, r25
     fe0:	3f 83       	std	Y+7, r19	; 0x07
     fe2:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
     fe4:	9b 8e       	std	Y+27, r9	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     fe6:	8c 8e       	std	Y+28, r8	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
     fe8:	8f ef       	ldi	r24, 0xFF	; 255
     fea:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
     fec:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     fee:	c8 01       	movw	r24, r16
     ff0:	08 96       	adiw	r24, 0x08	; 8
     ff2:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     ff6:	c8 01       	movw	r24, r16
     ff8:	41 96       	adiw	r24, 0x11	; 17
     ffa:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
     ffe:	05 c0       	rjmp	.+10     	; 0x100a <xQueueCreate+0xaa>
				return  pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1000:	c8 01       	movw	r24, r16
    1002:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>
    1006:	c0 e0       	ldi	r28, 0x00	; 0
    1008:	d0 e0       	ldi	r29, 0x00	; 0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
    100a:	ce 01       	movw	r24, r28
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	1f 91       	pop	r17
    1012:	0f 91       	pop	r16
    1014:	ff 90       	pop	r15
    1016:	ef 90       	pop	r14
    1018:	df 90       	pop	r13
    101a:	cf 90       	pop	r12
    101c:	bf 90       	pop	r11
    101e:	af 90       	pop	r10
    1020:	9f 90       	pop	r9
    1022:	8f 90       	pop	r8
    1024:	08 95       	ret

00001026 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1026:	80 91 a6 03 	lds	r24, 0x03A6
    102a:	8f 5f       	subi	r24, 0xFF	; 255
    102c:	80 93 a6 03 	sts	0x03A6, r24
}
    1030:	08 95       	ret

00001032 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    1032:	0f b6       	in	r0, 0x3f	; 63
    1034:	f8 94       	cli
    1036:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1038:	20 91 a4 03 	lds	r18, 0x03A4
    103c:	30 91 a5 03 	lds	r19, 0x03A5
	}
	portEXIT_CRITICAL();
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1044:	c9 01       	movw	r24, r18
    1046:	08 95       	ret

00001048 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
	return xTickCount;
    1048:	20 91 a4 03 	lds	r18, 0x03A4
    104c:	30 91 a5 03 	lds	r19, 0x03A5
}
    1050:	c9 01       	movw	r24, r18
    1052:	08 95       	ret

00001054 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1054:	80 91 a9 03 	lds	r24, 0x03A9
}
    1058:	08 95       	ret

0000105a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    105a:	80 91 a6 03 	lds	r24, 0x03A6
    105e:	88 23       	and	r24, r24
    1060:	51 f0       	breq	.+20     	; 0x1076 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	80 93 a2 03 	sts	0x03A2, r24
    1068:	08 95       	ret
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    106a:	80 91 a7 03 	lds	r24, 0x03A7
    106e:	81 50       	subi	r24, 0x01	; 1
    1070:	80 93 a7 03 	sts	0x03A7, r24
    1074:	01 c0       	rjmp	.+2      	; 0x1078 <vTaskSwitchContext+0x1e>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1076:	99 e0       	ldi	r25, 0x09	; 9
    1078:	e0 91 a7 03 	lds	r30, 0x03A7
    107c:	e9 9f       	mul	r30, r25
    107e:	f0 01       	movw	r30, r0
    1080:	11 24       	eor	r1, r1
    1082:	e2 55       	subi	r30, 0x52	; 82
    1084:	fc 4f       	sbci	r31, 0xFC	; 252
    1086:	80 81       	ld	r24, Z
    1088:	88 23       	and	r24, r24
    108a:	79 f3       	breq	.-34     	; 0x106a <vTaskSwitchContext+0x10>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    108c:	90 91 a7 03 	lds	r25, 0x03A7
    1090:	89 e0       	ldi	r24, 0x09	; 9
    1092:	98 9f       	mul	r25, r24
    1094:	d0 01       	movw	r26, r0
    1096:	11 24       	eor	r1, r1
    1098:	a2 55       	subi	r26, 0x52	; 82
    109a:	bc 4f       	sbci	r27, 0xFC	; 252
    109c:	11 96       	adiw	r26, 0x01	; 1
    109e:	ed 91       	ld	r30, X+
    10a0:	fc 91       	ld	r31, X
    10a2:	12 97       	sbiw	r26, 0x02	; 2
    10a4:	02 80       	ldd	r0, Z+2	; 0x02
    10a6:	f3 81       	ldd	r31, Z+3	; 0x03
    10a8:	e0 2d       	mov	r30, r0
    10aa:	12 96       	adiw	r26, 0x02	; 2
    10ac:	fc 93       	st	X, r31
    10ae:	ee 93       	st	-X, r30
    10b0:	11 97       	sbiw	r26, 0x01	; 1
    10b2:	cd 01       	movw	r24, r26
    10b4:	03 96       	adiw	r24, 0x03	; 3
    10b6:	e8 17       	cp	r30, r24
    10b8:	f9 07       	cpc	r31, r25
    10ba:	31 f4       	brne	.+12     	; 0x10c8 <vTaskSwitchContext+0x6e>
    10bc:	82 81       	ldd	r24, Z+2	; 0x02
    10be:	93 81       	ldd	r25, Z+3	; 0x03
    10c0:	12 96       	adiw	r26, 0x02	; 2
    10c2:	9c 93       	st	X, r25
    10c4:	8e 93       	st	-X, r24
    10c6:	11 97       	sbiw	r26, 0x01	; 1
    10c8:	11 96       	adiw	r26, 0x01	; 1
    10ca:	ed 91       	ld	r30, X+
    10cc:	fc 91       	ld	r31, X
    10ce:	12 97       	sbiw	r26, 0x02	; 2
    10d0:	86 81       	ldd	r24, Z+6	; 0x06
    10d2:	97 81       	ldd	r25, Z+7	; 0x07
    10d4:	90 93 a1 03 	sts	0x03A1, r25
    10d8:	80 93 a0 03 	sts	0x03A0, r24
    10dc:	08 95       	ret

000010de <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    10de:	fc 01       	movw	r30, r24
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10e0:	80 91 a3 03 	lds	r24, 0x03A3
    10e4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    10e6:	80 91 a4 03 	lds	r24, 0x03A4
    10ea:	90 91 a5 03 	lds	r25, 0x03A5
    10ee:	92 83       	std	Z+2, r25	; 0x02
    10f0:	81 83       	std	Z+1, r24	; 0x01
}
    10f2:	08 95       	ret

000010f4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    10f4:	fc 01       	movw	r30, r24
    10f6:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    10f8:	0f b6       	in	r0, 0x3f	; 63
    10fa:	f8 94       	cli
    10fc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    10fe:	90 91 a3 03 	lds	r25, 0x03A3
    1102:	80 81       	ld	r24, Z
    1104:	98 17       	cp	r25, r24
    1106:	49 f0       	breq	.+18     	; 0x111a <xTaskCheckForTimeOut+0x26>
    1108:	20 91 a4 03 	lds	r18, 0x03A4
    110c:	30 91 a5 03 	lds	r19, 0x03A5
    1110:	81 81       	ldd	r24, Z+1	; 0x01
    1112:	92 81       	ldd	r25, Z+2	; 0x02
    1114:	28 17       	cp	r18, r24
    1116:	39 07       	cpc	r19, r25
    1118:	18 f5       	brcc	.+70     	; 0x1160 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    111a:	80 91 a4 03 	lds	r24, 0x03A4
    111e:	90 91 a5 03 	lds	r25, 0x03A5
    1122:	21 81       	ldd	r18, Z+1	; 0x01
    1124:	32 81       	ldd	r19, Z+2	; 0x02
    1126:	4d 91       	ld	r20, X+
    1128:	5c 91       	ld	r21, X
    112a:	11 97       	sbiw	r26, 0x01	; 1
    112c:	82 1b       	sub	r24, r18
    112e:	93 0b       	sbc	r25, r19
    1130:	84 17       	cp	r24, r20
    1132:	95 07       	cpc	r25, r21
    1134:	a8 f4       	brcc	.+42     	; 0x1160 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1136:	80 91 a4 03 	lds	r24, 0x03A4
    113a:	90 91 a5 03 	lds	r25, 0x03A5
    113e:	28 1b       	sub	r18, r24
    1140:	39 0b       	sbc	r19, r25
    1142:	24 0f       	add	r18, r20
    1144:	35 1f       	adc	r19, r21
    1146:	2d 93       	st	X+, r18
    1148:	3c 93       	st	X, r19
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    114a:	80 91 a3 03 	lds	r24, 0x03A3
    114e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1150:	80 91 a4 03 	lds	r24, 0x03A4
    1154:	90 91 a5 03 	lds	r25, 0x03A5
    1158:	92 83       	std	Z+2, r25	; 0x02
    115a:	81 83       	std	Z+1, r24	; 0x01
    115c:	80 e0       	ldi	r24, 0x00	; 0
    115e:	01 c0       	rjmp	.+2      	; 0x1162 <xTaskCheckForTimeOut+0x6e>
    1160:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
    1162:	0f 90       	pop	r0
    1164:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1166:	08 95       	ret

00001168 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1168:	81 e0       	ldi	r24, 0x01	; 1
    116a:	80 93 a2 03 	sts	0x03A2, r24
}
    116e:	08 95       	ret

00001170 <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1170:	0f 93       	push	r16
    1172:	1f 93       	push	r17
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	fc 01       	movw	r30, r24
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    117a:	80 81       	ld	r24, Z
    117c:	88 23       	and	r24, r24
    117e:	19 f4       	brne	.+6      	; 0x1186 <xTaskRemoveFromEventList+0x16>
    1180:	c0 e0       	ldi	r28, 0x00	; 0
    1182:	d0 e0       	ldi	r29, 0x00	; 0
    1184:	05 c0       	rjmp	.+10     	; 0x1190 <xTaskRemoveFromEventList+0x20>
    1186:	05 80       	ldd	r0, Z+5	; 0x05
    1188:	f6 81       	ldd	r31, Z+6	; 0x06
    118a:	e0 2d       	mov	r30, r0
    118c:	c6 81       	ldd	r28, Z+6	; 0x06
    118e:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1190:	8e 01       	movw	r16, r28
    1192:	04 5f       	subi	r16, 0xF4	; 244
    1194:	1f 4f       	sbci	r17, 0xFF	; 255
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    119c:	80 91 a6 03 	lds	r24, 0x03A6
    11a0:	88 23       	and	r24, r24
    11a2:	a1 f4       	brne	.+40     	; 0x11cc <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    11a4:	8e 01       	movw	r16, r28
    11a6:	0e 5f       	subi	r16, 0xFE	; 254
    11a8:	1f 4f       	sbci	r17, 0xFF	; 255
    11aa:	c8 01       	movw	r24, r16
    11ac:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    11b0:	9e 89       	ldd	r25, Y+22	; 0x16
    11b2:	80 91 a7 03 	lds	r24, 0x03A7
    11b6:	89 17       	cp	r24, r25
    11b8:	10 f4       	brcc	.+4      	; 0x11be <xTaskRemoveFromEventList+0x4e>
    11ba:	90 93 a7 03 	sts	0x03A7, r25
    11be:	89 e0       	ldi	r24, 0x09	; 9
    11c0:	98 9f       	mul	r25, r24
    11c2:	c0 01       	movw	r24, r0
    11c4:	11 24       	eor	r1, r1
    11c6:	82 55       	subi	r24, 0x52	; 82
    11c8:	9c 4f       	sbci	r25, 0xFC	; 252
    11ca:	02 c0       	rjmp	.+4      	; 0x11d0 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    11cc:	88 ee       	ldi	r24, 0xE8	; 232
    11ce:	93 e0       	ldi	r25, 0x03	; 3
    11d0:	b8 01       	movw	r22, r16
    11d2:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    11d6:	e0 91 a0 03 	lds	r30, 0x03A0
    11da:	f0 91 a1 03 	lds	r31, 0x03A1
    11de:	20 e0       	ldi	r18, 0x00	; 0
    11e0:	9e 89       	ldd	r25, Y+22	; 0x16
    11e2:	86 89       	ldd	r24, Z+22	; 0x16
    11e4:	98 17       	cp	r25, r24
    11e6:	08 f0       	brcs	.+2      	; 0x11ea <xTaskRemoveFromEventList+0x7a>
    11e8:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    11ea:	82 2f       	mov	r24, r18
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	1f 91       	pop	r17
    11f2:	0f 91       	pop	r16
    11f4:	08 95       	ret

000011f6 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    11f6:	ff 92       	push	r15
    11f8:	0f 93       	push	r16
    11fa:	1f 93       	push	r17
    11fc:	cf 93       	push	r28
    11fe:	df 93       	push	r29
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1200:	80 91 a6 03 	lds	r24, 0x03A6
    1204:	88 23       	and	r24, r24
    1206:	09 f0       	breq	.+2      	; 0x120a <vTaskIncrementTick+0x14>
    1208:	61 c0       	rjmp	.+194    	; 0x12cc <vTaskIncrementTick+0xd6>
	{
		++xTickCount;
    120a:	80 91 a4 03 	lds	r24, 0x03A4
    120e:	90 91 a5 03 	lds	r25, 0x03A5
    1212:	01 96       	adiw	r24, 0x01	; 1
    1214:	90 93 a5 03 	sts	0x03A5, r25
    1218:	80 93 a4 03 	sts	0x03A4, r24
		if( xTickCount == ( portTickType ) 0 )
    121c:	80 91 a4 03 	lds	r24, 0x03A4
    1220:	90 91 a5 03 	lds	r25, 0x03A5
    1224:	89 2b       	or	r24, r25
    1226:	e9 f5       	brne	.+122    	; 0x12a2 <vTaskIncrementTick+0xac>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1228:	80 91 e4 03 	lds	r24, 0x03E4
    122c:	90 91 e5 03 	lds	r25, 0x03E5
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1230:	20 91 e6 03 	lds	r18, 0x03E6
    1234:	30 91 e7 03 	lds	r19, 0x03E7
    1238:	30 93 e5 03 	sts	0x03E5, r19
    123c:	20 93 e4 03 	sts	0x03E4, r18
			pxOverflowDelayedTaskList = pxTemp;
    1240:	90 93 e7 03 	sts	0x03E7, r25
    1244:	80 93 e6 03 	sts	0x03E6, r24
			xNumOfOverflows++;
    1248:	80 91 a3 03 	lds	r24, 0x03A3
    124c:	8f 5f       	subi	r24, 0xFF	; 255
    124e:	80 93 a3 03 	sts	0x03A3, r24
    1252:	27 c0       	rjmp	.+78     	; 0x12a2 <vTaskIncrementTick+0xac>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1254:	20 91 a4 03 	lds	r18, 0x03A4
    1258:	30 91 a5 03 	lds	r19, 0x03A5
    125c:	8a 81       	ldd	r24, Y+2	; 0x02
    125e:	9b 81       	ldd	r25, Y+3	; 0x03
    1260:	28 17       	cp	r18, r24
    1262:	39 07       	cpc	r19, r25
    1264:	c0 f1       	brcs	.+112    	; 0x12d6 <vTaskIncrementTick+0xe0>
    1266:	8e 01       	movw	r16, r28
    1268:	0e 5f       	subi	r16, 0xFE	; 254
    126a:	1f 4f       	sbci	r17, 0xFF	; 255
    126c:	c8 01       	movw	r24, r16
    126e:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
    1272:	8c 89       	ldd	r24, Y+20	; 0x14
    1274:	9d 89       	ldd	r25, Y+21	; 0x15
    1276:	89 2b       	or	r24, r25
    1278:	21 f0       	breq	.+8      	; 0x1282 <vTaskIncrementTick+0x8c>
    127a:	ce 01       	movw	r24, r28
    127c:	0c 96       	adiw	r24, 0x0c	; 12
    127e:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
    1282:	9e 89       	ldd	r25, Y+22	; 0x16
    1284:	80 91 a7 03 	lds	r24, 0x03A7
    1288:	89 17       	cp	r24, r25
    128a:	10 f4       	brcc	.+4      	; 0x1290 <vTaskIncrementTick+0x9a>
    128c:	90 93 a7 03 	sts	0x03A7, r25
    1290:	9f 9d       	mul	r25, r15
    1292:	c0 01       	movw	r24, r0
    1294:	11 24       	eor	r1, r1
    1296:	82 55       	subi	r24, 0x52	; 82
    1298:	9c 4f       	sbci	r25, 0xFC	; 252
    129a:	b8 01       	movw	r22, r16
    129c:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
    12a0:	02 c0       	rjmp	.+4      	; 0x12a6 <vTaskIncrementTick+0xb0>
    12a2:	89 e0       	ldi	r24, 0x09	; 9
    12a4:	f8 2e       	mov	r15, r24
    12a6:	e0 91 e4 03 	lds	r30, 0x03E4
    12aa:	f0 91 e5 03 	lds	r31, 0x03E5
    12ae:	80 81       	ld	r24, Z
    12b0:	88 23       	and	r24, r24
    12b2:	89 f0       	breq	.+34     	; 0x12d6 <vTaskIncrementTick+0xe0>
    12b4:	e0 91 e4 03 	lds	r30, 0x03E4
    12b8:	f0 91 e5 03 	lds	r31, 0x03E5
    12bc:	05 80       	ldd	r0, Z+5	; 0x05
    12be:	f6 81       	ldd	r31, Z+6	; 0x06
    12c0:	e0 2d       	mov	r30, r0
    12c2:	c6 81       	ldd	r28, Z+6	; 0x06
    12c4:	d7 81       	ldd	r29, Z+7	; 0x07
    12c6:	20 97       	sbiw	r28, 0x00	; 0
    12c8:	29 f6       	brne	.-118    	; 0x1254 <vTaskIncrementTick+0x5e>
    12ca:	05 c0       	rjmp	.+10     	; 0x12d6 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
    12cc:	80 91 a8 03 	lds	r24, 0x03A8
    12d0:	8f 5f       	subi	r24, 0xFF	; 255
    12d2:	80 93 a8 03 	sts	0x03A8, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	1f 91       	pop	r17
    12dc:	0f 91       	pop	r16
    12de:	ff 90       	pop	r15
    12e0:	08 95       	ret

000012e2 <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    12e2:	0f 93       	push	r16
    12e4:	1f 93       	push	r17
    12e6:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    12e8:	60 91 a0 03 	lds	r22, 0x03A0
    12ec:	70 91 a1 03 	lds	r23, 0x03A1
    12f0:	64 5f       	subi	r22, 0xF4	; 244
    12f2:	7f 4f       	sbci	r23, 0xFF	; 255
    12f4:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    12f8:	80 91 a0 03 	lds	r24, 0x03A0
    12fc:	90 91 a1 03 	lds	r25, 0x03A1
    1300:	02 96       	adiw	r24, 0x02	; 2
    1302:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1306:	80 91 a4 03 	lds	r24, 0x03A4
    130a:	90 91 a5 03 	lds	r25, 0x03A5
    130e:	80 0f       	add	r24, r16
    1310:	91 1f       	adc	r25, r17

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1312:	e0 91 a0 03 	lds	r30, 0x03A0
    1316:	f0 91 a1 03 	lds	r31, 0x03A1
    131a:	93 83       	std	Z+3, r25	; 0x03
    131c:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    131e:	20 91 a4 03 	lds	r18, 0x03A4
    1322:	30 91 a5 03 	lds	r19, 0x03A5
    1326:	82 17       	cp	r24, r18
    1328:	93 07       	cpc	r25, r19
    132a:	28 f4       	brcc	.+10     	; 0x1336 <vTaskPlaceOnEventList+0x54>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    132c:	80 91 e6 03 	lds	r24, 0x03E6
    1330:	90 91 e7 03 	lds	r25, 0x03E7
    1334:	04 c0       	rjmp	.+8      	; 0x133e <vTaskPlaceOnEventList+0x5c>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1336:	80 91 e4 03 	lds	r24, 0x03E4
    133a:	90 91 e5 03 	lds	r25, 0x03E5
    133e:	60 91 a0 03 	lds	r22, 0x03A0
    1342:	70 91 a1 03 	lds	r23, 0x03A1
    1346:	6e 5f       	subi	r22, 0xFE	; 254
    1348:	7f 4f       	sbci	r23, 0xFF	; 255
    134a:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>
			}
	}
	#endif
}
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	08 95       	ret

00001354 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1354:	cf 92       	push	r12
    1356:	df 92       	push	r13
    1358:	ff 92       	push	r15
    135a:	0f 93       	push	r16
    135c:	1f 93       	push	r17
    135e:	df 93       	push	r29
    1360:	cf 93       	push	r28
    1362:	0f 92       	push	r0
    1364:	cd b7       	in	r28, 0x3d	; 61
    1366:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    136e:	80 91 a6 03 	lds	r24, 0x03A6
    1372:	81 50       	subi	r24, 0x01	; 1
    1374:	80 93 a6 03 	sts	0x03A6, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1378:	80 91 a6 03 	lds	r24, 0x03A6
    137c:	88 23       	and	r24, r24
    137e:	09 f0       	breq	.+2      	; 0x1382 <xTaskResumeAll+0x2e>
    1380:	5b c0       	rjmp	.+182    	; 0x1438 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    1382:	80 91 a9 03 	lds	r24, 0x03A9
    1386:	88 23       	and	r24, r24
    1388:	09 f4       	brne	.+2      	; 0x138c <xTaskResumeAll+0x38>
    138a:	56 c0       	rjmp	.+172    	; 0x1438 <xTaskResumeAll+0xe4>
    138c:	19 82       	std	Y+1, r1	; 0x01
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    138e:	99 e0       	ldi	r25, 0x09	; 9
    1390:	f9 2e       	mov	r15, r25
    1392:	27 c0       	rjmp	.+78     	; 0x13e2 <xTaskResumeAll+0x8e>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    1394:	c6 01       	movw	r24, r12
    1396:	0c 96       	adiw	r24, 0x0c	; 12
    1398:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    139c:	86 01       	movw	r16, r12
    139e:	0e 5f       	subi	r16, 0xFE	; 254
    13a0:	1f 4f       	sbci	r17, 0xFF	; 255
    13a2:	c8 01       	movw	r24, r16
    13a4:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    13a8:	d6 01       	movw	r26, r12
    13aa:	56 96       	adiw	r26, 0x16	; 22
    13ac:	9c 91       	ld	r25, X
    13ae:	80 91 a7 03 	lds	r24, 0x03A7
    13b2:	89 17       	cp	r24, r25
    13b4:	10 f4       	brcc	.+4      	; 0x13ba <xTaskResumeAll+0x66>
    13b6:	90 93 a7 03 	sts	0x03A7, r25
    13ba:	9f 9d       	mul	r25, r15
    13bc:	c0 01       	movw	r24, r0
    13be:	11 24       	eor	r1, r1
    13c0:	82 55       	subi	r24, 0x52	; 82
    13c2:	9c 4f       	sbci	r25, 0xFC	; 252
    13c4:	b8 01       	movw	r22, r16
    13c6:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    13ca:	e0 91 a0 03 	lds	r30, 0x03A0
    13ce:	f0 91 a1 03 	lds	r31, 0x03A1
    13d2:	d6 01       	movw	r26, r12
    13d4:	56 96       	adiw	r26, 0x16	; 22
    13d6:	9c 91       	ld	r25, X
    13d8:	86 89       	ldd	r24, Z+22	; 0x16
    13da:	98 17       	cp	r25, r24
    13dc:	10 f0       	brcs	.+4      	; 0x13e2 <xTaskResumeAll+0x8e>
    13de:	b1 e0       	ldi	r27, 0x01	; 1
    13e0:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    13e2:	80 91 e8 03 	lds	r24, 0x03E8
    13e6:	88 23       	and	r24, r24
    13e8:	49 f0       	breq	.+18     	; 0x13fc <xTaskResumeAll+0xa8>
    13ea:	e0 91 ed 03 	lds	r30, 0x03ED
    13ee:	f0 91 ee 03 	lds	r31, 0x03EE
    13f2:	c6 80       	ldd	r12, Z+6	; 0x06
    13f4:	d7 80       	ldd	r13, Z+7	; 0x07
    13f6:	c1 14       	cp	r12, r1
    13f8:	d1 04       	cpc	r13, r1
    13fa:	61 f6       	brne	.-104    	; 0x1394 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    13fc:	80 91 a8 03 	lds	r24, 0x03A8
    1400:	88 23       	and	r24, r24
    1402:	41 f4       	brne	.+16     	; 0x1414 <xTaskResumeAll+0xc0>
    1404:	0c c0       	rjmp	.+24     	; 0x141e <xTaskResumeAll+0xca>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1406:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <vTaskIncrementTick>
						--uxMissedTicks;
    140a:	80 91 a8 03 	lds	r24, 0x03A8
    140e:	81 50       	subi	r24, 0x01	; 1
    1410:	80 93 a8 03 	sts	0x03A8, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1414:	80 91 a8 03 	lds	r24, 0x03A8
    1418:	88 23       	and	r24, r24
    141a:	a9 f7       	brne	.-22     	; 0x1406 <xTaskResumeAll+0xb2>
    141c:	07 c0       	rjmp	.+14     	; 0x142c <xTaskResumeAll+0xd8>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    141e:	e9 81       	ldd	r30, Y+1	; 0x01
    1420:	e1 30       	cpi	r30, 0x01	; 1
    1422:	21 f0       	breq	.+8      	; 0x142c <xTaskResumeAll+0xd8>
    1424:	80 91 a2 03 	lds	r24, 0x03A2
    1428:	81 30       	cpi	r24, 0x01	; 1
    142a:	31 f4       	brne	.+12     	; 0x1438 <xTaskResumeAll+0xe4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    142c:	10 92 a2 03 	sts	0x03A2, r1
					portYIELD_WITHIN_API();
    1430:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	01 c0       	rjmp	.+2      	; 0x143a <xTaskResumeAll+0xe6>
    1438:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	portEXIT_CRITICAL();
    143a:	0f 90       	pop	r0
    143c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    143e:	0f 90       	pop	r0
    1440:	cf 91       	pop	r28
    1442:	df 91       	pop	r29
    1444:	1f 91       	pop	r17
    1446:	0f 91       	pop	r16
    1448:	ff 90       	pop	r15
    144a:	df 90       	pop	r13
    144c:	cf 90       	pop	r12
    144e:	08 95       	ret

00001450 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1450:	0f 93       	push	r16
    1452:	1f 93       	push	r17
    1454:	9c 01       	movw	r18, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
    1456:	00 97       	sbiw	r24, 0x00	; 0
    1458:	a1 f1       	breq	.+104    	; 0x14c2 <vTaskDelay+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    145a:	80 91 a6 03 	lds	r24, 0x03A6
    145e:	8f 5f       	subi	r24, 0xFF	; 255
    1460:	80 93 a6 03 	sts	0x03A6, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1464:	00 91 a4 03 	lds	r16, 0x03A4
    1468:	10 91 a5 03 	lds	r17, 0x03A5
    146c:	02 0f       	add	r16, r18
    146e:	13 1f       	adc	r17, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1470:	80 91 a0 03 	lds	r24, 0x03A0
    1474:	90 91 a1 03 	lds	r25, 0x03A1
    1478:	02 96       	adiw	r24, 0x02	; 2
    147a:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    147e:	e0 91 a0 03 	lds	r30, 0x03A0
    1482:	f0 91 a1 03 	lds	r31, 0x03A1
    1486:	13 83       	std	Z+3, r17	; 0x03
    1488:	02 83       	std	Z+2, r16	; 0x02

				if( xTimeToWake < xTickCount )
    148a:	80 91 a4 03 	lds	r24, 0x03A4
    148e:	90 91 a5 03 	lds	r25, 0x03A5
    1492:	08 17       	cp	r16, r24
    1494:	19 07       	cpc	r17, r25
    1496:	28 f4       	brcc	.+10     	; 0x14a2 <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1498:	80 91 e6 03 	lds	r24, 0x03E6
    149c:	90 91 e7 03 	lds	r25, 0x03E7
    14a0:	04 c0       	rjmp	.+8      	; 0x14aa <vTaskDelay+0x5a>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    14a2:	80 91 e4 03 	lds	r24, 0x03E4
    14a6:	90 91 e5 03 	lds	r25, 0x03E5
    14aa:	60 91 a0 03 	lds	r22, 0x03A0
    14ae:	70 91 a1 03 	lds	r23, 0x03A1
    14b2:	6e 5f       	subi	r22, 0xFE	; 254
    14b4:	7f 4f       	sbci	r23, 0xFF	; 255
    14b6:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
    14ba:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    14be:	88 23       	and	r24, r24
    14c0:	11 f4       	brne	.+4      	; 0x14c6 <vTaskDelay+0x76>
		{
			portYIELD_WITHIN_API();
    14c2:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
		}
	}
    14c6:	1f 91       	pop	r17
    14c8:	0f 91       	pop	r16
    14ca:	08 95       	ret

000014cc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    14cc:	cf 93       	push	r28
    14ce:	df 93       	push	r29
    14d0:	fc 01       	movw	r30, r24
    14d2:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    14d4:	80 91 a6 03 	lds	r24, 0x03A6
    14d8:	8f 5f       	subi	r24, 0xFF	; 255
    14da:	80 93 a6 03 	sts	0x03A6, r24
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    14de:	20 81       	ld	r18, Z
    14e0:	31 81       	ldd	r19, Z+1	; 0x01
    14e2:	c2 0f       	add	r28, r18
    14e4:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
    14e6:	80 91 a4 03 	lds	r24, 0x03A4
    14ea:	90 91 a5 03 	lds	r25, 0x03A5
    14ee:	82 17       	cp	r24, r18
    14f0:	93 07       	cpc	r25, r19
    14f2:	28 f4       	brcc	.+10     	; 0x14fe <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    14f4:	c2 17       	cp	r28, r18
    14f6:	d3 07       	cpc	r29, r19
    14f8:	28 f0       	brcs	.+10     	; 0x1504 <vTaskDelayUntil+0x38>
    14fa:	20 e0       	ldi	r18, 0x00	; 0
    14fc:	0c c0       	rjmp	.+24     	; 0x1516 <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    14fe:	c2 17       	cp	r28, r18
    1500:	d3 07       	cpc	r29, r19
    1502:	40 f0       	brcs	.+16     	; 0x1514 <vTaskDelayUntil+0x48>
    1504:	80 91 a4 03 	lds	r24, 0x03A4
    1508:	90 91 a5 03 	lds	r25, 0x03A5
    150c:	20 e0       	ldi	r18, 0x00	; 0
    150e:	8c 17       	cp	r24, r28
    1510:	9d 07       	cpc	r25, r29
    1512:	08 f4       	brcc	.+2      	; 0x1516 <vTaskDelayUntil+0x4a>
    1514:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1516:	d1 83       	std	Z+1, r29	; 0x01
    1518:	c0 83       	st	Z, r28

			if( xShouldDelay )
    151a:	22 23       	and	r18, r18
    151c:	29 f1       	breq	.+74     	; 0x1568 <vTaskDelayUntil+0x9c>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    151e:	80 91 a0 03 	lds	r24, 0x03A0
    1522:	90 91 a1 03 	lds	r25, 0x03A1
    1526:	02 96       	adiw	r24, 0x02	; 2
    1528:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    152c:	e0 91 a0 03 	lds	r30, 0x03A0
    1530:	f0 91 a1 03 	lds	r31, 0x03A1
    1534:	d3 83       	std	Z+3, r29	; 0x03
    1536:	c2 83       	std	Z+2, r28	; 0x02

				if( xTimeToWake < xTickCount )
    1538:	80 91 a4 03 	lds	r24, 0x03A4
    153c:	90 91 a5 03 	lds	r25, 0x03A5
    1540:	c8 17       	cp	r28, r24
    1542:	d9 07       	cpc	r29, r25
    1544:	28 f4       	brcc	.+10     	; 0x1550 <vTaskDelayUntil+0x84>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1546:	80 91 e6 03 	lds	r24, 0x03E6
    154a:	90 91 e7 03 	lds	r25, 0x03E7
    154e:	04 c0       	rjmp	.+8      	; 0x1558 <vTaskDelayUntil+0x8c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1550:	80 91 e4 03 	lds	r24, 0x03E4
    1554:	90 91 e5 03 	lds	r25, 0x03E5
    1558:	60 91 a0 03 	lds	r22, 0x03A0
    155c:	70 91 a1 03 	lds	r23, 0x03A1
    1560:	6e 5f       	subi	r22, 0xFE	; 254
    1562:	7f 4f       	sbci	r23, 0xFF	; 255
    1564:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1568:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
    156c:	88 23       	and	r24, r24
    156e:	11 f4       	brne	.+4      	; 0x1574 <vTaskDelayUntil+0xa8>
		{
			portYIELD_WITHIN_API();
    1570:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
		}
	}
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	08 95       	ret

0000157a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    157a:	ef 92       	push	r14
    157c:	ff 92       	push	r15
    157e:	0f 93       	push	r16
    1580:	1f 93       	push	r17
    1582:	cf 93       	push	r28
    1584:	df 93       	push	r29
    1586:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		portENTER_CRITICAL();
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    158e:	80 91 a0 03 	lds	r24, 0x03A0
    1592:	90 91 a1 03 	lds	r25, 0x03A1
    1596:	08 17       	cp	r16, r24
    1598:	19 07       	cpc	r17, r25
    159a:	19 f4       	brne	.+6      	; 0x15a2 <vTaskDelete+0x28>
    159c:	00 e0       	ldi	r16, 0x00	; 0
    159e:	10 e0       	ldi	r17, 0x00	; 0
    15a0:	03 c0       	rjmp	.+6      	; 0x15a8 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    15a2:	01 15       	cp	r16, r1
    15a4:	11 05       	cpc	r17, r1
    15a6:	29 f4       	brne	.+10     	; 0x15b2 <vTaskDelete+0x38>
    15a8:	c0 91 a0 03 	lds	r28, 0x03A0
    15ac:	d0 91 a1 03 	lds	r29, 0x03A1
    15b0:	01 c0       	rjmp	.+2      	; 0x15b4 <vTaskDelete+0x3a>
    15b2:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    15b4:	22 e0       	ldi	r18, 0x02	; 2
    15b6:	e2 2e       	mov	r14, r18
    15b8:	f1 2c       	mov	r15, r1
    15ba:	ec 0e       	add	r14, r28
    15bc:	fd 1e       	adc	r15, r29
    15be:	c7 01       	movw	r24, r14
    15c0:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
    15c4:	8c 89       	ldd	r24, Y+20	; 0x14
    15c6:	9d 89       	ldd	r25, Y+21	; 0x15
    15c8:	89 2b       	or	r24, r25
    15ca:	21 f0       	breq	.+8      	; 0x15d4 <vTaskDelete+0x5a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    15cc:	ce 01       	movw	r24, r28
    15ce:	0c 96       	adiw	r24, 0x0c	; 12
    15d0:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    15d4:	81 ef       	ldi	r24, 0xF1	; 241
    15d6:	93 e0       	ldi	r25, 0x03	; 3
    15d8:	b7 01       	movw	r22, r14
    15da:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    15de:	80 91 ab 03 	lds	r24, 0x03AB
    15e2:	8f 5f       	subi	r24, 0xFF	; 255
    15e4:	80 93 ab 03 	sts	0x03AB, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    15e8:	80 91 ac 03 	lds	r24, 0x03AC
    15ec:	8f 5f       	subi	r24, 0xFF	; 255
    15ee:	80 93 ac 03 	sts	0x03AC, r24

			traceTASK_DELETE( pxTCB );
		}
		portEXIT_CRITICAL();
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    15f6:	80 91 aa 03 	lds	r24, 0x03AA
    15fa:	88 23       	and	r24, r24
    15fc:	21 f0       	breq	.+8      	; 0x1606 <vTaskDelete+0x8c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    15fe:	01 2b       	or	r16, r17
    1600:	11 f4       	brne	.+4      	; 0x1606 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
    1602:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
			}
		}
	}
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	1f 91       	pop	r17
    160c:	0f 91       	pop	r16
    160e:	ff 90       	pop	r15
    1610:	ef 90       	pop	r14
    1612:	08 95       	ret

00001614 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1614:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1616:	10 92 aa 03 	sts	0x03AA, r1
	vPortEndScheduler();
    161a:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <vPortEndScheduler>
}
    161e:	08 95       	ret

00001620 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    1620:	1f 93       	push	r17
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
    1626:	80 91 ab 03 	lds	r24, 0x03AB
    162a:	88 23       	and	r24, r24
    162c:	91 f1       	breq	.+100    	; 0x1692 <prvIdleTask+0x72>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    162e:	80 91 a6 03 	lds	r24, 0x03A6
    1632:	8f 5f       	subi	r24, 0xFF	; 255
    1634:	80 93 a6 03 	sts	0x03A6, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1638:	10 91 f1 03 	lds	r17, 0x03F1
			xTaskResumeAll();
    163c:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>

			if( !xListIsEmpty )
    1640:	11 23       	and	r17, r17
    1642:	39 f1       	breq	.+78     	; 0x1692 <prvIdleTask+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
    1644:	0f b6       	in	r0, 0x3f	; 63
    1646:	f8 94       	cli
    1648:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    164a:	80 91 f1 03 	lds	r24, 0x03F1
    164e:	88 23       	and	r24, r24
    1650:	19 f4       	brne	.+6      	; 0x1658 <prvIdleTask+0x38>
    1652:	c0 e0       	ldi	r28, 0x00	; 0
    1654:	d0 e0       	ldi	r29, 0x00	; 0
    1656:	06 c0       	rjmp	.+12     	; 0x1664 <prvIdleTask+0x44>
    1658:	e0 91 f6 03 	lds	r30, 0x03F6
    165c:	f0 91 f7 03 	lds	r31, 0x03F7
    1660:	c6 81       	ldd	r28, Z+6	; 0x06
    1662:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    1664:	ce 01       	movw	r24, r28
    1666:	02 96       	adiw	r24, 0x02	; 2
    1668:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
					--uxCurrentNumberOfTasks;
    166c:	80 91 a9 03 	lds	r24, 0x03A9
    1670:	81 50       	subi	r24, 0x01	; 1
    1672:	80 93 a9 03 	sts	0x03A9, r24
					--uxTasksDeleted;
    1676:	80 91 ab 03 	lds	r24, 0x03AB
    167a:	81 50       	subi	r24, 0x01	; 1
    167c:	80 93 ab 03 	sts	0x03AB, r24
				}
				portEXIT_CRITICAL();
    1680:	0f 90       	pop	r0
    1682:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1684:	8f 89       	ldd	r24, Y+23	; 0x17
    1686:	98 8d       	ldd	r25, Y+24	; 0x18
    1688:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>
		vPortFree( pxTCB );
    168c:	ce 01       	movw	r24, r28
    168e:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1692:	80 91 ae 03 	lds	r24, 0x03AE
    1696:	82 30       	cpi	r24, 0x02	; 2
    1698:	30 f2       	brcs	.-116    	; 0x1626 <prvIdleTask+0x6>
			{
				taskYIELD();
    169a:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
    169e:	c3 cf       	rjmp	.-122    	; 0x1626 <prvIdleTask+0x6>

000016a0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    16a0:	2f 92       	push	r2
    16a2:	3f 92       	push	r3
    16a4:	5f 92       	push	r5
    16a6:	6f 92       	push	r6
    16a8:	7f 92       	push	r7
    16aa:	8f 92       	push	r8
    16ac:	9f 92       	push	r9
    16ae:	af 92       	push	r10
    16b0:	bf 92       	push	r11
    16b2:	cf 92       	push	r12
    16b4:	df 92       	push	r13
    16b6:	ef 92       	push	r14
    16b8:	ff 92       	push	r15
    16ba:	0f 93       	push	r16
    16bc:	1f 93       	push	r17
    16be:	df 93       	push	r29
    16c0:	cf 93       	push	r28
    16c2:	00 d0       	rcall	.+0      	; 0x16c4 <xTaskGenericCreate+0x24>
    16c4:	00 d0       	rcall	.+0      	; 0x16c6 <xTaskGenericCreate+0x26>
    16c6:	cd b7       	in	r28, 0x3d	; 61
    16c8:	de b7       	in	r29, 0x3e	; 62
    16ca:	9a 83       	std	Y+2, r25	; 0x02
    16cc:	89 83       	std	Y+1, r24	; 0x01
    16ce:	4b 01       	movw	r8, r22
    16d0:	5a 01       	movw	r10, r20
    16d2:	19 01       	movw	r2, r18
    16d4:	50 2e       	mov	r5, r16
    16d6:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    16d8:	81 e2       	ldi	r24, 0x21	; 33
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <pvPortMalloc>
    16e0:	8b 83       	std	Y+3, r24	; 0x03
    16e2:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
    16e4:	8b 81       	ldd	r24, Y+3	; 0x03
    16e6:	9c 81       	ldd	r25, Y+4	; 0x04
    16e8:	89 2b       	or	r24, r25
    16ea:	89 f0       	breq	.+34     	; 0x170e <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    16ec:	c1 14       	cp	r12, r1
    16ee:	d1 04       	cpc	r13, r1
    16f0:	21 f4       	brne	.+8      	; 0x16fa <xTaskGenericCreate+0x5a>
    16f2:	c5 01       	movw	r24, r10
    16f4:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <pvPortMalloc>
    16f8:	6c 01       	movw	r12, r24
    16fa:	eb 81       	ldd	r30, Y+3	; 0x03
    16fc:	fc 81       	ldd	r31, Y+4	; 0x04
    16fe:	d0 8e       	std	Z+24, r13	; 0x18
    1700:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1702:	c1 14       	cp	r12, r1
    1704:	d1 04       	cpc	r13, r1
    1706:	29 f4       	brne	.+10     	; 0x1712 <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1708:	cf 01       	movw	r24, r30
    170a:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vPortFree>
    170e:	8f ef       	ldi	r24, 0xFF	; 255
    1710:	d5 c0       	rjmp	.+426    	; 0x18bc <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    1712:	c6 01       	movw	r24, r12
    1714:	65 ea       	ldi	r22, 0xA5	; 165
    1716:	70 e0       	ldi	r23, 0x00	; 0
    1718:	a5 01       	movw	r20, r10
    171a:	0e 94 69 26 	call	0x4cd2	; 0x4cd2 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    171e:	08 94       	sec
    1720:	a1 08       	sbc	r10, r1
    1722:	b1 08       	sbc	r11, r1
    1724:	eb 81       	ldd	r30, Y+3	; 0x03
    1726:	fc 81       	ldd	r31, Y+4	; 0x04
    1728:	e7 88       	ldd	r14, Z+23	; 0x17
    172a:	f0 8c       	ldd	r15, Z+24	; 0x18
    172c:	ea 0c       	add	r14, r10
    172e:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1730:	cf 01       	movw	r24, r30
    1732:	49 96       	adiw	r24, 0x19	; 25
    1734:	b4 01       	movw	r22, r8
    1736:	48 e0       	ldi	r20, 0x08	; 8
    1738:	50 e0       	ldi	r21, 0x00	; 0
    173a:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    173e:	eb 81       	ldd	r30, Y+3	; 0x03
    1740:	fc 81       	ldd	r31, Y+4	; 0x04
    1742:	10 a2       	std	Z+32, r1	; 0x20
    1744:	05 2d       	mov	r16, r5
    1746:	f3 e0       	ldi	r31, 0x03	; 3
    1748:	f5 15       	cp	r31, r5
    174a:	08 f4       	brcc	.+2      	; 0x174e <xTaskGenericCreate+0xae>
    174c:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
    174e:	eb 81       	ldd	r30, Y+3	; 0x03
    1750:	fc 81       	ldd	r31, Y+4	; 0x04
    1752:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1754:	42 e0       	ldi	r20, 0x02	; 2
    1756:	c4 2e       	mov	r12, r20
    1758:	d1 2c       	mov	r13, r1
    175a:	ce 0e       	add	r12, r30
    175c:	df 1e       	adc	r13, r31
    175e:	c6 01       	movw	r24, r12
    1760:	0e 94 a4 04 	call	0x948	; 0x948 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1764:	8b 81       	ldd	r24, Y+3	; 0x03
    1766:	9c 81       	ldd	r25, Y+4	; 0x04
    1768:	0c 96       	adiw	r24, 0x0c	; 12
    176a:	0e 94 a4 04 	call	0x948	; 0x948 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    176e:	8b 81       	ldd	r24, Y+3	; 0x03
    1770:	9c 81       	ldd	r25, Y+4	; 0x04
    1772:	fc 01       	movw	r30, r24
    1774:	91 87       	std	Z+9, r25	; 0x09
    1776:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1778:	84 e0       	ldi	r24, 0x04	; 4
    177a:	90 e0       	ldi	r25, 0x00	; 0
    177c:	80 1b       	sub	r24, r16
    177e:	91 09       	sbc	r25, r1
    1780:	95 87       	std	Z+13, r25	; 0x0d
    1782:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1784:	f3 8b       	std	Z+19, r31	; 0x13
    1786:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1788:	c7 01       	movw	r24, r14
    178a:	69 81       	ldd	r22, Y+1	; 0x01
    178c:	7a 81       	ldd	r23, Y+2	; 0x02
    178e:	a1 01       	movw	r20, r2
    1790:	0e 94 9f 0c 	call	0x193e	; 0x193e <pxPortInitialiseStack>
    1794:	eb 81       	ldd	r30, Y+3	; 0x03
    1796:	fc 81       	ldd	r31, Y+4	; 0x04
    1798:	91 83       	std	Z+1, r25	; 0x01
    179a:	80 83       	st	Z, r24
		}
		#endif

		if( ( void * ) pxCreatedTask != NULL )
    179c:	61 14       	cp	r6, r1
    179e:	71 04       	cpc	r7, r1
    17a0:	21 f0       	breq	.+8      	; 0x17aa <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    17a2:	cf 01       	movw	r24, r30
    17a4:	f3 01       	movw	r30, r6
    17a6:	91 83       	std	Z+1, r25	; 0x01
    17a8:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    17aa:	0f b6       	in	r0, 0x3f	; 63
    17ac:	f8 94       	cli
    17ae:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    17b0:	80 91 a9 03 	lds	r24, 0x03A9
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	80 93 a9 03 	sts	0x03A9, r24
			if( pxCurrentTCB == NULL )
    17ba:	80 91 a0 03 	lds	r24, 0x03A0
    17be:	90 91 a1 03 	lds	r25, 0x03A1
    17c2:	89 2b       	or	r24, r25
    17c4:	b9 f5       	brne	.+110    	; 0x1834 <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    17c6:	eb 81       	ldd	r30, Y+3	; 0x03
    17c8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ca:	f0 93 a1 03 	sts	0x03A1, r31
    17ce:	e0 93 a0 03 	sts	0x03A0, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    17d2:	80 91 a9 03 	lds	r24, 0x03A9
    17d6:	81 30       	cpi	r24, 0x01	; 1
    17d8:	f1 f5       	brne	.+124    	; 0x1856 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    17da:	8e ea       	ldi	r24, 0xAE	; 174
    17dc:	93 e0       	ldi	r25, 0x03	; 3
    17de:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
    17e2:	87 eb       	ldi	r24, 0xB7	; 183
    17e4:	93 e0       	ldi	r25, 0x03	; 3
    17e6:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
    17ea:	80 ec       	ldi	r24, 0xC0	; 192
    17ec:	93 e0       	ldi	r25, 0x03	; 3
    17ee:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
    17f2:	89 ec       	ldi	r24, 0xC9	; 201
    17f4:	93 e0       	ldi	r25, 0x03	; 3
    17f6:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    17fa:	32 ed       	ldi	r19, 0xD2	; 210
    17fc:	e3 2e       	mov	r14, r19
    17fe:	33 e0       	ldi	r19, 0x03	; 3
    1800:	f3 2e       	mov	r15, r19
    1802:	c7 01       	movw	r24, r14
    1804:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1808:	0b ed       	ldi	r16, 0xDB	; 219
    180a:	13 e0       	ldi	r17, 0x03	; 3
    180c:	c8 01       	movw	r24, r16
    180e:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1812:	88 ee       	ldi	r24, 0xE8	; 232
    1814:	93 e0       	ldi	r25, 0x03	; 3
    1816:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    181a:	81 ef       	ldi	r24, 0xF1	; 241
    181c:	93 e0       	ldi	r25, 0x03	; 3
    181e:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1822:	f0 92 e5 03 	sts	0x03E5, r15
    1826:	e0 92 e4 03 	sts	0x03E4, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    182a:	10 93 e7 03 	sts	0x03E7, r17
    182e:	00 93 e6 03 	sts	0x03E6, r16
    1832:	11 c0       	rjmp	.+34     	; 0x1856 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1834:	80 91 aa 03 	lds	r24, 0x03AA
    1838:	88 23       	and	r24, r24
    183a:	69 f4       	brne	.+26     	; 0x1856 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    183c:	e0 91 a0 03 	lds	r30, 0x03A0
    1840:	f0 91 a1 03 	lds	r31, 0x03A1
    1844:	86 89       	ldd	r24, Z+22	; 0x16
    1846:	58 16       	cp	r5, r24
    1848:	30 f0       	brcs	.+12     	; 0x1856 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
    184a:	8b 81       	ldd	r24, Y+3	; 0x03
    184c:	9c 81       	ldd	r25, Y+4	; 0x04
    184e:	90 93 a1 03 	sts	0x03A1, r25
    1852:	80 93 a0 03 	sts	0x03A0, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1856:	eb 81       	ldd	r30, Y+3	; 0x03
    1858:	fc 81       	ldd	r31, Y+4	; 0x04
    185a:	96 89       	ldd	r25, Z+22	; 0x16
    185c:	80 91 ad 03 	lds	r24, 0x03AD
    1860:	89 17       	cp	r24, r25
    1862:	10 f4       	brcc	.+4      	; 0x1868 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1864:	90 93 ad 03 	sts	0x03AD, r25
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1868:	80 91 ac 03 	lds	r24, 0x03AC
    186c:	8f 5f       	subi	r24, 0xFF	; 255
    186e:	80 93 ac 03 	sts	0x03AC, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1872:	eb 81       	ldd	r30, Y+3	; 0x03
    1874:	fc 81       	ldd	r31, Y+4	; 0x04
    1876:	96 89       	ldd	r25, Z+22	; 0x16
    1878:	80 91 a7 03 	lds	r24, 0x03A7
    187c:	89 17       	cp	r24, r25
    187e:	10 f4       	brcc	.+4      	; 0x1884 <xTaskGenericCreate+0x1e4>
    1880:	90 93 a7 03 	sts	0x03A7, r25
    1884:	eb 81       	ldd	r30, Y+3	; 0x03
    1886:	fc 81       	ldd	r31, Y+4	; 0x04
    1888:	86 89       	ldd	r24, Z+22	; 0x16
    188a:	29 e0       	ldi	r18, 0x09	; 9
    188c:	82 9f       	mul	r24, r18
    188e:	c0 01       	movw	r24, r0
    1890:	11 24       	eor	r1, r1
    1892:	82 55       	subi	r24, 0x52	; 82
    1894:	9c 4f       	sbci	r25, 0xFC	; 252
    1896:	b6 01       	movw	r22, r12
    1898:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    189c:	0f 90       	pop	r0
    189e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    18a0:	80 91 aa 03 	lds	r24, 0x03AA
    18a4:	88 23       	and	r24, r24
    18a6:	49 f0       	breq	.+18     	; 0x18ba <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    18a8:	e0 91 a0 03 	lds	r30, 0x03A0
    18ac:	f0 91 a1 03 	lds	r31, 0x03A1
    18b0:	86 89       	ldd	r24, Z+22	; 0x16
    18b2:	85 15       	cp	r24, r5
    18b4:	10 f4       	brcc	.+4      	; 0x18ba <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
    18b6:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <vPortYield>
    18ba:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    18bc:	0f 90       	pop	r0
    18be:	0f 90       	pop	r0
    18c0:	0f 90       	pop	r0
    18c2:	0f 90       	pop	r0
    18c4:	cf 91       	pop	r28
    18c6:	df 91       	pop	r29
    18c8:	1f 91       	pop	r17
    18ca:	0f 91       	pop	r16
    18cc:	ff 90       	pop	r15
    18ce:	ef 90       	pop	r14
    18d0:	df 90       	pop	r13
    18d2:	cf 90       	pop	r12
    18d4:	bf 90       	pop	r11
    18d6:	af 90       	pop	r10
    18d8:	9f 90       	pop	r9
    18da:	8f 90       	pop	r8
    18dc:	7f 90       	pop	r7
    18de:	6f 90       	pop	r6
    18e0:	5f 90       	pop	r5
    18e2:	3f 90       	pop	r3
    18e4:	2f 90       	pop	r2
    18e6:	08 95       	ret

000018e8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    18e8:	af 92       	push	r10
    18ea:	bf 92       	push	r11
    18ec:	cf 92       	push	r12
    18ee:	df 92       	push	r13
    18f0:	ef 92       	push	r14
    18f2:	ff 92       	push	r15
    18f4:	0f 93       	push	r16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    18f6:	80 e1       	ldi	r24, 0x10	; 16
    18f8:	9b e0       	ldi	r25, 0x0B	; 11
    18fa:	62 e9       	ldi	r22, 0x92	; 146
    18fc:	72 e0       	ldi	r23, 0x02	; 2
    18fe:	45 e5       	ldi	r20, 0x55	; 85
    1900:	50 e0       	ldi	r21, 0x00	; 0
    1902:	20 e0       	ldi	r18, 0x00	; 0
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	00 e0       	ldi	r16, 0x00	; 0
    1908:	ee 24       	eor	r14, r14
    190a:	ff 24       	eor	r15, r15
    190c:	cc 24       	eor	r12, r12
    190e:	dd 24       	eor	r13, r13
    1910:	aa 24       	eor	r10, r10
    1912:	bb 24       	eor	r11, r11
    1914:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskGenericCreate>

	if( xReturn == pdPASS )
    1918:	81 30       	cpi	r24, 0x01	; 1
    191a:	49 f4       	brne	.+18     	; 0x192e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    191c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    191e:	80 93 aa 03 	sts	0x03AA, r24
		xTickCount = ( portTickType ) 0;
    1922:	10 92 a5 03 	sts	0x03A5, r1
    1926:	10 92 a4 03 	sts	0x03A4, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    192a:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    192e:	0f 91       	pop	r16
    1930:	ff 90       	pop	r15
    1932:	ef 90       	pop	r14
    1934:	df 90       	pop	r13
    1936:	cf 90       	pop	r12
    1938:	bf 90       	pop	r11
    193a:	af 90       	pop	r10
    193c:	08 95       	ret

0000193e <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    193e:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1940:	91 e1       	ldi	r25, 0x11	; 17
    1942:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1944:	22 e2       	ldi	r18, 0x22	; 34
    1946:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1948:	83 e3       	ldi	r24, 0x33	; 51
    194a:	82 93       	st	-Z, r24
	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	

	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    194c:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    194e:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1950:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1952:	80 e8       	ldi	r24, 0x80	; 128
    1954:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1956:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1958:	82 e0       	ldi	r24, 0x02	; 2
    195a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    195c:	83 e0       	ldi	r24, 0x03	; 3
    195e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1960:	84 e0       	ldi	r24, 0x04	; 4
    1962:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1964:	85 e0       	ldi	r24, 0x05	; 5
    1966:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1968:	86 e0       	ldi	r24, 0x06	; 6
    196a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    196c:	87 e0       	ldi	r24, 0x07	; 7
    196e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1970:	88 e0       	ldi	r24, 0x08	; 8
    1972:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1974:	89 e0       	ldi	r24, 0x09	; 9
    1976:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1978:	80 e1       	ldi	r24, 0x10	; 16
    197a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    197c:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    197e:	82 e1       	ldi	r24, 0x12	; 18
    1980:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1982:	83 e1       	ldi	r24, 0x13	; 19
    1984:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1986:	84 e1       	ldi	r24, 0x14	; 20
    1988:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    198a:	85 e1       	ldi	r24, 0x15	; 21
    198c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    198e:	86 e1       	ldi	r24, 0x16	; 22
    1990:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1992:	87 e1       	ldi	r24, 0x17	; 23
    1994:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1996:	88 e1       	ldi	r24, 0x18	; 24
    1998:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    199a:	89 e1       	ldi	r24, 0x19	; 25
    199c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    199e:	80 e2       	ldi	r24, 0x20	; 32
    19a0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    19a2:	81 e2       	ldi	r24, 0x21	; 33
    19a4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    19a6:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    19a8:	83 e2       	ldi	r24, 0x23	; 35
    19aa:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */

	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    19ac:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    19ae:	52 93       	st	-Z, r21
	pxTopOfStack--;


	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    19b0:	86 e2       	ldi	r24, 0x26	; 38
    19b2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    19b4:	87 e2       	ldi	r24, 0x27	; 39
    19b6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    19b8:	88 e2       	ldi	r24, 0x28	; 40
    19ba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    19bc:	89 e2       	ldi	r24, 0x29	; 41
    19be:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    19c0:	80 e3       	ldi	r24, 0x30	; 48
    19c2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    19c4:	81 e3       	ldi	r24, 0x31	; 49
    19c6:	82 93       	st	-Z, r24
    19c8:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    19ca:	cf 01       	movw	r24, r30
    19cc:	08 95       	ret

000019ce <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    19ce:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
    19d2:	89 ef       	ldi	r24, 0xF9	; 249
    19d4:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    19d8:	8b e0       	ldi	r24, 0x0B	; 11
    19da:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    19de:	ef e6       	ldi	r30, 0x6F	; 111
    19e0:	f0 e0       	ldi	r31, 0x00	; 0
    19e2:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    19e4:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    19e6:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    19e8:	a0 91 a0 03 	lds	r26, 0x03A0
    19ec:	b0 91 a1 03 	lds	r27, 0x03A1
    19f0:	cd 91       	ld	r28, X+
    19f2:	cd bf       	out	0x3d, r28	; 61
    19f4:	dd 91       	ld	r29, X+
    19f6:	de bf       	out	0x3e, r29	; 62
    19f8:	ff 91       	pop	r31
    19fa:	ef 91       	pop	r30
    19fc:	df 91       	pop	r29
    19fe:	cf 91       	pop	r28
    1a00:	bf 91       	pop	r27
    1a02:	af 91       	pop	r26
    1a04:	9f 91       	pop	r25
    1a06:	8f 91       	pop	r24
    1a08:	7f 91       	pop	r23
    1a0a:	6f 91       	pop	r22
    1a0c:	5f 91       	pop	r21
    1a0e:	4f 91       	pop	r20
    1a10:	3f 91       	pop	r19
    1a12:	2f 91       	pop	r18
    1a14:	1f 91       	pop	r17
    1a16:	0f 91       	pop	r16
    1a18:	ff 90       	pop	r15
    1a1a:	ef 90       	pop	r14
    1a1c:	df 90       	pop	r13
    1a1e:	cf 90       	pop	r12
    1a20:	bf 90       	pop	r11
    1a22:	af 90       	pop	r10
    1a24:	9f 90       	pop	r9
    1a26:	8f 90       	pop	r8
    1a28:	7f 90       	pop	r7
    1a2a:	6f 90       	pop	r6
    1a2c:	5f 90       	pop	r5
    1a2e:	4f 90       	pop	r4
    1a30:	3f 90       	pop	r3
    1a32:	2f 90       	pop	r2
    1a34:	1f 90       	pop	r1
    1a36:	0f 90       	pop	r0
    1a38:	0f be       	out	0x3f, r0	; 63
    1a3a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a3c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	08 95       	ret

00001a42 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1a42:	08 95       	ret

00001a44 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a44:	0f 92       	push	r0
    1a46:	0f b6       	in	r0, 0x3f	; 63
    1a48:	f8 94       	cli
    1a4a:	0f 92       	push	r0
    1a4c:	1f 92       	push	r1
    1a4e:	11 24       	eor	r1, r1
    1a50:	2f 92       	push	r2
    1a52:	3f 92       	push	r3
    1a54:	4f 92       	push	r4
    1a56:	5f 92       	push	r5
    1a58:	6f 92       	push	r6
    1a5a:	7f 92       	push	r7
    1a5c:	8f 92       	push	r8
    1a5e:	9f 92       	push	r9
    1a60:	af 92       	push	r10
    1a62:	bf 92       	push	r11
    1a64:	cf 92       	push	r12
    1a66:	df 92       	push	r13
    1a68:	ef 92       	push	r14
    1a6a:	ff 92       	push	r15
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	2f 93       	push	r18
    1a72:	3f 93       	push	r19
    1a74:	4f 93       	push	r20
    1a76:	5f 93       	push	r21
    1a78:	6f 93       	push	r22
    1a7a:	7f 93       	push	r23
    1a7c:	8f 93       	push	r24
    1a7e:	9f 93       	push	r25
    1a80:	af 93       	push	r26
    1a82:	bf 93       	push	r27
    1a84:	cf 93       	push	r28
    1a86:	df 93       	push	r29
    1a88:	ef 93       	push	r30
    1a8a:	ff 93       	push	r31
    1a8c:	a0 91 a0 03 	lds	r26, 0x03A0
    1a90:	b0 91 a1 03 	lds	r27, 0x03A1
    1a94:	0d b6       	in	r0, 0x3d	; 61
    1a96:	0d 92       	st	X+, r0
    1a98:	0e b6       	in	r0, 0x3e	; 62
    1a9a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a9c:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1aa0:	0e 94 2d 08 	call	0x105a	; 0x105a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1aa4:	a0 91 a0 03 	lds	r26, 0x03A0
    1aa8:	b0 91 a1 03 	lds	r27, 0x03A1
    1aac:	cd 91       	ld	r28, X+
    1aae:	cd bf       	out	0x3d, r28	; 61
    1ab0:	dd 91       	ld	r29, X+
    1ab2:	de bf       	out	0x3e, r29	; 62
    1ab4:	ff 91       	pop	r31
    1ab6:	ef 91       	pop	r30
    1ab8:	df 91       	pop	r29
    1aba:	cf 91       	pop	r28
    1abc:	bf 91       	pop	r27
    1abe:	af 91       	pop	r26
    1ac0:	9f 91       	pop	r25
    1ac2:	8f 91       	pop	r24
    1ac4:	7f 91       	pop	r23
    1ac6:	6f 91       	pop	r22
    1ac8:	5f 91       	pop	r21
    1aca:	4f 91       	pop	r20
    1acc:	3f 91       	pop	r19
    1ace:	2f 91       	pop	r18
    1ad0:	1f 91       	pop	r17
    1ad2:	0f 91       	pop	r16
    1ad4:	ff 90       	pop	r15
    1ad6:	ef 90       	pop	r14
    1ad8:	df 90       	pop	r13
    1ada:	cf 90       	pop	r12
    1adc:	bf 90       	pop	r11
    1ade:	af 90       	pop	r10
    1ae0:	9f 90       	pop	r9
    1ae2:	8f 90       	pop	r8
    1ae4:	7f 90       	pop	r7
    1ae6:	6f 90       	pop	r6
    1ae8:	5f 90       	pop	r5
    1aea:	4f 90       	pop	r4
    1aec:	3f 90       	pop	r3
    1aee:	2f 90       	pop	r2
    1af0:	1f 90       	pop	r1
    1af2:	0f 90       	pop	r0
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1af8:	08 95       	ret

00001afa <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1afa:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1afe:	18 95       	reti

00001b00 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b00:	0f 92       	push	r0
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	0f 92       	push	r0
    1b08:	1f 92       	push	r1
    1b0a:	11 24       	eor	r1, r1
    1b0c:	2f 92       	push	r2
    1b0e:	3f 92       	push	r3
    1b10:	4f 92       	push	r4
    1b12:	5f 92       	push	r5
    1b14:	6f 92       	push	r6
    1b16:	7f 92       	push	r7
    1b18:	8f 92       	push	r8
    1b1a:	9f 92       	push	r9
    1b1c:	af 92       	push	r10
    1b1e:	bf 92       	push	r11
    1b20:	cf 92       	push	r12
    1b22:	df 92       	push	r13
    1b24:	ef 92       	push	r14
    1b26:	ff 92       	push	r15
    1b28:	0f 93       	push	r16
    1b2a:	1f 93       	push	r17
    1b2c:	2f 93       	push	r18
    1b2e:	3f 93       	push	r19
    1b30:	4f 93       	push	r20
    1b32:	5f 93       	push	r21
    1b34:	6f 93       	push	r22
    1b36:	7f 93       	push	r23
    1b38:	8f 93       	push	r24
    1b3a:	9f 93       	push	r25
    1b3c:	af 93       	push	r26
    1b3e:	bf 93       	push	r27
    1b40:	cf 93       	push	r28
    1b42:	df 93       	push	r29
    1b44:	ef 93       	push	r30
    1b46:	ff 93       	push	r31
    1b48:	a0 91 a0 03 	lds	r26, 0x03A0
    1b4c:	b0 91 a1 03 	lds	r27, 0x03A1
    1b50:	0d b6       	in	r0, 0x3d	; 61
    1b52:	0d 92       	st	X+, r0
    1b54:	0e b6       	in	r0, 0x3e	; 62
    1b56:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b58:	0e 94 2d 08 	call	0x105a	; 0x105a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b5c:	a0 91 a0 03 	lds	r26, 0x03A0
    1b60:	b0 91 a1 03 	lds	r27, 0x03A1
    1b64:	cd 91       	ld	r28, X+
    1b66:	cd bf       	out	0x3d, r28	; 61
    1b68:	dd 91       	ld	r29, X+
    1b6a:	de bf       	out	0x3e, r29	; 62
    1b6c:	ff 91       	pop	r31
    1b6e:	ef 91       	pop	r30
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	bf 91       	pop	r27
    1b76:	af 91       	pop	r26
    1b78:	9f 91       	pop	r25
    1b7a:	8f 91       	pop	r24
    1b7c:	7f 91       	pop	r23
    1b7e:	6f 91       	pop	r22
    1b80:	5f 91       	pop	r21
    1b82:	4f 91       	pop	r20
    1b84:	3f 91       	pop	r19
    1b86:	2f 91       	pop	r18
    1b88:	1f 91       	pop	r17
    1b8a:	0f 91       	pop	r16
    1b8c:	ff 90       	pop	r15
    1b8e:	ef 90       	pop	r14
    1b90:	df 90       	pop	r13
    1b92:	cf 90       	pop	r12
    1b94:	bf 90       	pop	r11
    1b96:	af 90       	pop	r10
    1b98:	9f 90       	pop	r9
    1b9a:	8f 90       	pop	r8
    1b9c:	7f 90       	pop	r7
    1b9e:	6f 90       	pop	r6
    1ba0:	5f 90       	pop	r5
    1ba2:	4f 90       	pop	r4
    1ba4:	3f 90       	pop	r3
    1ba6:	2f 90       	pop	r2
    1ba8:	1f 90       	pop	r1
    1baa:	0f 90       	pop	r0
    1bac:	0f be       	out	0x3f, r0	; 63
    1bae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1bb0:	08 95       	ret

00001bb2 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1bb2:	0f 93       	push	r16
    1bb4:	1f 93       	push	r17
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	fc 01       	movw	r30, r24
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1bbc:	80 81       	ld	r24, Z
    1bbe:	88 23       	and	r24, r24
    1bc0:	19 f4       	brne	.+6      	; 0x1bc8 <xCoRoutineRemoveFromEventList+0x16>
    1bc2:	c0 e0       	ldi	r28, 0x00	; 0
    1bc4:	d0 e0       	ldi	r29, 0x00	; 0
    1bc6:	05 c0       	rjmp	.+10     	; 0x1bd2 <xCoRoutineRemoveFromEventList+0x20>
    1bc8:	05 80       	ldd	r0, Z+5	; 0x05
    1bca:	f6 81       	ldd	r31, Z+6	; 0x06
    1bcc:	e0 2d       	mov	r30, r0
    1bce:	c6 81       	ldd	r28, Z+6	; 0x06
    1bd0:	d7 81       	ldd	r29, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1bd2:	8e 01       	movw	r16, r28
    1bd4:	04 5f       	subi	r16, 0xF4	; 244
    1bd6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1bde:	8b e2       	ldi	r24, 0x2B	; 43
    1be0:	94 e0       	ldi	r25, 0x04	; 4
    1be2:	b8 01       	movw	r22, r16
    1be4:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	e0 91 fa 03 	lds	r30, 0x03FA
    1bee:	f0 91 fb 03 	lds	r31, 0x03FB
    1bf2:	9e 89       	ldd	r25, Y+22	; 0x16
    1bf4:	86 89       	ldd	r24, Z+22	; 0x16
    1bf6:	98 17       	cp	r25, r24
    1bf8:	08 f0       	brcs	.+2      	; 0x1bfc <xCoRoutineRemoveFromEventList+0x4a>
    1bfa:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1bfc:	82 2f       	mov	r24, r18
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	08 95       	ret

00001c08 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1c08:	ff 92       	push	r15
    1c0a:	0f 93       	push	r16
    1c0c:	1f 93       	push	r17
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1c12:	99 e0       	ldi	r25, 0x09	; 9
    1c14:	f9 2e       	mov	r15, r25
    1c16:	28 c0       	rjmp	.+80     	; 0x1c68 <vCoRoutineSchedule+0x60>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1c18:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1c1a:	80 91 2b 04 	lds	r24, 0x042B
    1c1e:	88 23       	and	r24, r24
    1c20:	19 f4       	brne	.+6      	; 0x1c28 <vCoRoutineSchedule+0x20>
    1c22:	c0 e0       	ldi	r28, 0x00	; 0
    1c24:	d0 e0       	ldi	r29, 0x00	; 0
    1c26:	06 c0       	rjmp	.+12     	; 0x1c34 <vCoRoutineSchedule+0x2c>
    1c28:	e0 91 30 04 	lds	r30, 0x0430
    1c2c:	f0 91 31 04 	lds	r31, 0x0431
    1c30:	c6 81       	ldd	r28, Z+6	; 0x06
    1c32:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1c34:	ce 01       	movw	r24, r28
    1c36:	0c 96       	adiw	r24, 0x0c	; 12
    1c38:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1c3c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1c3e:	8e 01       	movw	r16, r28
    1c40:	0e 5f       	subi	r16, 0xFE	; 254
    1c42:	1f 4f       	sbci	r17, 0xFF	; 255
    1c44:	c8 01       	movw	r24, r16
    1c46:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1c4a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c4c:	80 91 fc 03 	lds	r24, 0x03FC
    1c50:	89 17       	cp	r24, r25
    1c52:	10 f4       	brcc	.+4      	; 0x1c58 <vCoRoutineSchedule+0x50>
    1c54:	90 93 fc 03 	sts	0x03FC, r25
    1c58:	9f 9d       	mul	r25, r15
    1c5a:	c0 01       	movw	r24, r0
    1c5c:	11 24       	eor	r1, r1
    1c5e:	8d 5f       	subi	r24, 0xFD	; 253
    1c60:	9b 4f       	sbci	r25, 0xFB	; 251
    1c62:	b8 01       	movw	r22, r16
    1c64:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
    1c68:	80 91 2b 04 	lds	r24, 0x042B
    1c6c:	88 23       	and	r24, r24
    1c6e:	a1 f6       	brne	.-88     	; 0x1c18 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1c70:	0e 94 19 08 	call	0x1032	; 0x1032 <xTaskGetTickCount>
    1c74:	20 91 fd 03 	lds	r18, 0x03FD
    1c78:	30 91 fe 03 	lds	r19, 0x03FE
    1c7c:	82 1b       	sub	r24, r18
    1c7e:	93 0b       	sbc	r25, r19
    1c80:	90 93 00 04 	sts	0x0400, r25
    1c84:	80 93 ff 03 	sts	0x03FF, r24
					vListRemove( &( pxCRCB->xEventListItem ) );											
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1c88:	89 e0       	ldi	r24, 0x09	; 9
    1c8a:	f8 2e       	mov	r15, r24
    1c8c:	54 c0       	rjmp	.+168    	; 0x1d36 <vCoRoutineSchedule+0x12e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1c8e:	01 96       	adiw	r24, 0x01	; 1
    1c90:	90 93 02 04 	sts	0x0402, r25
    1c94:	80 93 01 04 	sts	0x0401, r24
		xPassedTicks--;
    1c98:	21 50       	subi	r18, 0x01	; 1
    1c9a:	30 40       	sbci	r19, 0x00	; 0
    1c9c:	30 93 00 04 	sts	0x0400, r19
    1ca0:	20 93 ff 03 	sts	0x03FF, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1ca4:	89 2b       	or	r24, r25
    1ca6:	c9 f5       	brne	.+114    	; 0x1d1a <vCoRoutineSchedule+0x112>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1ca8:	20 91 27 04 	lds	r18, 0x0427
    1cac:	30 91 28 04 	lds	r19, 0x0428
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1cb0:	80 91 29 04 	lds	r24, 0x0429
    1cb4:	90 91 2a 04 	lds	r25, 0x042A
    1cb8:	90 93 28 04 	sts	0x0428, r25
    1cbc:	80 93 27 04 	sts	0x0427, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1cc0:	30 93 2a 04 	sts	0x042A, r19
    1cc4:	20 93 29 04 	sts	0x0429, r18
    1cc8:	28 c0       	rjmp	.+80     	; 0x1d1a <vCoRoutineSchedule+0x112>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1cca:	20 91 01 04 	lds	r18, 0x0401
    1cce:	30 91 02 04 	lds	r19, 0x0402
    1cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    1cd6:	28 17       	cp	r18, r24
    1cd8:	39 07       	cpc	r19, r25
    1cda:	68 f1       	brcs	.+90     	; 0x1d36 <vCoRoutineSchedule+0x12e>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1cdc:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1cde:	8e 01       	movw	r16, r28
    1ce0:	0e 5f       	subi	r16, 0xFE	; 254
    1ce2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce4:	c8 01       	movw	r24, r16
    1ce6:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1cea:	8c 89       	ldd	r24, Y+20	; 0x14
    1cec:	9d 89       	ldd	r25, Y+21	; 0x15
    1cee:	89 2b       	or	r24, r25
    1cf0:	21 f0       	breq	.+8      	; 0x1cfa <vCoRoutineSchedule+0xf2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1cf2:	ce 01       	movw	r24, r28
    1cf4:	0c 96       	adiw	r24, 0x0c	; 12
    1cf6:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1cfa:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1cfc:	9e 89       	ldd	r25, Y+22	; 0x16
    1cfe:	80 91 fc 03 	lds	r24, 0x03FC
    1d02:	89 17       	cp	r24, r25
    1d04:	10 f4       	brcc	.+4      	; 0x1d0a <vCoRoutineSchedule+0x102>
    1d06:	90 93 fc 03 	sts	0x03FC, r25
    1d0a:	9f 9d       	mul	r25, r15
    1d0c:	c0 01       	movw	r24, r0
    1d0e:	11 24       	eor	r1, r1
    1d10:	8d 5f       	subi	r24, 0xFD	; 253
    1d12:	9b 4f       	sbci	r25, 0xFB	; 251
    1d14:	b8 01       	movw	r22, r16
    1d16:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
    1d1a:	e0 91 27 04 	lds	r30, 0x0427
    1d1e:	f0 91 28 04 	lds	r31, 0x0428
    1d22:	80 81       	ld	r24, Z
    1d24:	88 23       	and	r24, r24
    1d26:	39 f0       	breq	.+14     	; 0x1d36 <vCoRoutineSchedule+0x12e>
    1d28:	05 80       	ldd	r0, Z+5	; 0x05
    1d2a:	f6 81       	ldd	r31, Z+6	; 0x06
    1d2c:	e0 2d       	mov	r30, r0
    1d2e:	c6 81       	ldd	r28, Z+6	; 0x06
    1d30:	d7 81       	ldd	r29, Z+7	; 0x07
    1d32:	20 97       	sbiw	r28, 0x00	; 0
    1d34:	51 f6       	brne	.-108    	; 0x1cca <vCoRoutineSchedule+0xc2>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1d36:	20 91 ff 03 	lds	r18, 0x03FF
    1d3a:	30 91 00 04 	lds	r19, 0x0400
    1d3e:	80 91 01 04 	lds	r24, 0x0401
    1d42:	90 91 02 04 	lds	r25, 0x0402
    1d46:	21 15       	cp	r18, r1
    1d48:	31 05       	cpc	r19, r1
    1d4a:	09 f0       	breq	.+2      	; 0x1d4e <vCoRoutineSchedule+0x146>
    1d4c:	a0 cf       	rjmp	.-192    	; 0x1c8e <vCoRoutineSchedule+0x86>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1d4e:	90 93 fe 03 	sts	0x03FE, r25
    1d52:	80 93 fd 03 	sts	0x03FD, r24
    1d56:	90 91 fc 03 	lds	r25, 0x03FC

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1d5a:	29 e0       	ldi	r18, 0x09	; 9
    1d5c:	06 c0       	rjmp	.+12     	; 0x1d6a <vCoRoutineSchedule+0x162>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1d5e:	99 23       	and	r25, r25
    1d60:	19 f4       	brne	.+6      	; 0x1d68 <vCoRoutineSchedule+0x160>
    1d62:	10 92 fc 03 	sts	0x03FC, r1
    1d66:	32 c0       	rjmp	.+100    	; 0x1dcc <vCoRoutineSchedule+0x1c4>
    1d68:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1d6a:	92 9f       	mul	r25, r18
    1d6c:	d0 01       	movw	r26, r0
    1d6e:	11 24       	eor	r1, r1
    1d70:	ad 5f       	subi	r26, 0xFD	; 253
    1d72:	bb 4f       	sbci	r27, 0xFB	; 251
    1d74:	8c 91       	ld	r24, X
    1d76:	88 23       	and	r24, r24
    1d78:	91 f3       	breq	.-28     	; 0x1d5e <vCoRoutineSchedule+0x156>
    1d7a:	90 93 fc 03 	sts	0x03FC, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1d7e:	11 96       	adiw	r26, 0x01	; 1
    1d80:	ed 91       	ld	r30, X+
    1d82:	fc 91       	ld	r31, X
    1d84:	12 97       	sbiw	r26, 0x02	; 2
    1d86:	02 80       	ldd	r0, Z+2	; 0x02
    1d88:	f3 81       	ldd	r31, Z+3	; 0x03
    1d8a:	e0 2d       	mov	r30, r0
    1d8c:	12 96       	adiw	r26, 0x02	; 2
    1d8e:	fc 93       	st	X, r31
    1d90:	ee 93       	st	-X, r30
    1d92:	11 97       	sbiw	r26, 0x01	; 1
    1d94:	cd 01       	movw	r24, r26
    1d96:	03 96       	adiw	r24, 0x03	; 3
    1d98:	e8 17       	cp	r30, r24
    1d9a:	f9 07       	cpc	r31, r25
    1d9c:	31 f4       	brne	.+12     	; 0x1daa <vCoRoutineSchedule+0x1a2>
    1d9e:	82 81       	ldd	r24, Z+2	; 0x02
    1da0:	93 81       	ldd	r25, Z+3	; 0x03
    1da2:	12 96       	adiw	r26, 0x02	; 2
    1da4:	9c 93       	st	X, r25
    1da6:	8e 93       	st	-X, r24
    1da8:	11 97       	sbiw	r26, 0x01	; 1
    1daa:	11 96       	adiw	r26, 0x01	; 1
    1dac:	ed 91       	ld	r30, X+
    1dae:	fc 91       	ld	r31, X
    1db0:	12 97       	sbiw	r26, 0x02	; 2
    1db2:	06 80       	ldd	r0, Z+6	; 0x06
    1db4:	f7 81       	ldd	r31, Z+7	; 0x07
    1db6:	e0 2d       	mov	r30, r0
    1db8:	f0 93 fb 03 	sts	0x03FB, r31
    1dbc:	e0 93 fa 03 	sts	0x03FA, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1dc0:	20 81       	ld	r18, Z
    1dc2:	31 81       	ldd	r19, Z+1	; 0x01
    1dc4:	cf 01       	movw	r24, r30
    1dc6:	67 89       	ldd	r22, Z+23	; 0x17
    1dc8:	f9 01       	movw	r30, r18
    1dca:	09 95       	icall

	return;
}
    1dcc:	df 91       	pop	r29
    1dce:	cf 91       	pop	r28
    1dd0:	1f 91       	pop	r17
    1dd2:	0f 91       	pop	r16
    1dd4:	ff 90       	pop	r15
    1dd6:	08 95       	ret

00001dd8 <vCoRoutineAddToDelayedList>:
	return xReturn;	
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1dd8:	0f 93       	push	r16
    1dda:	1f 93       	push	r17
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    1de0:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1de2:	00 91 01 04 	lds	r16, 0x0401
    1de6:	10 91 02 04 	lds	r17, 0x0402
    1dea:	08 0f       	add	r16, r24
    1dec:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1dee:	80 91 fa 03 	lds	r24, 0x03FA
    1df2:	90 91 fb 03 	lds	r25, 0x03FB
    1df6:	02 96       	adiw	r24, 0x02	; 2
    1df8:	0e 94 06 05 	call	0xa0c	; 0xa0c <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1dfc:	e0 91 fa 03 	lds	r30, 0x03FA
    1e00:	f0 91 fb 03 	lds	r31, 0x03FB
    1e04:	13 83       	std	Z+3, r17	; 0x03
    1e06:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1e08:	80 91 01 04 	lds	r24, 0x0401
    1e0c:	90 91 02 04 	lds	r25, 0x0402
    1e10:	bf 01       	movw	r22, r30
    1e12:	6e 5f       	subi	r22, 0xFE	; 254
    1e14:	7f 4f       	sbci	r23, 0xFF	; 255
    1e16:	08 17       	cp	r16, r24
    1e18:	19 07       	cpc	r17, r25
    1e1a:	28 f4       	brcc	.+10     	; 0x1e26 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e1c:	80 91 29 04 	lds	r24, 0x0429
    1e20:	90 91 2a 04 	lds	r25, 0x042A
    1e24:	04 c0       	rjmp	.+8      	; 0x1e2e <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1e26:	80 91 27 04 	lds	r24, 0x0427
    1e2a:	90 91 28 04 	lds	r25, 0x0428
    1e2e:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>
	}

	if( pxEventList )
    1e32:	20 97       	sbiw	r28, 0x00	; 0
    1e34:	49 f0       	breq	.+18     	; 0x1e48 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1e36:	60 91 fa 03 	lds	r22, 0x03FA
    1e3a:	70 91 fb 03 	lds	r23, 0x03FB
    1e3e:	64 5f       	subi	r22, 0xF4	; 244
    1e40:	7f 4f       	sbci	r23, 0xFF	; 255
    1e42:	ce 01       	movw	r24, r28
    1e44:	0e 94 d1 04 	call	0x9a2	; 0x9a2 <vListInsert>
	}
}
    1e48:	df 91       	pop	r29
    1e4a:	cf 91       	pop	r28
    1e4c:	1f 91       	pop	r17
    1e4e:	0f 91       	pop	r16
    1e50:	08 95       	ret

00001e52 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1e52:	af 92       	push	r10
    1e54:	bf 92       	push	r11
    1e56:	cf 92       	push	r12
    1e58:	df 92       	push	r13
    1e5a:	ef 92       	push	r14
    1e5c:	ff 92       	push	r15
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	6c 01       	movw	r12, r24
    1e68:	b6 2e       	mov	r11, r22
    1e6a:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1e6c:	8a e1       	ldi	r24, 0x1A	; 26
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
    1e70:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <pvPortMalloc>
    1e74:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	11 f4       	brne	.+4      	; 0x1e7e <xCoRoutineCreate+0x2c>
    1e7a:	8f ef       	ldi	r24, 0xFF	; 255
    1e7c:	59 c0       	rjmp	.+178    	; 0x1f30 <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1e7e:	80 91 fa 03 	lds	r24, 0x03FA
    1e82:	90 91 fb 03 	lds	r25, 0x03FB
    1e86:	89 2b       	or	r24, r25
    1e88:	21 f5       	brne	.+72     	; 0x1ed2 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1e8a:	d0 93 fb 03 	sts	0x03FB, r29
    1e8e:	c0 93 fa 03 	sts	0x03FA, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1e92:	83 e0       	ldi	r24, 0x03	; 3
    1e94:	94 e0       	ldi	r25, 0x04	; 4
    1e96:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
    1e9a:	8c e0       	ldi	r24, 0x0C	; 12
    1e9c:	94 e0       	ldi	r25, 0x04	; 4
    1e9e:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1ea2:	25 e1       	ldi	r18, 0x15	; 21
    1ea4:	e2 2e       	mov	r14, r18
    1ea6:	24 e0       	ldi	r18, 0x04	; 4
    1ea8:	f2 2e       	mov	r15, r18
    1eaa:	c7 01       	movw	r24, r14
    1eac:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1eb0:	0e e1       	ldi	r16, 0x1E	; 30
    1eb2:	14 e0       	ldi	r17, 0x04	; 4
    1eb4:	c8 01       	movw	r24, r16
    1eb6:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1eba:	8b e2       	ldi	r24, 0x2B	; 43
    1ebc:	94 e0       	ldi	r25, 0x04	; 4
    1ebe:	0e 94 94 04 	call	0x928	; 0x928 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1ec2:	f0 92 28 04 	sts	0x0428, r15
    1ec6:	e0 92 27 04 	sts	0x0427, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1eca:	10 93 2a 04 	sts	0x042A, r17
    1ece:	00 93 29 04 	sts	0x0429, r16
    1ed2:	eb 2c       	mov	r14, r11
    1ed4:	bb 20       	and	r11, r11
    1ed6:	11 f0       	breq	.+4      	; 0x1edc <xCoRoutineCreate+0x8a>
    1ed8:	ee 24       	eor	r14, r14
    1eda:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1edc:	19 8e       	std	Y+25, r1	; 0x19
    1ede:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1ee0:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1ee2:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1ee4:	fe 01       	movw	r30, r28
    1ee6:	c1 92       	st	Z+, r12
    1ee8:	d1 92       	st	Z+, r13
    1eea:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1eec:	cf 01       	movw	r24, r30
    1eee:	0e 94 a4 04 	call	0x948	; 0x948 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1ef2:	ce 01       	movw	r24, r28
    1ef4:	0c 96       	adiw	r24, 0x0c	; 12
    1ef6:	0e 94 a4 04 	call	0x948	; 0x948 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1efa:	d9 87       	std	Y+9, r29	; 0x09
    1efc:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1efe:	db 8b       	std	Y+19, r29	; 0x13
    1f00:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1f02:	84 e0       	ldi	r24, 0x04	; 4
    1f04:	90 e0       	ldi	r25, 0x00	; 0
    1f06:	8e 19       	sub	r24, r14
    1f08:	91 09       	sbc	r25, r1
    1f0a:	9d 87       	std	Y+13, r25	; 0x0d
    1f0c:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1f0e:	9e 89       	ldd	r25, Y+22	; 0x16
    1f10:	80 91 fc 03 	lds	r24, 0x03FC
    1f14:	89 17       	cp	r24, r25
    1f16:	10 f4       	brcc	.+4      	; 0x1f1c <xCoRoutineCreate+0xca>
    1f18:	90 93 fc 03 	sts	0x03FC, r25
    1f1c:	89 e0       	ldi	r24, 0x09	; 9
    1f1e:	98 9f       	mul	r25, r24
    1f20:	c0 01       	movw	r24, r0
    1f22:	11 24       	eor	r1, r1
    1f24:	8d 5f       	subi	r24, 0xFD	; 253
    1f26:	9b 4f       	sbci	r25, 0xFB	; 251
    1f28:	b8 01       	movw	r22, r16
    1f2a:	0e 94 a8 04 	call	0x950	; 0x950 <vListInsertEnd>
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}
	
	return xReturn;	
}
    1f30:	df 91       	pop	r29
    1f32:	cf 91       	pop	r28
    1f34:	1f 91       	pop	r17
    1f36:	0f 91       	pop	r16
    1f38:	ff 90       	pop	r15
    1f3a:	ef 90       	pop	r14
    1f3c:	df 90       	pop	r13
    1f3e:	cf 90       	pop	r12
    1f40:	bf 90       	pop	r11
    1f42:	af 90       	pop	r10
    1f44:	08 95       	ret

00001f46 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1f46:	08 95       	ret

00001f48 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1f48:	10 92 35 04 	sts	0x0435, r1
    1f4c:	10 92 34 04 	sts	0x0434, r1
}
    1f50:	08 95       	ret

00001f52 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1f52:	2c ed       	ldi	r18, 0xDC	; 220
    1f54:	35 e0       	ldi	r19, 0x05	; 5
    1f56:	80 91 34 04 	lds	r24, 0x0434
    1f5a:	90 91 35 04 	lds	r25, 0x0435
    1f5e:	28 1b       	sub	r18, r24
    1f60:	39 0b       	sbc	r19, r25
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
}
    1f62:	c9 01       	movw	r24, r18
    1f64:	08 95       	ret

00001f66 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1f66:	0f 93       	push	r16
    1f68:	1f 93       	push	r17
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
    1f6e:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1f70:	0e 94 13 08 	call	0x1026	; 0x1026 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1f74:	80 91 34 04 	lds	r24, 0x0434
    1f78:	90 91 35 04 	lds	r25, 0x0435
    1f7c:	98 01       	movw	r18, r16
    1f7e:	28 0f       	add	r18, r24
    1f80:	39 1f       	adc	r19, r25
    1f82:	45 e0       	ldi	r20, 0x05	; 5
    1f84:	2c 3d       	cpi	r18, 0xDC	; 220
    1f86:	34 07       	cpc	r19, r20
    1f88:	58 f4       	brcc	.+22     	; 0x1fa0 <pvPortMalloc+0x3a>
    1f8a:	82 17       	cp	r24, r18
    1f8c:	93 07       	cpc	r25, r19
    1f8e:	40 f4       	brcc	.+16     	; 0x1fa0 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1f90:	ec 01       	movw	r28, r24
    1f92:	ca 5c       	subi	r28, 0xCA	; 202
    1f94:	db 4f       	sbci	r29, 0xFB	; 251
			xNextFreeByte += xWantedSize;			
    1f96:	30 93 35 04 	sts	0x0435, r19
    1f9a:	20 93 34 04 	sts	0x0434, r18
    1f9e:	02 c0       	rjmp	.+4      	; 0x1fa4 <pvPortMalloc+0x3e>
    1fa0:	c0 e0       	ldi	r28, 0x00	; 0
    1fa2:	d0 e0       	ldi	r29, 0x00	; 0
		}	
	}
	xTaskResumeAll();
    1fa4:	0e 94 aa 09 	call	0x1354	; 0x1354 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1fa8:	ce 01       	movw	r24, r28
    1faa:	df 91       	pop	r29
    1fac:	cf 91       	pop	r28
    1fae:	1f 91       	pop	r17
    1fb0:	0f 91       	pop	r16
    1fb2:	08 95       	ret

00001fb4 <prescaler_hex_to_value>:
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    1fb4:	e8 2f       	mov	r30, r24
    1fb6:	f0 e0       	ldi	r31, 0x00	; 0
    1fb8:	e7 70       	andi	r30, 0x07	; 7
    1fba:	f0 70       	andi	r31, 0x00	; 0
    1fbc:	ee 0f       	add	r30, r30
    1fbe:	ff 1f       	adc	r31, r31
    1fc0:	ef 5f       	subi	r30, 0xFF	; 255
    1fc2:	fe 4f       	sbci	r31, 0xFE	; 254
    1fc4:	25 91       	lpm	r18, Z+
    1fc6:	34 91       	lpm	r19, Z+
}
    1fc8:	c9 01       	movw	r24, r18
    1fca:	08 95       	ret

00001fcc <prescaler_hex_to_value_for_timer2>:
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    1fcc:	e8 2f       	mov	r30, r24
    1fce:	f0 e0       	ldi	r31, 0x00	; 0
    1fd0:	e7 70       	andi	r30, 0x07	; 7
    1fd2:	f0 70       	andi	r31, 0x00	; 0
    1fd4:	ee 0f       	add	r30, r30
    1fd6:	ff 1f       	adc	r31, r31
    1fd8:	e3 5f       	subi	r30, 0xF3	; 243
    1fda:	fe 4f       	sbci	r31, 0xFE	; 254
    1fdc:	25 91       	lpm	r18, Z+
    1fde:	34 91       	lpm	r19, Z+
}
    1fe0:	c9 01       	movw	r24, r18
    1fe2:	08 95       	ret

00001fe4 <get_timer0_prescaler>:

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
    1fe4:	85 b5       	in	r24, 0x25	; 37
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    1fe6:	e8 2f       	mov	r30, r24
    1fe8:	f0 e0       	ldi	r31, 0x00	; 0
    1fea:	e7 70       	andi	r30, 0x07	; 7
    1fec:	f0 70       	andi	r31, 0x00	; 0
    1fee:	ee 0f       	add	r30, r30
    1ff0:	ff 1f       	adc	r31, r31
    1ff2:	ef 5f       	subi	r30, 0xFF	; 255
    1ff4:	fe 4f       	sbci	r31, 0xFE	; 254
    1ff6:	25 91       	lpm	r18, Z+
    1ff8:	34 91       	lpm	r19, Z+
}

uint16_t get_timer0_prescaler(void)
{
  return prescaler_hex_to_value(TCCR0B);
}
    1ffa:	c9 01       	movw	r24, r18
    1ffc:	08 95       	ret

00001ffe <get_timer1_prescaler>:
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
    1ffe:	80 91 81 00 	lds	r24, 0x0081
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2002:	e8 2f       	mov	r30, r24
    2004:	f0 e0       	ldi	r31, 0x00	; 0
    2006:	e7 70       	andi	r30, 0x07	; 7
    2008:	f0 70       	andi	r31, 0x00	; 0
    200a:	ee 0f       	add	r30, r30
    200c:	ff 1f       	adc	r31, r31
    200e:	ef 5f       	subi	r30, 0xFF	; 255
    2010:	fe 4f       	sbci	r31, 0xFE	; 254
    2012:	25 91       	lpm	r18, Z+
    2014:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR0B);
}
uint16_t get_timer1_prescaler(void)
{
  return prescaler_hex_to_value(TCCR1B);
}
    2016:	c9 01       	movw	r24, r18
    2018:	08 95       	ret

0000201a <get_timer2_prescaler>:
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
    201a:	80 91 b1 00 	lds	r24, 0x00B1
uint16_t prescaler_hex_to_value_for_timer2(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to Timer2PrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(Timer2PrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    201e:	e8 2f       	mov	r30, r24
    2020:	f0 e0       	ldi	r31, 0x00	; 0
    2022:	e7 70       	andi	r30, 0x07	; 7
    2024:	f0 70       	andi	r31, 0x00	; 0
    2026:	ee 0f       	add	r30, r30
    2028:	ff 1f       	adc	r31, r31
    202a:	e3 5f       	subi	r30, 0xF3	; 243
    202c:	fe 4f       	sbci	r31, 0xFE	; 254
    202e:	25 91       	lpm	r18, Z+
    2030:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR1B);
}
uint16_t get_timer2_prescaler(void)
{
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
    2032:	c9 01       	movw	r24, r18
    2034:	08 95       	ret

00002036 <get_timer3_prescaler>:
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
    2036:	80 91 91 00 	lds	r24, 0x0091
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    203a:	e8 2f       	mov	r30, r24
    203c:	f0 e0       	ldi	r31, 0x00	; 0
    203e:	e7 70       	andi	r30, 0x07	; 7
    2040:	f0 70       	andi	r31, 0x00	; 0
    2042:	ee 0f       	add	r30, r30
    2044:	ff 1f       	adc	r31, r31
    2046:	ef 5f       	subi	r30, 0xFF	; 255
    2048:	fe 4f       	sbci	r31, 0xFE	; 254
    204a:	25 91       	lpm	r18, Z+
    204c:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value_for_timer2(TCCR2B);
}
uint16_t get_timer3_prescaler(void)
{
  return prescaler_hex_to_value(TCCR3B);
}
    204e:	c9 01       	movw	r24, r18
    2050:	08 95       	ret

00002052 <get_timer4_prescaler>:
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
    2052:	80 91 a1 00 	lds	r24, 0x00A1
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2056:	e8 2f       	mov	r30, r24
    2058:	f0 e0       	ldi	r31, 0x00	; 0
    205a:	e7 70       	andi	r30, 0x07	; 7
    205c:	f0 70       	andi	r31, 0x00	; 0
    205e:	ee 0f       	add	r30, r30
    2060:	ff 1f       	adc	r31, r31
    2062:	ef 5f       	subi	r30, 0xFF	; 255
    2064:	fe 4f       	sbci	r31, 0xFE	; 254
    2066:	25 91       	lpm	r18, Z+
    2068:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR3B);
}
uint16_t get_timer4_prescaler(void)
{
  return prescaler_hex_to_value(TCCR4B);
}
    206a:	c9 01       	movw	r24, r18
    206c:	08 95       	ret

0000206e <get_timer5_prescaler>:
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
    206e:	80 91 21 01 	lds	r24, 0x0121
uint16_t prescaler_hex_to_value(uint8_t hex)
{
  // basically pgm_read_word will return a pointer to TimerPrescaleFactor in program space
  // and it will move the array to the correct position, then typecast it back
  // to uint16_t
  return (uint16_t)(pgm_read_word(TimerPrescaleFactor+(hex & TIMER_PRESCALE_MASK)));
    2072:	e8 2f       	mov	r30, r24
    2074:	f0 e0       	ldi	r31, 0x00	; 0
    2076:	e7 70       	andi	r30, 0x07	; 7
    2078:	f0 70       	andi	r31, 0x00	; 0
    207a:	ee 0f       	add	r30, r30
    207c:	ff 1f       	adc	r31, r31
    207e:	ef 5f       	subi	r30, 0xFF	; 255
    2080:	fe 4f       	sbci	r31, 0xFE	; 254
    2082:	25 91       	lpm	r18, Z+
    2084:	34 91       	lpm	r19, Z+
  return prescaler_hex_to_value(TCCR4B);
}
uint16_t get_timer5_prescaler(void)
{
  return prescaler_hex_to_value(TCCR5B);
}
    2086:	c9 01       	movw	r24, r18
    2088:	08 95       	ret

0000208a <get_timer0_overflow>:

const uint32_t get_timer0_overflow(void)
{
    return timer0_ovrflow_cnt;
    208a:	20 91 98 0c 	lds	r18, 0x0C98
    208e:	30 91 99 0c 	lds	r19, 0x0C99
    2092:	40 91 9a 0c 	lds	r20, 0x0C9A
    2096:	50 91 9b 0c 	lds	r21, 0x0C9B
}
    209a:	b9 01       	movw	r22, r18
    209c:	ca 01       	movw	r24, r20
    209e:	08 95       	ret

000020a0 <get_timer1_overflow>:
const uint32_t get_timer1_overflow(void)
{
    return timer1_ovrflow_cnt;
    20a0:	20 91 94 0c 	lds	r18, 0x0C94
    20a4:	30 91 95 0c 	lds	r19, 0x0C95
    20a8:	40 91 96 0c 	lds	r20, 0x0C96
    20ac:	50 91 97 0c 	lds	r21, 0x0C97
}
    20b0:	b9 01       	movw	r22, r18
    20b2:	ca 01       	movw	r24, r20
    20b4:	08 95       	ret

000020b6 <get_timer2_overflow>:
const uint32_t get_timer2_overflow(void)
{
    return timer2_ovrflow_cnt;
    20b6:	20 91 9c 0c 	lds	r18, 0x0C9C
    20ba:	30 91 9d 0c 	lds	r19, 0x0C9D
    20be:	40 91 9e 0c 	lds	r20, 0x0C9E
    20c2:	50 91 9f 0c 	lds	r21, 0x0C9F
}
    20c6:	b9 01       	movw	r22, r18
    20c8:	ca 01       	movw	r24, r20
    20ca:	08 95       	ret

000020cc <get_timer3_overflow>:
const uint32_t get_timer3_overflow(void)
{
    return timer3_ovrflow_cnt;
    20cc:	20 91 a4 0c 	lds	r18, 0x0CA4
    20d0:	30 91 a5 0c 	lds	r19, 0x0CA5
    20d4:	40 91 a6 0c 	lds	r20, 0x0CA6
    20d8:	50 91 a7 0c 	lds	r21, 0x0CA7
}
    20dc:	b9 01       	movw	r22, r18
    20de:	ca 01       	movw	r24, r20
    20e0:	08 95       	ret

000020e2 <get_timer4_overflow>:
const uint32_t get_timer4_overflow(void)
{
    return timer4_ovrflow_cnt;
    20e2:	20 91 90 0c 	lds	r18, 0x0C90
    20e6:	30 91 91 0c 	lds	r19, 0x0C91
    20ea:	40 91 92 0c 	lds	r20, 0x0C92
    20ee:	50 91 93 0c 	lds	r21, 0x0C93
}
    20f2:	b9 01       	movw	r22, r18
    20f4:	ca 01       	movw	r24, r20
    20f6:	08 95       	ret

000020f8 <get_timer5_overflow>:
const uint32_t get_timer5_overflow(void)
{
    return timer5_ovrflow_cnt;
    20f8:	20 91 a8 0c 	lds	r18, 0x0CA8
    20fc:	30 91 a9 0c 	lds	r19, 0x0CA9
    2100:	40 91 aa 0c 	lds	r20, 0x0CAA
    2104:	50 91 ab 0c 	lds	r21, 0x0CAB
}
    2108:	b9 01       	movw	r22, r18
    210a:	ca 01       	movw	r24, r20
    210c:	08 95       	ret

0000210e <get_timer0_counter>:

const uint8_t get_timer0_counter(void)
{
    return TCNT0;
    210e:	86 b5       	in	r24, 0x26	; 38
}
    2110:	08 95       	ret

00002112 <get_timer1_counter>:
const uint16_t get_timer1_counter(void)
{
    return TCNT1;
    2112:	20 91 84 00 	lds	r18, 0x0084
    2116:	30 91 85 00 	lds	r19, 0x0085
}
    211a:	c9 01       	movw	r24, r18
    211c:	08 95       	ret

0000211e <get_timer2_counter>:
const uint8_t get_timer2_counter(void)
{
    return TCNT2;
    211e:	80 91 b2 00 	lds	r24, 0x00B2
}
    2122:	08 95       	ret

00002124 <get_timer3_counter>:
const uint16_t get_timer3_counter(void)
{
    return TCNT3;
    2124:	20 91 94 00 	lds	r18, 0x0094
    2128:	30 91 95 00 	lds	r19, 0x0095
}
    212c:	c9 01       	movw	r24, r18
    212e:	08 95       	ret

00002130 <get_timer4_counter>:
const uint16_t get_timer4_counter(void)
{
    return TCNT4;
    2130:	20 91 a4 00 	lds	r18, 0x00A4
    2134:	30 91 a5 00 	lds	r19, 0x00A5
}
    2138:	c9 01       	movw	r24, r18
    213a:	08 95       	ret

0000213c <get_timer5_counter>:
const uint16_t get_timer5_counter(void)
{
    return TCNT5;
    213c:	20 91 24 01 	lds	r18, 0x0124
    2140:	30 91 25 01 	lds	r19, 0x0125
}
    2144:	c9 01       	movw	r24, r18
    2146:	08 95       	ret

00002148 <reset_timer0>:

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    2148:	10 92 98 0c 	sts	0x0C98, r1
    214c:	10 92 99 0c 	sts	0x0C99, r1
    2150:	10 92 9a 0c 	sts	0x0C9A, r1
    2154:	10 92 9b 0c 	sts	0x0C9B, r1
    2158:	16 bc       	out	0x26, r1	; 38
}
    215a:	08 95       	ret

0000215c <reset_timer1>:
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    215c:	10 92 94 0c 	sts	0x0C94, r1
    2160:	10 92 95 0c 	sts	0x0C95, r1
    2164:	10 92 96 0c 	sts	0x0C96, r1
    2168:	10 92 97 0c 	sts	0x0C97, r1
    216c:	10 92 85 00 	sts	0x0085, r1
    2170:	10 92 84 00 	sts	0x0084, r1
}
    2174:	08 95       	ret

00002176 <reset_timer2>:
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2176:	10 92 9c 0c 	sts	0x0C9C, r1
    217a:	10 92 9d 0c 	sts	0x0C9D, r1
    217e:	10 92 9e 0c 	sts	0x0C9E, r1
    2182:	10 92 9f 0c 	sts	0x0C9F, r1
    2186:	10 92 b2 00 	sts	0x00B2, r1
}
    218a:	08 95       	ret

0000218c <reset_timer3>:
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    218c:	10 92 a4 0c 	sts	0x0CA4, r1
    2190:	10 92 a5 0c 	sts	0x0CA5, r1
    2194:	10 92 a6 0c 	sts	0x0CA6, r1
    2198:	10 92 a7 0c 	sts	0x0CA7, r1
    219c:	10 92 95 00 	sts	0x0095, r1
    21a0:	10 92 94 00 	sts	0x0094, r1
}
    21a4:	08 95       	ret

000021a6 <reset_timer4>:
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    21a6:	10 92 90 0c 	sts	0x0C90, r1
    21aa:	10 92 91 0c 	sts	0x0C91, r1
    21ae:	10 92 92 0c 	sts	0x0C92, r1
    21b2:	10 92 93 0c 	sts	0x0C93, r1
    21b6:	10 92 a5 00 	sts	0x00A5, r1
    21ba:	10 92 a4 00 	sts	0x00A4, r1
}
    21be:	08 95       	ret

000021c0 <reset_timer5>:
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    21c0:	10 92 a8 0c 	sts	0x0CA8, r1
    21c4:	10 92 a9 0c 	sts	0x0CA9, r1
    21c8:	10 92 aa 0c 	sts	0x0CAA, r1
    21cc:	10 92 ab 0c 	sts	0x0CAB, r1
    21d0:	10 92 25 01 	sts	0x0125, r1
    21d4:	10 92 24 01 	sts	0x0124, r1
}
    21d8:	08 95       	ret

000021da <delay_us>:

	delay_loops = ((time_us * CYCLES_PER_US)+3) / 5; // +3 for rounding up (dirty) 

	// one loop takes 5 cpu cycles 
	for (i=0; i < delay_loops; i++) {};
}
    21da:	08 95       	ret

000021dc <init_timer0>:

void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
    21dc:	85 bd       	out	0x25, r24	; 37
  TIMSK0 = _BV(TOIE0); // enable interrupts
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	80 93 6e 00 	sts	0x006E, r24
    return TCNT5;
}

void reset_timer0(void)
{
    TCNT0 = timer0_ovrflow_cnt = 0;
    21e4:	10 92 98 0c 	sts	0x0C98, r1
    21e8:	10 92 99 0c 	sts	0x0C99, r1
    21ec:	10 92 9a 0c 	sts	0x0C9A, r1
    21f0:	10 92 9b 0c 	sts	0x0C9B, r1
    21f4:	16 bc       	out	0x26, r1	; 38
void init_timer0(const uint8_t prescaler)
{
  TCCR0B = prescaler;
  TIMSK0 = _BV(TOIE0); // enable interrupts
  reset_timer0(); // reset counter
}
    21f6:	08 95       	ret

000021f8 <init_timer1>:
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
    21f8:	80 93 81 00 	sts	0x0081, r24
  TIMSK1 = _BV(TOIE1); // enable interrupts
    21fc:	81 e0       	ldi	r24, 0x01	; 1
    21fe:	80 93 6f 00 	sts	0x006F, r24
{
    TCNT0 = timer0_ovrflow_cnt = 0;
}
void reset_timer1(void)
{
    TCNT1 = timer1_ovrflow_cnt = 0;
    2202:	10 92 94 0c 	sts	0x0C94, r1
    2206:	10 92 95 0c 	sts	0x0C95, r1
    220a:	10 92 96 0c 	sts	0x0C96, r1
    220e:	10 92 97 0c 	sts	0x0C97, r1
    2212:	10 92 85 00 	sts	0x0085, r1
    2216:	10 92 84 00 	sts	0x0084, r1
void init_timer1(const uint8_t prescaler)
{
  TCCR1B = prescaler;
  TIMSK1 = _BV(TOIE1); // enable interrupts
  reset_timer1(); // reset counter
}
    221a:	08 95       	ret

0000221c <init_timer2>:
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
    221c:	80 93 b1 00 	sts	0x00B1, r24
  TIMSK2 = _BV(TOIE2); // enable interrupts
    2220:	81 e0       	ldi	r24, 0x01	; 1
    2222:	80 93 70 00 	sts	0x0070, r24
{
    TCNT1 = timer1_ovrflow_cnt = 0;
}
void reset_timer2(void)
{
    TCNT2 = timer2_ovrflow_cnt = 0;
    2226:	10 92 9c 0c 	sts	0x0C9C, r1
    222a:	10 92 9d 0c 	sts	0x0C9D, r1
    222e:	10 92 9e 0c 	sts	0x0C9E, r1
    2232:	10 92 9f 0c 	sts	0x0C9F, r1
    2236:	10 92 b2 00 	sts	0x00B2, r1
void init_timer2(const uint8_t prescaler)
{
  TCCR2B = prescaler;
  TIMSK2 = _BV(TOIE2); // enable interrupts
  reset_timer2(); // reset counter
}
    223a:	08 95       	ret

0000223c <init_timer3>:
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
    223c:	80 93 91 00 	sts	0x0091, r24
  TIMSK3 = _BV(TOIE3); // enable interrupts
    2240:	81 e0       	ldi	r24, 0x01	; 1
    2242:	80 93 71 00 	sts	0x0071, r24
{
    TCNT2 = timer2_ovrflow_cnt = 0;
}
void reset_timer3(void)
{
    TCNT3 = timer3_ovrflow_cnt = 0;
    2246:	10 92 a4 0c 	sts	0x0CA4, r1
    224a:	10 92 a5 0c 	sts	0x0CA5, r1
    224e:	10 92 a6 0c 	sts	0x0CA6, r1
    2252:	10 92 a7 0c 	sts	0x0CA7, r1
    2256:	10 92 95 00 	sts	0x0095, r1
    225a:	10 92 94 00 	sts	0x0094, r1
void init_timer3(const uint8_t prescaler)
{
  TCCR3B = prescaler;
  TIMSK3 = _BV(TOIE3); // enable interrupts
  reset_timer3(); // reset counter
}
    225e:	08 95       	ret

00002260 <init_timer4>:
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
    2260:	80 93 a1 00 	sts	0x00A1, r24
  TIMSK4 = _BV(TOIE4); // enable interrupts
    2264:	81 e0       	ldi	r24, 0x01	; 1
    2266:	80 93 72 00 	sts	0x0072, r24
{
    TCNT3 = timer3_ovrflow_cnt = 0;
}
void reset_timer4(void)
{
    TCNT4 = timer4_ovrflow_cnt = 0;
    226a:	10 92 90 0c 	sts	0x0C90, r1
    226e:	10 92 91 0c 	sts	0x0C91, r1
    2272:	10 92 92 0c 	sts	0x0C92, r1
    2276:	10 92 93 0c 	sts	0x0C93, r1
    227a:	10 92 a5 00 	sts	0x00A5, r1
    227e:	10 92 a4 00 	sts	0x00A4, r1
void init_timer4(const uint8_t prescaler)
{
  TCCR4B = prescaler;
  TIMSK4 = _BV(TOIE4); // enable interrupts
  reset_timer4(); // reset counter
}
    2282:	08 95       	ret

00002284 <init_timer5>:
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
    2284:	80 93 21 01 	sts	0x0121, r24
  TIMSK5 = _BV(TOIE5); // enable interrupts
    2288:	81 e0       	ldi	r24, 0x01	; 1
    228a:	80 93 73 00 	sts	0x0073, r24
{
    TCNT4 = timer4_ovrflow_cnt = 0;
}
void reset_timer5(void)
{
    TCNT5 = timer5_ovrflow_cnt = 0;
    228e:	10 92 a8 0c 	sts	0x0CA8, r1
    2292:	10 92 a9 0c 	sts	0x0CA9, r1
    2296:	10 92 aa 0c 	sts	0x0CAA, r1
    229a:	10 92 ab 0c 	sts	0x0CAB, r1
    229e:	10 92 25 01 	sts	0x0125, r1
    22a2:	10 92 24 01 	sts	0x0124, r1
void init_timer5(const uint8_t prescaler)
{
  TCCR5B = prescaler;
  TIMSK5 = _BV(TOIE5); // enable interrupts
  reset_timer5(); // reset counter
}
    22a6:	08 95       	ret

000022a8 <timer_attach>:

void timer_attach(TimerInterrupt_t interrupt, void (*user_func)(void) )
{
  // set the interrupt function to run
  // the supplied user's function
  TimerIntFunc[interrupt] = user_func;
    22a8:	e8 2f       	mov	r30, r24
    22aa:	f0 e0       	ldi	r31, 0x00	; 0
    22ac:	ee 0f       	add	r30, r30
    22ae:	ff 1f       	adc	r31, r31
    22b0:	ee 5e       	subi	r30, 0xEE	; 238
    22b2:	f5 4f       	sbci	r31, 0xF5	; 245
    22b4:	71 83       	std	Z+1, r23	; 0x01
    22b6:	60 83       	st	Z, r22
}
    22b8:	08 95       	ret

000022ba <timer_detach>:

void timer_detach(TimerInterrupt_t interrupt)
{
  // clear the user defined interrupt function
  TimerIntFunc[interrupt] = NULL;
    22ba:	e8 2f       	mov	r30, r24
    22bc:	f0 e0       	ldi	r31, 0x00	; 0
    22be:	ee 0f       	add	r30, r30
    22c0:	ff 1f       	adc	r31, r31
    22c2:	ee 5e       	subi	r30, 0xEE	; 238
    22c4:	f5 4f       	sbci	r31, 0xF5	; 245
    22c6:	11 82       	std	Z+1, r1	; 0x01
    22c8:	10 82       	st	Z, r1
}
    22ca:	08 95       	ret

000022cc <_delay_loop_2>:

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    22cc:	01 97       	sbiw	r24, 0x01	; 1
    22ce:	f1 f7       	brne	.-4      	; 0x22cc <_delay_loop_2>
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
    22d0:	08 95       	ret

000022d2 <sleep>:

void sleep(uint16_t time_ms)
{
    22d2:	af 92       	push	r10
    22d4:	bf 92       	push	r11
    22d6:	cf 92       	push	r12
    22d8:	df 92       	push	r13
    22da:	ef 92       	push	r14
    22dc:	ff 92       	push	r15
    22de:	0f 93       	push	r16
    22e0:	1f 93       	push	r17
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * time_ms;
    22e2:	a0 e0       	ldi	r26, 0x00	; 0
    22e4:	b0 e0       	ldi	r27, 0x00	; 0
    22e6:	bc 01       	movw	r22, r24
    22e8:	cd 01       	movw	r24, r26
    22ea:	0e 94 f2 23 	call	0x47e4	; 0x47e4 <__floatunsisf>
    22ee:	5b 01       	movw	r10, r22
    22f0:	6c 01       	movw	r12, r24
    22f2:	20 e0       	ldi	r18, 0x00	; 0
    22f4:	30 e0       	ldi	r19, 0x00	; 0
    22f6:	4a e7       	ldi	r20, 0x7A	; 122
    22f8:	55 e4       	ldi	r21, 0x45	; 69
    22fa:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__mulsf3>
    22fe:	7b 01       	movw	r14, r22
    2300:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    2302:	20 e0       	ldi	r18, 0x00	; 0
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	40 e8       	ldi	r20, 0x80	; 128
    2308:	5f e3       	ldi	r21, 0x3F	; 63
    230a:	0e 94 10 23 	call	0x4620	; 0x4620 <__ltsf2>
    230e:	88 23       	and	r24, r24
    2310:	1c f4       	brge	.+6      	; 0x2318 <sleep+0x46>
    2312:	61 e0       	ldi	r22, 0x01	; 1
    2314:	70 e0       	ldi	r23, 0x00	; 0
    2316:	24 c0       	rjmp	.+72     	; 0x2360 <sleep+0x8e>
		__ticks = 1;
	else if (__tmp > 65535)
    2318:	c8 01       	movw	r24, r16
    231a:	b7 01       	movw	r22, r14
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	3f ef       	ldi	r19, 0xFF	; 255
    2320:	4f e7       	ldi	r20, 0x7F	; 127
    2322:	57 e4       	ldi	r21, 0x47	; 71
    2324:	0e 94 b0 22 	call	0x4560	; 0x4560 <__gtsf2>
    2328:	18 16       	cp	r1, r24
    232a:	b4 f4       	brge	.+44     	; 0x2358 <sleep+0x86>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
    232c:	c6 01       	movw	r24, r12
    232e:	b5 01       	movw	r22, r10
    2330:	20 e0       	ldi	r18, 0x00	; 0
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	40 e2       	ldi	r20, 0x20	; 32
    2336:	51 e4       	ldi	r21, 0x41	; 65
    2338:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__mulsf3>
    233c:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2340:	80 e9       	ldi	r24, 0x90	; 144
    2342:	91 e0       	ldi	r25, 0x01	; 1
    2344:	05 c0       	rjmp	.+10     	; 0x2350 <sleep+0x7e>
    2346:	fc 01       	movw	r30, r24
    2348:	31 97       	sbiw	r30, 0x01	; 1
    234a:	f1 f7       	brne	.-4      	; 0x2348 <sleep+0x76>
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    234c:	61 50       	subi	r22, 0x01	; 1
    234e:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (time_ms * 10.0);
		while(__ticks)
    2350:	61 15       	cp	r22, r1
    2352:	71 05       	cpc	r23, r1
    2354:	c1 f7       	brne	.-16     	; 0x2346 <sleep+0x74>
    2356:	07 c0       	rjmp	.+14     	; 0x2366 <sleep+0x94>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2358:	c8 01       	movw	r24, r16
    235a:	b7 01       	movw	r22, r14
    235c:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__fixunssfsi>
}

void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2360:	cb 01       	movw	r24, r22
    2362:	01 97       	sbiw	r24, 0x01	; 1
    2364:	f1 f7       	brne	.-4      	; 0x2362 <sleep+0x90>
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
}
    2366:	1f 91       	pop	r17
    2368:	0f 91       	pop	r16
    236a:	ff 90       	pop	r15
    236c:	ef 90       	pop	r14
    236e:	df 90       	pop	r13
    2370:	cf 90       	pop	r12
    2372:	bf 90       	pop	r11
    2374:	af 90       	pop	r10
    2376:	08 95       	ret

00002378 <__vector_23>:
    }
  }
}*/

ISR(TIMER0_OVF_vect) 
{
    2378:	1f 92       	push	r1
    237a:	0f 92       	push	r0
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	0f 92       	push	r0
    2380:	11 24       	eor	r1, r1
    2382:	2f 93       	push	r18
    2384:	3f 93       	push	r19
    2386:	4f 93       	push	r20
    2388:	5f 93       	push	r21
    238a:	6f 93       	push	r22
    238c:	7f 93       	push	r23
    238e:	8f 93       	push	r24
    2390:	9f 93       	push	r25
    2392:	af 93       	push	r26
    2394:	bf 93       	push	r27
    2396:	ef 93       	push	r30
    2398:	ff 93       	push	r31
  timer0_ovrflow_cnt++;
    239a:	80 91 98 0c 	lds	r24, 0x0C98
    239e:	90 91 99 0c 	lds	r25, 0x0C99
    23a2:	a0 91 9a 0c 	lds	r26, 0x0C9A
    23a6:	b0 91 9b 0c 	lds	r27, 0x0C9B
    23aa:	01 96       	adiw	r24, 0x01	; 1
    23ac:	a1 1d       	adc	r26, r1
    23ae:	b1 1d       	adc	r27, r1
    23b0:	80 93 98 0c 	sts	0x0C98, r24
    23b4:	90 93 99 0c 	sts	0x0C99, r25
    23b8:	a0 93 9a 0c 	sts	0x0C9A, r26
    23bc:	b0 93 9b 0c 	sts	0x0C9B, r27
  timer_sleep_cnt++;
    23c0:	80 91 a0 0c 	lds	r24, 0x0CA0
    23c4:	90 91 a1 0c 	lds	r25, 0x0CA1
    23c8:	a0 91 a2 0c 	lds	r26, 0x0CA2
    23cc:	b0 91 a3 0c 	lds	r27, 0x0CA3
    23d0:	01 96       	adiw	r24, 0x01	; 1
    23d2:	a1 1d       	adc	r26, r1
    23d4:	b1 1d       	adc	r27, r1
    23d6:	80 93 a0 0c 	sts	0x0CA0, r24
    23da:	90 93 a1 0c 	sts	0x0CA1, r25
    23de:	a0 93 a2 0c 	sts	0x0CA2, r26
    23e2:	b0 93 a3 0c 	sts	0x0CA3, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER0_OVF_interrupt);
    23e6:	80 91 16 0a 	lds	r24, 0x0A16
    23ea:	90 91 17 0a 	lds	r25, 0x0A17
    23ee:	89 2b       	or	r24, r25
    23f0:	29 f0       	breq	.+10     	; 0x23fc <__vector_23+0x84>
    23f2:	e0 91 16 0a 	lds	r30, 0x0A16
    23f6:	f0 91 17 0a 	lds	r31, 0x0A17
    23fa:	09 95       	icall
}
    23fc:	ff 91       	pop	r31
    23fe:	ef 91       	pop	r30
    2400:	bf 91       	pop	r27
    2402:	af 91       	pop	r26
    2404:	9f 91       	pop	r25
    2406:	8f 91       	pop	r24
    2408:	7f 91       	pop	r23
    240a:	6f 91       	pop	r22
    240c:	5f 91       	pop	r21
    240e:	4f 91       	pop	r20
    2410:	3f 91       	pop	r19
    2412:	2f 91       	pop	r18
    2414:	0f 90       	pop	r0
    2416:	0f be       	out	0x3f, r0	; 63
    2418:	0f 90       	pop	r0
    241a:	1f 90       	pop	r1
    241c:	18 95       	reti

0000241e <__vector_20>:
ISR(TIMER1_OVF_vect) 
{
    241e:	1f 92       	push	r1
    2420:	0f 92       	push	r0
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	0f 92       	push	r0
    2426:	11 24       	eor	r1, r1
    2428:	2f 93       	push	r18
    242a:	3f 93       	push	r19
    242c:	4f 93       	push	r20
    242e:	5f 93       	push	r21
    2430:	6f 93       	push	r22
    2432:	7f 93       	push	r23
    2434:	8f 93       	push	r24
    2436:	9f 93       	push	r25
    2438:	af 93       	push	r26
    243a:	bf 93       	push	r27
    243c:	ef 93       	push	r30
    243e:	ff 93       	push	r31
  timer1_ovrflow_cnt++;
    2440:	80 91 94 0c 	lds	r24, 0x0C94
    2444:	90 91 95 0c 	lds	r25, 0x0C95
    2448:	a0 91 96 0c 	lds	r26, 0x0C96
    244c:	b0 91 97 0c 	lds	r27, 0x0C97
    2450:	01 96       	adiw	r24, 0x01	; 1
    2452:	a1 1d       	adc	r26, r1
    2454:	b1 1d       	adc	r27, r1
    2456:	80 93 94 0c 	sts	0x0C94, r24
    245a:	90 93 95 0c 	sts	0x0C95, r25
    245e:	a0 93 96 0c 	sts	0x0C96, r26
    2462:	b0 93 97 0c 	sts	0x0C97, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER1_OVF_interrupt);
    2466:	80 91 20 0a 	lds	r24, 0x0A20
    246a:	90 91 21 0a 	lds	r25, 0x0A21
    246e:	89 2b       	or	r24, r25
    2470:	29 f0       	breq	.+10     	; 0x247c <__vector_20+0x5e>
    2472:	e0 91 20 0a 	lds	r30, 0x0A20
    2476:	f0 91 21 0a 	lds	r31, 0x0A21
    247a:	09 95       	icall
}
    247c:	ff 91       	pop	r31
    247e:	ef 91       	pop	r30
    2480:	bf 91       	pop	r27
    2482:	af 91       	pop	r26
    2484:	9f 91       	pop	r25
    2486:	8f 91       	pop	r24
    2488:	7f 91       	pop	r23
    248a:	6f 91       	pop	r22
    248c:	5f 91       	pop	r21
    248e:	4f 91       	pop	r20
    2490:	3f 91       	pop	r19
    2492:	2f 91       	pop	r18
    2494:	0f 90       	pop	r0
    2496:	0f be       	out	0x3f, r0	; 63
    2498:	0f 90       	pop	r0
    249a:	1f 90       	pop	r1
    249c:	18 95       	reti

0000249e <__vector_15>:
ISR(TIMER2_OVF_vect) 
{
    249e:	1f 92       	push	r1
    24a0:	0f 92       	push	r0
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	0f 92       	push	r0
    24a6:	11 24       	eor	r1, r1
    24a8:	2f 93       	push	r18
    24aa:	3f 93       	push	r19
    24ac:	4f 93       	push	r20
    24ae:	5f 93       	push	r21
    24b0:	6f 93       	push	r22
    24b2:	7f 93       	push	r23
    24b4:	8f 93       	push	r24
    24b6:	9f 93       	push	r25
    24b8:	af 93       	push	r26
    24ba:	bf 93       	push	r27
    24bc:	ef 93       	push	r30
    24be:	ff 93       	push	r31
  timer2_ovrflow_cnt++;
    24c0:	80 91 9c 0c 	lds	r24, 0x0C9C
    24c4:	90 91 9d 0c 	lds	r25, 0x0C9D
    24c8:	a0 91 9e 0c 	lds	r26, 0x0C9E
    24cc:	b0 91 9f 0c 	lds	r27, 0x0C9F
    24d0:	01 96       	adiw	r24, 0x01	; 1
    24d2:	a1 1d       	adc	r26, r1
    24d4:	b1 1d       	adc	r27, r1
    24d6:	80 93 9c 0c 	sts	0x0C9C, r24
    24da:	90 93 9d 0c 	sts	0x0C9D, r25
    24de:	a0 93 9e 0c 	sts	0x0C9E, r26
    24e2:	b0 93 9f 0c 	sts	0x0C9F, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER2_OVF_interrupt);
    24e6:	80 91 26 0a 	lds	r24, 0x0A26
    24ea:	90 91 27 0a 	lds	r25, 0x0A27
    24ee:	89 2b       	or	r24, r25
    24f0:	29 f0       	breq	.+10     	; 0x24fc <__vector_15+0x5e>
    24f2:	e0 91 26 0a 	lds	r30, 0x0A26
    24f6:	f0 91 27 0a 	lds	r31, 0x0A27
    24fa:	09 95       	icall
}
    24fc:	ff 91       	pop	r31
    24fe:	ef 91       	pop	r30
    2500:	bf 91       	pop	r27
    2502:	af 91       	pop	r26
    2504:	9f 91       	pop	r25
    2506:	8f 91       	pop	r24
    2508:	7f 91       	pop	r23
    250a:	6f 91       	pop	r22
    250c:	5f 91       	pop	r21
    250e:	4f 91       	pop	r20
    2510:	3f 91       	pop	r19
    2512:	2f 91       	pop	r18
    2514:	0f 90       	pop	r0
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	0f 90       	pop	r0
    251a:	1f 90       	pop	r1
    251c:	18 95       	reti

0000251e <__vector_35>:
ISR(TIMER3_OVF_vect) 
{
    251e:	1f 92       	push	r1
    2520:	0f 92       	push	r0
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	0f 92       	push	r0
    2526:	11 24       	eor	r1, r1
    2528:	2f 93       	push	r18
    252a:	3f 93       	push	r19
    252c:	4f 93       	push	r20
    252e:	5f 93       	push	r21
    2530:	6f 93       	push	r22
    2532:	7f 93       	push	r23
    2534:	8f 93       	push	r24
    2536:	9f 93       	push	r25
    2538:	af 93       	push	r26
    253a:	bf 93       	push	r27
    253c:	ef 93       	push	r30
    253e:	ff 93       	push	r31
  timer3_ovrflow_cnt++;
    2540:	80 91 a4 0c 	lds	r24, 0x0CA4
    2544:	90 91 a5 0c 	lds	r25, 0x0CA5
    2548:	a0 91 a6 0c 	lds	r26, 0x0CA6
    254c:	b0 91 a7 0c 	lds	r27, 0x0CA7
    2550:	01 96       	adiw	r24, 0x01	; 1
    2552:	a1 1d       	adc	r26, r1
    2554:	b1 1d       	adc	r27, r1
    2556:	80 93 a4 0c 	sts	0x0CA4, r24
    255a:	90 93 a5 0c 	sts	0x0CA5, r25
    255e:	a0 93 a6 0c 	sts	0x0CA6, r26
    2562:	b0 93 a7 0c 	sts	0x0CA7, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER3_OVF_interrupt);
    2566:	80 91 30 0a 	lds	r24, 0x0A30
    256a:	90 91 31 0a 	lds	r25, 0x0A31
    256e:	89 2b       	or	r24, r25
    2570:	29 f0       	breq	.+10     	; 0x257c <__vector_35+0x5e>
    2572:	e0 91 30 0a 	lds	r30, 0x0A30
    2576:	f0 91 31 0a 	lds	r31, 0x0A31
    257a:	09 95       	icall
}
    257c:	ff 91       	pop	r31
    257e:	ef 91       	pop	r30
    2580:	bf 91       	pop	r27
    2582:	af 91       	pop	r26
    2584:	9f 91       	pop	r25
    2586:	8f 91       	pop	r24
    2588:	7f 91       	pop	r23
    258a:	6f 91       	pop	r22
    258c:	5f 91       	pop	r21
    258e:	4f 91       	pop	r20
    2590:	3f 91       	pop	r19
    2592:	2f 91       	pop	r18
    2594:	0f 90       	pop	r0
    2596:	0f be       	out	0x3f, r0	; 63
    2598:	0f 90       	pop	r0
    259a:	1f 90       	pop	r1
    259c:	18 95       	reti

0000259e <__vector_45>:
ISR(TIMER4_OVF_vect) 
{
    259e:	1f 92       	push	r1
    25a0:	0f 92       	push	r0
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	0f 92       	push	r0
    25a6:	11 24       	eor	r1, r1
    25a8:	2f 93       	push	r18
    25aa:	3f 93       	push	r19
    25ac:	4f 93       	push	r20
    25ae:	5f 93       	push	r21
    25b0:	6f 93       	push	r22
    25b2:	7f 93       	push	r23
    25b4:	8f 93       	push	r24
    25b6:	9f 93       	push	r25
    25b8:	af 93       	push	r26
    25ba:	bf 93       	push	r27
    25bc:	ef 93       	push	r30
    25be:	ff 93       	push	r31
  timer4_ovrflow_cnt++;
    25c0:	80 91 90 0c 	lds	r24, 0x0C90
    25c4:	90 91 91 0c 	lds	r25, 0x0C91
    25c8:	a0 91 92 0c 	lds	r26, 0x0C92
    25cc:	b0 91 93 0c 	lds	r27, 0x0C93
    25d0:	01 96       	adiw	r24, 0x01	; 1
    25d2:	a1 1d       	adc	r26, r1
    25d4:	b1 1d       	adc	r27, r1
    25d6:	80 93 90 0c 	sts	0x0C90, r24
    25da:	90 93 91 0c 	sts	0x0C91, r25
    25de:	a0 93 92 0c 	sts	0x0C92, r26
    25e2:	b0 93 93 0c 	sts	0x0C93, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER4_OVF_interrupt);
    25e6:	80 91 3a 0a 	lds	r24, 0x0A3A
    25ea:	90 91 3b 0a 	lds	r25, 0x0A3B
    25ee:	89 2b       	or	r24, r25
    25f0:	29 f0       	breq	.+10     	; 0x25fc <__vector_45+0x5e>
    25f2:	e0 91 3a 0a 	lds	r30, 0x0A3A
    25f6:	f0 91 3b 0a 	lds	r31, 0x0A3B
    25fa:	09 95       	icall
}
    25fc:	ff 91       	pop	r31
    25fe:	ef 91       	pop	r30
    2600:	bf 91       	pop	r27
    2602:	af 91       	pop	r26
    2604:	9f 91       	pop	r25
    2606:	8f 91       	pop	r24
    2608:	7f 91       	pop	r23
    260a:	6f 91       	pop	r22
    260c:	5f 91       	pop	r21
    260e:	4f 91       	pop	r20
    2610:	3f 91       	pop	r19
    2612:	2f 91       	pop	r18
    2614:	0f 90       	pop	r0
    2616:	0f be       	out	0x3f, r0	; 63
    2618:	0f 90       	pop	r0
    261a:	1f 90       	pop	r1
    261c:	18 95       	reti

0000261e <__vector_50>:
ISR(TIMER5_OVF_vect) 
{
    261e:	1f 92       	push	r1
    2620:	0f 92       	push	r0
    2622:	0f b6       	in	r0, 0x3f	; 63
    2624:	0f 92       	push	r0
    2626:	11 24       	eor	r1, r1
    2628:	2f 93       	push	r18
    262a:	3f 93       	push	r19
    262c:	4f 93       	push	r20
    262e:	5f 93       	push	r21
    2630:	6f 93       	push	r22
    2632:	7f 93       	push	r23
    2634:	8f 93       	push	r24
    2636:	9f 93       	push	r25
    2638:	af 93       	push	r26
    263a:	bf 93       	push	r27
    263c:	ef 93       	push	r30
    263e:	ff 93       	push	r31
  timer5_ovrflow_cnt++;
    2640:	80 91 a8 0c 	lds	r24, 0x0CA8
    2644:	90 91 a9 0c 	lds	r25, 0x0CA9
    2648:	a0 91 aa 0c 	lds	r26, 0x0CAA
    264c:	b0 91 ab 0c 	lds	r27, 0x0CAB
    2650:	01 96       	adiw	r24, 0x01	; 1
    2652:	a1 1d       	adc	r26, r1
    2654:	b1 1d       	adc	r27, r1
    2656:	80 93 a8 0c 	sts	0x0CA8, r24
    265a:	90 93 a9 0c 	sts	0x0CA9, r25
    265e:	a0 93 aa 0c 	sts	0x0CAA, r26
    2662:	b0 93 ab 0c 	sts	0x0CAB, r27
  RUN_USER_DEFINE_INTERRUPT(TIMER5_OVF_interrupt);
    2666:	80 91 44 0a 	lds	r24, 0x0A44
    266a:	90 91 45 0a 	lds	r25, 0x0A45
    266e:	89 2b       	or	r24, r25
    2670:	29 f0       	breq	.+10     	; 0x267c <__vector_50+0x5e>
    2672:	e0 91 44 0a 	lds	r30, 0x0A44
    2676:	f0 91 45 0a 	lds	r31, 0x0A45
    267a:	09 95       	icall
}
    267c:	ff 91       	pop	r31
    267e:	ef 91       	pop	r30
    2680:	bf 91       	pop	r27
    2682:	af 91       	pop	r26
    2684:	9f 91       	pop	r25
    2686:	8f 91       	pop	r24
    2688:	7f 91       	pop	r23
    268a:	6f 91       	pop	r22
    268c:	5f 91       	pop	r21
    268e:	4f 91       	pop	r20
    2690:	3f 91       	pop	r19
    2692:	2f 91       	pop	r18
    2694:	0f 90       	pop	r0
    2696:	0f be       	out	0x3f, r0	; 63
    2698:	0f 90       	pop	r0
    269a:	1f 90       	pop	r1
    269c:	18 95       	reti

0000269e <__vector_21>:
ISR(TIMER0_COMPA_vect)
{
    269e:	1f 92       	push	r1
    26a0:	0f 92       	push	r0
    26a2:	0f b6       	in	r0, 0x3f	; 63
    26a4:	0f 92       	push	r0
    26a6:	11 24       	eor	r1, r1
    26a8:	2f 93       	push	r18
    26aa:	3f 93       	push	r19
    26ac:	4f 93       	push	r20
    26ae:	5f 93       	push	r21
    26b0:	6f 93       	push	r22
    26b2:	7f 93       	push	r23
    26b4:	8f 93       	push	r24
    26b6:	9f 93       	push	r25
    26b8:	af 93       	push	r26
    26ba:	bf 93       	push	r27
    26bc:	ef 93       	push	r30
    26be:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPA_interrupt);
    26c0:	80 91 12 0a 	lds	r24, 0x0A12
    26c4:	90 91 13 0a 	lds	r25, 0x0A13
    26c8:	89 2b       	or	r24, r25
    26ca:	29 f0       	breq	.+10     	; 0x26d6 <__vector_21+0x38>
    26cc:	e0 91 12 0a 	lds	r30, 0x0A12
    26d0:	f0 91 13 0a 	lds	r31, 0x0A13
    26d4:	09 95       	icall
}
    26d6:	ff 91       	pop	r31
    26d8:	ef 91       	pop	r30
    26da:	bf 91       	pop	r27
    26dc:	af 91       	pop	r26
    26de:	9f 91       	pop	r25
    26e0:	8f 91       	pop	r24
    26e2:	7f 91       	pop	r23
    26e4:	6f 91       	pop	r22
    26e6:	5f 91       	pop	r21
    26e8:	4f 91       	pop	r20
    26ea:	3f 91       	pop	r19
    26ec:	2f 91       	pop	r18
    26ee:	0f 90       	pop	r0
    26f0:	0f be       	out	0x3f, r0	; 63
    26f2:	0f 90       	pop	r0
    26f4:	1f 90       	pop	r1
    26f6:	18 95       	reti

000026f8 <__vector_22>:
ISR(TIMER0_COMPB_vect)
{
    26f8:	1f 92       	push	r1
    26fa:	0f 92       	push	r0
    26fc:	0f b6       	in	r0, 0x3f	; 63
    26fe:	0f 92       	push	r0
    2700:	11 24       	eor	r1, r1
    2702:	2f 93       	push	r18
    2704:	3f 93       	push	r19
    2706:	4f 93       	push	r20
    2708:	5f 93       	push	r21
    270a:	6f 93       	push	r22
    270c:	7f 93       	push	r23
    270e:	8f 93       	push	r24
    2710:	9f 93       	push	r25
    2712:	af 93       	push	r26
    2714:	bf 93       	push	r27
    2716:	ef 93       	push	r30
    2718:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER0_COMPB_interrupt);
    271a:	80 91 14 0a 	lds	r24, 0x0A14
    271e:	90 91 15 0a 	lds	r25, 0x0A15
    2722:	89 2b       	or	r24, r25
    2724:	29 f0       	breq	.+10     	; 0x2730 <__vector_22+0x38>
    2726:	e0 91 14 0a 	lds	r30, 0x0A14
    272a:	f0 91 15 0a 	lds	r31, 0x0A15
    272e:	09 95       	icall
}
    2730:	ff 91       	pop	r31
    2732:	ef 91       	pop	r30
    2734:	bf 91       	pop	r27
    2736:	af 91       	pop	r26
    2738:	9f 91       	pop	r25
    273a:	8f 91       	pop	r24
    273c:	7f 91       	pop	r23
    273e:	6f 91       	pop	r22
    2740:	5f 91       	pop	r21
    2742:	4f 91       	pop	r20
    2744:	3f 91       	pop	r19
    2746:	2f 91       	pop	r18
    2748:	0f 90       	pop	r0
    274a:	0f be       	out	0x3f, r0	; 63
    274c:	0f 90       	pop	r0
    274e:	1f 90       	pop	r1
    2750:	18 95       	reti

00002752 <__vector_16>:
ISR(TIMER1_CAPT_vect)
{
    2752:	1f 92       	push	r1
    2754:	0f 92       	push	r0
    2756:	0f b6       	in	r0, 0x3f	; 63
    2758:	0f 92       	push	r0
    275a:	11 24       	eor	r1, r1
    275c:	2f 93       	push	r18
    275e:	3f 93       	push	r19
    2760:	4f 93       	push	r20
    2762:	5f 93       	push	r21
    2764:	6f 93       	push	r22
    2766:	7f 93       	push	r23
    2768:	8f 93       	push	r24
    276a:	9f 93       	push	r25
    276c:	af 93       	push	r26
    276e:	bf 93       	push	r27
    2770:	ef 93       	push	r30
    2772:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_CAPT_interrupt);
    2774:	80 91 18 0a 	lds	r24, 0x0A18
    2778:	90 91 19 0a 	lds	r25, 0x0A19
    277c:	89 2b       	or	r24, r25
    277e:	29 f0       	breq	.+10     	; 0x278a <__vector_16+0x38>
    2780:	e0 91 18 0a 	lds	r30, 0x0A18
    2784:	f0 91 19 0a 	lds	r31, 0x0A19
    2788:	09 95       	icall
}
    278a:	ff 91       	pop	r31
    278c:	ef 91       	pop	r30
    278e:	bf 91       	pop	r27
    2790:	af 91       	pop	r26
    2792:	9f 91       	pop	r25
    2794:	8f 91       	pop	r24
    2796:	7f 91       	pop	r23
    2798:	6f 91       	pop	r22
    279a:	5f 91       	pop	r21
    279c:	4f 91       	pop	r20
    279e:	3f 91       	pop	r19
    27a0:	2f 91       	pop	r18
    27a2:	0f 90       	pop	r0
    27a4:	0f be       	out	0x3f, r0	; 63
    27a6:	0f 90       	pop	r0
    27a8:	1f 90       	pop	r1
    27aa:	18 95       	reti

000027ac <__vector_18>:
{
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPA_interrupt);
}
*/
ISR(TIMER1_COMPB_vect)
{
    27ac:	1f 92       	push	r1
    27ae:	0f 92       	push	r0
    27b0:	0f b6       	in	r0, 0x3f	; 63
    27b2:	0f 92       	push	r0
    27b4:	11 24       	eor	r1, r1
    27b6:	2f 93       	push	r18
    27b8:	3f 93       	push	r19
    27ba:	4f 93       	push	r20
    27bc:	5f 93       	push	r21
    27be:	6f 93       	push	r22
    27c0:	7f 93       	push	r23
    27c2:	8f 93       	push	r24
    27c4:	9f 93       	push	r25
    27c6:	af 93       	push	r26
    27c8:	bf 93       	push	r27
    27ca:	ef 93       	push	r30
    27cc:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPB_interrupt);
    27ce:	80 91 1c 0a 	lds	r24, 0x0A1C
    27d2:	90 91 1d 0a 	lds	r25, 0x0A1D
    27d6:	89 2b       	or	r24, r25
    27d8:	29 f0       	breq	.+10     	; 0x27e4 <__vector_18+0x38>
    27da:	e0 91 1c 0a 	lds	r30, 0x0A1C
    27de:	f0 91 1d 0a 	lds	r31, 0x0A1D
    27e2:	09 95       	icall
}
    27e4:	ff 91       	pop	r31
    27e6:	ef 91       	pop	r30
    27e8:	bf 91       	pop	r27
    27ea:	af 91       	pop	r26
    27ec:	9f 91       	pop	r25
    27ee:	8f 91       	pop	r24
    27f0:	7f 91       	pop	r23
    27f2:	6f 91       	pop	r22
    27f4:	5f 91       	pop	r21
    27f6:	4f 91       	pop	r20
    27f8:	3f 91       	pop	r19
    27fa:	2f 91       	pop	r18
    27fc:	0f 90       	pop	r0
    27fe:	0f be       	out	0x3f, r0	; 63
    2800:	0f 90       	pop	r0
    2802:	1f 90       	pop	r1
    2804:	18 95       	reti

00002806 <__vector_19>:
ISR(TIMER1_COMPC_vect)
{
    2806:	1f 92       	push	r1
    2808:	0f 92       	push	r0
    280a:	0f b6       	in	r0, 0x3f	; 63
    280c:	0f 92       	push	r0
    280e:	11 24       	eor	r1, r1
    2810:	2f 93       	push	r18
    2812:	3f 93       	push	r19
    2814:	4f 93       	push	r20
    2816:	5f 93       	push	r21
    2818:	6f 93       	push	r22
    281a:	7f 93       	push	r23
    281c:	8f 93       	push	r24
    281e:	9f 93       	push	r25
    2820:	af 93       	push	r26
    2822:	bf 93       	push	r27
    2824:	ef 93       	push	r30
    2826:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER1_COMPC_interrupt);
    2828:	80 91 1e 0a 	lds	r24, 0x0A1E
    282c:	90 91 1f 0a 	lds	r25, 0x0A1F
    2830:	89 2b       	or	r24, r25
    2832:	29 f0       	breq	.+10     	; 0x283e <__vector_19+0x38>
    2834:	e0 91 1e 0a 	lds	r30, 0x0A1E
    2838:	f0 91 1f 0a 	lds	r31, 0x0A1F
    283c:	09 95       	icall
}
    283e:	ff 91       	pop	r31
    2840:	ef 91       	pop	r30
    2842:	bf 91       	pop	r27
    2844:	af 91       	pop	r26
    2846:	9f 91       	pop	r25
    2848:	8f 91       	pop	r24
    284a:	7f 91       	pop	r23
    284c:	6f 91       	pop	r22
    284e:	5f 91       	pop	r21
    2850:	4f 91       	pop	r20
    2852:	3f 91       	pop	r19
    2854:	2f 91       	pop	r18
    2856:	0f 90       	pop	r0
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	0f 90       	pop	r0
    285c:	1f 90       	pop	r1
    285e:	18 95       	reti

00002860 <__vector_13>:
ISR(TIMER2_COMPA_vect)
{
    2860:	1f 92       	push	r1
    2862:	0f 92       	push	r0
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	0f 92       	push	r0
    2868:	11 24       	eor	r1, r1
    286a:	2f 93       	push	r18
    286c:	3f 93       	push	r19
    286e:	4f 93       	push	r20
    2870:	5f 93       	push	r21
    2872:	6f 93       	push	r22
    2874:	7f 93       	push	r23
    2876:	8f 93       	push	r24
    2878:	9f 93       	push	r25
    287a:	af 93       	push	r26
    287c:	bf 93       	push	r27
    287e:	ef 93       	push	r30
    2880:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPA_interrupt);
    2882:	80 91 22 0a 	lds	r24, 0x0A22
    2886:	90 91 23 0a 	lds	r25, 0x0A23
    288a:	89 2b       	or	r24, r25
    288c:	29 f0       	breq	.+10     	; 0x2898 <__vector_13+0x38>
    288e:	e0 91 22 0a 	lds	r30, 0x0A22
    2892:	f0 91 23 0a 	lds	r31, 0x0A23
    2896:	09 95       	icall
}
    2898:	ff 91       	pop	r31
    289a:	ef 91       	pop	r30
    289c:	bf 91       	pop	r27
    289e:	af 91       	pop	r26
    28a0:	9f 91       	pop	r25
    28a2:	8f 91       	pop	r24
    28a4:	7f 91       	pop	r23
    28a6:	6f 91       	pop	r22
    28a8:	5f 91       	pop	r21
    28aa:	4f 91       	pop	r20
    28ac:	3f 91       	pop	r19
    28ae:	2f 91       	pop	r18
    28b0:	0f 90       	pop	r0
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	0f 90       	pop	r0
    28b6:	1f 90       	pop	r1
    28b8:	18 95       	reti

000028ba <__vector_14>:
ISR(TIMER2_COMPB_vect)
{
    28ba:	1f 92       	push	r1
    28bc:	0f 92       	push	r0
    28be:	0f b6       	in	r0, 0x3f	; 63
    28c0:	0f 92       	push	r0
    28c2:	11 24       	eor	r1, r1
    28c4:	2f 93       	push	r18
    28c6:	3f 93       	push	r19
    28c8:	4f 93       	push	r20
    28ca:	5f 93       	push	r21
    28cc:	6f 93       	push	r22
    28ce:	7f 93       	push	r23
    28d0:	8f 93       	push	r24
    28d2:	9f 93       	push	r25
    28d4:	af 93       	push	r26
    28d6:	bf 93       	push	r27
    28d8:	ef 93       	push	r30
    28da:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER2_COMPB_interrupt);
    28dc:	80 91 24 0a 	lds	r24, 0x0A24
    28e0:	90 91 25 0a 	lds	r25, 0x0A25
    28e4:	89 2b       	or	r24, r25
    28e6:	29 f0       	breq	.+10     	; 0x28f2 <__vector_14+0x38>
    28e8:	e0 91 24 0a 	lds	r30, 0x0A24
    28ec:	f0 91 25 0a 	lds	r31, 0x0A25
    28f0:	09 95       	icall
}
    28f2:	ff 91       	pop	r31
    28f4:	ef 91       	pop	r30
    28f6:	bf 91       	pop	r27
    28f8:	af 91       	pop	r26
    28fa:	9f 91       	pop	r25
    28fc:	8f 91       	pop	r24
    28fe:	7f 91       	pop	r23
    2900:	6f 91       	pop	r22
    2902:	5f 91       	pop	r21
    2904:	4f 91       	pop	r20
    2906:	3f 91       	pop	r19
    2908:	2f 91       	pop	r18
    290a:	0f 90       	pop	r0
    290c:	0f be       	out	0x3f, r0	; 63
    290e:	0f 90       	pop	r0
    2910:	1f 90       	pop	r1
    2912:	18 95       	reti

00002914 <__vector_31>:
ISR(TIMER3_CAPT_vect)
{
    2914:	1f 92       	push	r1
    2916:	0f 92       	push	r0
    2918:	0f b6       	in	r0, 0x3f	; 63
    291a:	0f 92       	push	r0
    291c:	11 24       	eor	r1, r1
    291e:	2f 93       	push	r18
    2920:	3f 93       	push	r19
    2922:	4f 93       	push	r20
    2924:	5f 93       	push	r21
    2926:	6f 93       	push	r22
    2928:	7f 93       	push	r23
    292a:	8f 93       	push	r24
    292c:	9f 93       	push	r25
    292e:	af 93       	push	r26
    2930:	bf 93       	push	r27
    2932:	ef 93       	push	r30
    2934:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_CAPT_interrupt);
    2936:	80 91 28 0a 	lds	r24, 0x0A28
    293a:	90 91 29 0a 	lds	r25, 0x0A29
    293e:	89 2b       	or	r24, r25
    2940:	29 f0       	breq	.+10     	; 0x294c <__vector_31+0x38>
    2942:	e0 91 28 0a 	lds	r30, 0x0A28
    2946:	f0 91 29 0a 	lds	r31, 0x0A29
    294a:	09 95       	icall
}
    294c:	ff 91       	pop	r31
    294e:	ef 91       	pop	r30
    2950:	bf 91       	pop	r27
    2952:	af 91       	pop	r26
    2954:	9f 91       	pop	r25
    2956:	8f 91       	pop	r24
    2958:	7f 91       	pop	r23
    295a:	6f 91       	pop	r22
    295c:	5f 91       	pop	r21
    295e:	4f 91       	pop	r20
    2960:	3f 91       	pop	r19
    2962:	2f 91       	pop	r18
    2964:	0f 90       	pop	r0
    2966:	0f be       	out	0x3f, r0	; 63
    2968:	0f 90       	pop	r0
    296a:	1f 90       	pop	r1
    296c:	18 95       	reti

0000296e <__vector_32>:
ISR(TIMER3_COMPA_vect)
{
    296e:	1f 92       	push	r1
    2970:	0f 92       	push	r0
    2972:	0f b6       	in	r0, 0x3f	; 63
    2974:	0f 92       	push	r0
    2976:	11 24       	eor	r1, r1
    2978:	2f 93       	push	r18
    297a:	3f 93       	push	r19
    297c:	4f 93       	push	r20
    297e:	5f 93       	push	r21
    2980:	6f 93       	push	r22
    2982:	7f 93       	push	r23
    2984:	8f 93       	push	r24
    2986:	9f 93       	push	r25
    2988:	af 93       	push	r26
    298a:	bf 93       	push	r27
    298c:	ef 93       	push	r30
    298e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPA_interrupt);
    2990:	80 91 2a 0a 	lds	r24, 0x0A2A
    2994:	90 91 2b 0a 	lds	r25, 0x0A2B
    2998:	89 2b       	or	r24, r25
    299a:	29 f0       	breq	.+10     	; 0x29a6 <__vector_32+0x38>
    299c:	e0 91 2a 0a 	lds	r30, 0x0A2A
    29a0:	f0 91 2b 0a 	lds	r31, 0x0A2B
    29a4:	09 95       	icall
}
    29a6:	ff 91       	pop	r31
    29a8:	ef 91       	pop	r30
    29aa:	bf 91       	pop	r27
    29ac:	af 91       	pop	r26
    29ae:	9f 91       	pop	r25
    29b0:	8f 91       	pop	r24
    29b2:	7f 91       	pop	r23
    29b4:	6f 91       	pop	r22
    29b6:	5f 91       	pop	r21
    29b8:	4f 91       	pop	r20
    29ba:	3f 91       	pop	r19
    29bc:	2f 91       	pop	r18
    29be:	0f 90       	pop	r0
    29c0:	0f be       	out	0x3f, r0	; 63
    29c2:	0f 90       	pop	r0
    29c4:	1f 90       	pop	r1
    29c6:	18 95       	reti

000029c8 <__vector_33>:
ISR(TIMER3_COMPB_vect)
{
    29c8:	1f 92       	push	r1
    29ca:	0f 92       	push	r0
    29cc:	0f b6       	in	r0, 0x3f	; 63
    29ce:	0f 92       	push	r0
    29d0:	11 24       	eor	r1, r1
    29d2:	2f 93       	push	r18
    29d4:	3f 93       	push	r19
    29d6:	4f 93       	push	r20
    29d8:	5f 93       	push	r21
    29da:	6f 93       	push	r22
    29dc:	7f 93       	push	r23
    29de:	8f 93       	push	r24
    29e0:	9f 93       	push	r25
    29e2:	af 93       	push	r26
    29e4:	bf 93       	push	r27
    29e6:	ef 93       	push	r30
    29e8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPB_interrupt);
    29ea:	80 91 2c 0a 	lds	r24, 0x0A2C
    29ee:	90 91 2d 0a 	lds	r25, 0x0A2D
    29f2:	89 2b       	or	r24, r25
    29f4:	29 f0       	breq	.+10     	; 0x2a00 <__vector_33+0x38>
    29f6:	e0 91 2c 0a 	lds	r30, 0x0A2C
    29fa:	f0 91 2d 0a 	lds	r31, 0x0A2D
    29fe:	09 95       	icall
}
    2a00:	ff 91       	pop	r31
    2a02:	ef 91       	pop	r30
    2a04:	bf 91       	pop	r27
    2a06:	af 91       	pop	r26
    2a08:	9f 91       	pop	r25
    2a0a:	8f 91       	pop	r24
    2a0c:	7f 91       	pop	r23
    2a0e:	6f 91       	pop	r22
    2a10:	5f 91       	pop	r21
    2a12:	4f 91       	pop	r20
    2a14:	3f 91       	pop	r19
    2a16:	2f 91       	pop	r18
    2a18:	0f 90       	pop	r0
    2a1a:	0f be       	out	0x3f, r0	; 63
    2a1c:	0f 90       	pop	r0
    2a1e:	1f 90       	pop	r1
    2a20:	18 95       	reti

00002a22 <__vector_34>:
ISR(TIMER3_COMPC_vect)
{
    2a22:	1f 92       	push	r1
    2a24:	0f 92       	push	r0
    2a26:	0f b6       	in	r0, 0x3f	; 63
    2a28:	0f 92       	push	r0
    2a2a:	11 24       	eor	r1, r1
    2a2c:	2f 93       	push	r18
    2a2e:	3f 93       	push	r19
    2a30:	4f 93       	push	r20
    2a32:	5f 93       	push	r21
    2a34:	6f 93       	push	r22
    2a36:	7f 93       	push	r23
    2a38:	8f 93       	push	r24
    2a3a:	9f 93       	push	r25
    2a3c:	af 93       	push	r26
    2a3e:	bf 93       	push	r27
    2a40:	ef 93       	push	r30
    2a42:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER3_COMPC_interrupt);
    2a44:	80 91 2e 0a 	lds	r24, 0x0A2E
    2a48:	90 91 2f 0a 	lds	r25, 0x0A2F
    2a4c:	89 2b       	or	r24, r25
    2a4e:	29 f0       	breq	.+10     	; 0x2a5a <__vector_34+0x38>
    2a50:	e0 91 2e 0a 	lds	r30, 0x0A2E
    2a54:	f0 91 2f 0a 	lds	r31, 0x0A2F
    2a58:	09 95       	icall
}
    2a5a:	ff 91       	pop	r31
    2a5c:	ef 91       	pop	r30
    2a5e:	bf 91       	pop	r27
    2a60:	af 91       	pop	r26
    2a62:	9f 91       	pop	r25
    2a64:	8f 91       	pop	r24
    2a66:	7f 91       	pop	r23
    2a68:	6f 91       	pop	r22
    2a6a:	5f 91       	pop	r21
    2a6c:	4f 91       	pop	r20
    2a6e:	3f 91       	pop	r19
    2a70:	2f 91       	pop	r18
    2a72:	0f 90       	pop	r0
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	0f 90       	pop	r0
    2a78:	1f 90       	pop	r1
    2a7a:	18 95       	reti

00002a7c <__vector_41>:
ISR(TIMER4_CAPT_vect)
{
    2a7c:	1f 92       	push	r1
    2a7e:	0f 92       	push	r0
    2a80:	0f b6       	in	r0, 0x3f	; 63
    2a82:	0f 92       	push	r0
    2a84:	11 24       	eor	r1, r1
    2a86:	2f 93       	push	r18
    2a88:	3f 93       	push	r19
    2a8a:	4f 93       	push	r20
    2a8c:	5f 93       	push	r21
    2a8e:	6f 93       	push	r22
    2a90:	7f 93       	push	r23
    2a92:	8f 93       	push	r24
    2a94:	9f 93       	push	r25
    2a96:	af 93       	push	r26
    2a98:	bf 93       	push	r27
    2a9a:	ef 93       	push	r30
    2a9c:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_CAPT_interrupt);
    2a9e:	80 91 32 0a 	lds	r24, 0x0A32
    2aa2:	90 91 33 0a 	lds	r25, 0x0A33
    2aa6:	89 2b       	or	r24, r25
    2aa8:	29 f0       	breq	.+10     	; 0x2ab4 <__vector_41+0x38>
    2aaa:	e0 91 32 0a 	lds	r30, 0x0A32
    2aae:	f0 91 33 0a 	lds	r31, 0x0A33
    2ab2:	09 95       	icall
}
    2ab4:	ff 91       	pop	r31
    2ab6:	ef 91       	pop	r30
    2ab8:	bf 91       	pop	r27
    2aba:	af 91       	pop	r26
    2abc:	9f 91       	pop	r25
    2abe:	8f 91       	pop	r24
    2ac0:	7f 91       	pop	r23
    2ac2:	6f 91       	pop	r22
    2ac4:	5f 91       	pop	r21
    2ac6:	4f 91       	pop	r20
    2ac8:	3f 91       	pop	r19
    2aca:	2f 91       	pop	r18
    2acc:	0f 90       	pop	r0
    2ace:	0f be       	out	0x3f, r0	; 63
    2ad0:	0f 90       	pop	r0
    2ad2:	1f 90       	pop	r1
    2ad4:	18 95       	reti

00002ad6 <__vector_42>:
ISR(TIMER4_COMPA_vect)
{
    2ad6:	1f 92       	push	r1
    2ad8:	0f 92       	push	r0
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	0f 92       	push	r0
    2ade:	11 24       	eor	r1, r1
    2ae0:	2f 93       	push	r18
    2ae2:	3f 93       	push	r19
    2ae4:	4f 93       	push	r20
    2ae6:	5f 93       	push	r21
    2ae8:	6f 93       	push	r22
    2aea:	7f 93       	push	r23
    2aec:	8f 93       	push	r24
    2aee:	9f 93       	push	r25
    2af0:	af 93       	push	r26
    2af2:	bf 93       	push	r27
    2af4:	ef 93       	push	r30
    2af6:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPA_interrupt);
    2af8:	80 91 34 0a 	lds	r24, 0x0A34
    2afc:	90 91 35 0a 	lds	r25, 0x0A35
    2b00:	89 2b       	or	r24, r25
    2b02:	29 f0       	breq	.+10     	; 0x2b0e <__vector_42+0x38>
    2b04:	e0 91 34 0a 	lds	r30, 0x0A34
    2b08:	f0 91 35 0a 	lds	r31, 0x0A35
    2b0c:	09 95       	icall
}
    2b0e:	ff 91       	pop	r31
    2b10:	ef 91       	pop	r30
    2b12:	bf 91       	pop	r27
    2b14:	af 91       	pop	r26
    2b16:	9f 91       	pop	r25
    2b18:	8f 91       	pop	r24
    2b1a:	7f 91       	pop	r23
    2b1c:	6f 91       	pop	r22
    2b1e:	5f 91       	pop	r21
    2b20:	4f 91       	pop	r20
    2b22:	3f 91       	pop	r19
    2b24:	2f 91       	pop	r18
    2b26:	0f 90       	pop	r0
    2b28:	0f be       	out	0x3f, r0	; 63
    2b2a:	0f 90       	pop	r0
    2b2c:	1f 90       	pop	r1
    2b2e:	18 95       	reti

00002b30 <__vector_43>:
ISR(TIMER4_COMPB_vect)
{
    2b30:	1f 92       	push	r1
    2b32:	0f 92       	push	r0
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	0f 92       	push	r0
    2b38:	11 24       	eor	r1, r1
    2b3a:	2f 93       	push	r18
    2b3c:	3f 93       	push	r19
    2b3e:	4f 93       	push	r20
    2b40:	5f 93       	push	r21
    2b42:	6f 93       	push	r22
    2b44:	7f 93       	push	r23
    2b46:	8f 93       	push	r24
    2b48:	9f 93       	push	r25
    2b4a:	af 93       	push	r26
    2b4c:	bf 93       	push	r27
    2b4e:	ef 93       	push	r30
    2b50:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPB_interrupt);
    2b52:	80 91 36 0a 	lds	r24, 0x0A36
    2b56:	90 91 37 0a 	lds	r25, 0x0A37
    2b5a:	89 2b       	or	r24, r25
    2b5c:	29 f0       	breq	.+10     	; 0x2b68 <__vector_43+0x38>
    2b5e:	e0 91 36 0a 	lds	r30, 0x0A36
    2b62:	f0 91 37 0a 	lds	r31, 0x0A37
    2b66:	09 95       	icall
}
    2b68:	ff 91       	pop	r31
    2b6a:	ef 91       	pop	r30
    2b6c:	bf 91       	pop	r27
    2b6e:	af 91       	pop	r26
    2b70:	9f 91       	pop	r25
    2b72:	8f 91       	pop	r24
    2b74:	7f 91       	pop	r23
    2b76:	6f 91       	pop	r22
    2b78:	5f 91       	pop	r21
    2b7a:	4f 91       	pop	r20
    2b7c:	3f 91       	pop	r19
    2b7e:	2f 91       	pop	r18
    2b80:	0f 90       	pop	r0
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	0f 90       	pop	r0
    2b86:	1f 90       	pop	r1
    2b88:	18 95       	reti

00002b8a <__vector_44>:
ISR(TIMER4_COMPC_vect)
{
    2b8a:	1f 92       	push	r1
    2b8c:	0f 92       	push	r0
    2b8e:	0f b6       	in	r0, 0x3f	; 63
    2b90:	0f 92       	push	r0
    2b92:	11 24       	eor	r1, r1
    2b94:	2f 93       	push	r18
    2b96:	3f 93       	push	r19
    2b98:	4f 93       	push	r20
    2b9a:	5f 93       	push	r21
    2b9c:	6f 93       	push	r22
    2b9e:	7f 93       	push	r23
    2ba0:	8f 93       	push	r24
    2ba2:	9f 93       	push	r25
    2ba4:	af 93       	push	r26
    2ba6:	bf 93       	push	r27
    2ba8:	ef 93       	push	r30
    2baa:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER4_COMPC_interrupt);
    2bac:	80 91 38 0a 	lds	r24, 0x0A38
    2bb0:	90 91 39 0a 	lds	r25, 0x0A39
    2bb4:	89 2b       	or	r24, r25
    2bb6:	29 f0       	breq	.+10     	; 0x2bc2 <__vector_44+0x38>
    2bb8:	e0 91 38 0a 	lds	r30, 0x0A38
    2bbc:	f0 91 39 0a 	lds	r31, 0x0A39
    2bc0:	09 95       	icall
}
    2bc2:	ff 91       	pop	r31
    2bc4:	ef 91       	pop	r30
    2bc6:	bf 91       	pop	r27
    2bc8:	af 91       	pop	r26
    2bca:	9f 91       	pop	r25
    2bcc:	8f 91       	pop	r24
    2bce:	7f 91       	pop	r23
    2bd0:	6f 91       	pop	r22
    2bd2:	5f 91       	pop	r21
    2bd4:	4f 91       	pop	r20
    2bd6:	3f 91       	pop	r19
    2bd8:	2f 91       	pop	r18
    2bda:	0f 90       	pop	r0
    2bdc:	0f be       	out	0x3f, r0	; 63
    2bde:	0f 90       	pop	r0
    2be0:	1f 90       	pop	r1
    2be2:	18 95       	reti

00002be4 <__vector_46>:
ISR(TIMER5_CAPT_vect)
{
    2be4:	1f 92       	push	r1
    2be6:	0f 92       	push	r0
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	0f 92       	push	r0
    2bec:	11 24       	eor	r1, r1
    2bee:	2f 93       	push	r18
    2bf0:	3f 93       	push	r19
    2bf2:	4f 93       	push	r20
    2bf4:	5f 93       	push	r21
    2bf6:	6f 93       	push	r22
    2bf8:	7f 93       	push	r23
    2bfa:	8f 93       	push	r24
    2bfc:	9f 93       	push	r25
    2bfe:	af 93       	push	r26
    2c00:	bf 93       	push	r27
    2c02:	ef 93       	push	r30
    2c04:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_CAPT_interrupt);
    2c06:	80 91 3c 0a 	lds	r24, 0x0A3C
    2c0a:	90 91 3d 0a 	lds	r25, 0x0A3D
    2c0e:	89 2b       	or	r24, r25
    2c10:	29 f0       	breq	.+10     	; 0x2c1c <__vector_46+0x38>
    2c12:	e0 91 3c 0a 	lds	r30, 0x0A3C
    2c16:	f0 91 3d 0a 	lds	r31, 0x0A3D
    2c1a:	09 95       	icall
}
    2c1c:	ff 91       	pop	r31
    2c1e:	ef 91       	pop	r30
    2c20:	bf 91       	pop	r27
    2c22:	af 91       	pop	r26
    2c24:	9f 91       	pop	r25
    2c26:	8f 91       	pop	r24
    2c28:	7f 91       	pop	r23
    2c2a:	6f 91       	pop	r22
    2c2c:	5f 91       	pop	r21
    2c2e:	4f 91       	pop	r20
    2c30:	3f 91       	pop	r19
    2c32:	2f 91       	pop	r18
    2c34:	0f 90       	pop	r0
    2c36:	0f be       	out	0x3f, r0	; 63
    2c38:	0f 90       	pop	r0
    2c3a:	1f 90       	pop	r1
    2c3c:	18 95       	reti

00002c3e <__vector_47>:
ISR(TIMER5_COMPA_vect)
{
    2c3e:	1f 92       	push	r1
    2c40:	0f 92       	push	r0
    2c42:	0f b6       	in	r0, 0x3f	; 63
    2c44:	0f 92       	push	r0
    2c46:	11 24       	eor	r1, r1
    2c48:	2f 93       	push	r18
    2c4a:	3f 93       	push	r19
    2c4c:	4f 93       	push	r20
    2c4e:	5f 93       	push	r21
    2c50:	6f 93       	push	r22
    2c52:	7f 93       	push	r23
    2c54:	8f 93       	push	r24
    2c56:	9f 93       	push	r25
    2c58:	af 93       	push	r26
    2c5a:	bf 93       	push	r27
    2c5c:	ef 93       	push	r30
    2c5e:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPA_interrupt);
    2c60:	80 91 3e 0a 	lds	r24, 0x0A3E
    2c64:	90 91 3f 0a 	lds	r25, 0x0A3F
    2c68:	89 2b       	or	r24, r25
    2c6a:	29 f0       	breq	.+10     	; 0x2c76 <__vector_47+0x38>
    2c6c:	e0 91 3e 0a 	lds	r30, 0x0A3E
    2c70:	f0 91 3f 0a 	lds	r31, 0x0A3F
    2c74:	09 95       	icall
}
    2c76:	ff 91       	pop	r31
    2c78:	ef 91       	pop	r30
    2c7a:	bf 91       	pop	r27
    2c7c:	af 91       	pop	r26
    2c7e:	9f 91       	pop	r25
    2c80:	8f 91       	pop	r24
    2c82:	7f 91       	pop	r23
    2c84:	6f 91       	pop	r22
    2c86:	5f 91       	pop	r21
    2c88:	4f 91       	pop	r20
    2c8a:	3f 91       	pop	r19
    2c8c:	2f 91       	pop	r18
    2c8e:	0f 90       	pop	r0
    2c90:	0f be       	out	0x3f, r0	; 63
    2c92:	0f 90       	pop	r0
    2c94:	1f 90       	pop	r1
    2c96:	18 95       	reti

00002c98 <__vector_48>:
ISR(TIMER5_COMPB_vect)
{
    2c98:	1f 92       	push	r1
    2c9a:	0f 92       	push	r0
    2c9c:	0f b6       	in	r0, 0x3f	; 63
    2c9e:	0f 92       	push	r0
    2ca0:	11 24       	eor	r1, r1
    2ca2:	2f 93       	push	r18
    2ca4:	3f 93       	push	r19
    2ca6:	4f 93       	push	r20
    2ca8:	5f 93       	push	r21
    2caa:	6f 93       	push	r22
    2cac:	7f 93       	push	r23
    2cae:	8f 93       	push	r24
    2cb0:	9f 93       	push	r25
    2cb2:	af 93       	push	r26
    2cb4:	bf 93       	push	r27
    2cb6:	ef 93       	push	r30
    2cb8:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPB_interrupt);
    2cba:	80 91 40 0a 	lds	r24, 0x0A40
    2cbe:	90 91 41 0a 	lds	r25, 0x0A41
    2cc2:	89 2b       	or	r24, r25
    2cc4:	29 f0       	breq	.+10     	; 0x2cd0 <__vector_48+0x38>
    2cc6:	e0 91 40 0a 	lds	r30, 0x0A40
    2cca:	f0 91 41 0a 	lds	r31, 0x0A41
    2cce:	09 95       	icall
}
    2cd0:	ff 91       	pop	r31
    2cd2:	ef 91       	pop	r30
    2cd4:	bf 91       	pop	r27
    2cd6:	af 91       	pop	r26
    2cd8:	9f 91       	pop	r25
    2cda:	8f 91       	pop	r24
    2cdc:	7f 91       	pop	r23
    2cde:	6f 91       	pop	r22
    2ce0:	5f 91       	pop	r21
    2ce2:	4f 91       	pop	r20
    2ce4:	3f 91       	pop	r19
    2ce6:	2f 91       	pop	r18
    2ce8:	0f 90       	pop	r0
    2cea:	0f be       	out	0x3f, r0	; 63
    2cec:	0f 90       	pop	r0
    2cee:	1f 90       	pop	r1
    2cf0:	18 95       	reti

00002cf2 <__vector_49>:
ISR(TIMER5_COMPC_vect)
{
    2cf2:	1f 92       	push	r1
    2cf4:	0f 92       	push	r0
    2cf6:	0f b6       	in	r0, 0x3f	; 63
    2cf8:	0f 92       	push	r0
    2cfa:	11 24       	eor	r1, r1
    2cfc:	2f 93       	push	r18
    2cfe:	3f 93       	push	r19
    2d00:	4f 93       	push	r20
    2d02:	5f 93       	push	r21
    2d04:	6f 93       	push	r22
    2d06:	7f 93       	push	r23
    2d08:	8f 93       	push	r24
    2d0a:	9f 93       	push	r25
    2d0c:	af 93       	push	r26
    2d0e:	bf 93       	push	r27
    2d10:	ef 93       	push	r30
    2d12:	ff 93       	push	r31
  RUN_USER_DEFINE_INTERRUPT(TIMER5_COMPC_interrupt);
    2d14:	80 91 42 0a 	lds	r24, 0x0A42
    2d18:	90 91 43 0a 	lds	r25, 0x0A43
    2d1c:	89 2b       	or	r24, r25
    2d1e:	29 f0       	breq	.+10     	; 0x2d2a <__vector_49+0x38>
    2d20:	e0 91 42 0a 	lds	r30, 0x0A42
    2d24:	f0 91 43 0a 	lds	r31, 0x0A43
    2d28:	09 95       	icall
}
    2d2a:	ff 91       	pop	r31
    2d2c:	ef 91       	pop	r30
    2d2e:	bf 91       	pop	r27
    2d30:	af 91       	pop	r26
    2d32:	9f 91       	pop	r25
    2d34:	8f 91       	pop	r24
    2d36:	7f 91       	pop	r23
    2d38:	6f 91       	pop	r22
    2d3a:	5f 91       	pop	r21
    2d3c:	4f 91       	pop	r20
    2d3e:	3f 91       	pop	r19
    2d40:	2f 91       	pop	r18
    2d42:	0f 90       	pop	r0
    2d44:	0f be       	out	0x3f, r0	; 63
    2d46:	0f 90       	pop	r0
    2d48:	1f 90       	pop	r1
    2d4a:	18 95       	reti

00002d4c <__vector_default>:

ISR(BADISR_vect)
{
    2d4c:	1f 92       	push	r1
    2d4e:	0f 92       	push	r0
    2d50:	0f b6       	in	r0, 0x3f	; 63
    2d52:	0f 92       	push	r0
    2d54:	11 24       	eor	r1, r1
    2d56:	2f 93       	push	r18
    2d58:	3f 93       	push	r19
    2d5a:	4f 93       	push	r20
    2d5c:	5f 93       	push	r21
    2d5e:	6f 93       	push	r22
    2d60:	7f 93       	push	r23
    2d62:	8f 93       	push	r24
    2d64:	9f 93       	push	r25
    2d66:	af 93       	push	r26
    2d68:	bf 93       	push	r27
    2d6a:	ef 93       	push	r30
    2d6c:	ff 93       	push	r31
  rprintf("BAD_vect called!");
    2d6e:	00 d0       	rcall	.+0      	; 0x2d70 <__vector_default+0x24>
    2d70:	0f 92       	push	r0
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	ed b7       	in	r30, 0x3d	; 61
    2d76:	fe b7       	in	r31, 0x3e	; 62
    2d78:	81 83       	std	Z+1, r24	; 0x01
    2d7a:	8d e1       	ldi	r24, 0x1D	; 29
    2d7c:	91 e0       	ldi	r25, 0x01	; 1
    2d7e:	93 83       	std	Z+3, r25	; 0x03
    2d80:	82 83       	std	Z+2, r24	; 0x02
    2d82:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <rprintf1RamRom>
    2d86:	0f 90       	pop	r0
    2d88:	0f 90       	pop	r0
    2d8a:	0f 90       	pop	r0
}
    2d8c:	ff 91       	pop	r31
    2d8e:	ef 91       	pop	r30
    2d90:	bf 91       	pop	r27
    2d92:	af 91       	pop	r26
    2d94:	9f 91       	pop	r25
    2d96:	8f 91       	pop	r24
    2d98:	7f 91       	pop	r23
    2d9a:	6f 91       	pop	r22
    2d9c:	5f 91       	pop	r21
    2d9e:	4f 91       	pop	r20
    2da0:	3f 91       	pop	r19
    2da2:	2f 91       	pop	r18
    2da4:	0f 90       	pop	r0
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	0f 90       	pop	r0
    2daa:	1f 90       	pop	r1
    2dac:	18 95       	reti

00002dae <uartSetRxHandler>:
}

void uartSetRxHandler(u08 nUart, void (*rx_func)(unsigned char c))
{
	// make sure the uart number is within bounds
	if(nUart < 4)
    2dae:	84 30       	cpi	r24, 0x04	; 4
    2db0:	40 f4       	brcc	.+16     	; 0x2dc2 <uartSetRxHandler+0x14>
	{
		// set the receive interrupt to run the supplied user function
		UartRxFunc[nUart] = rx_func;
    2db2:	e8 2f       	mov	r30, r24
    2db4:	f0 e0       	ldi	r31, 0x00	; 0
    2db6:	ee 0f       	add	r30, r30
    2db8:	ff 1f       	adc	r31, r31
    2dba:	ea 57       	subi	r30, 0x7A	; 122
    2dbc:	f3 4f       	sbci	r31, 0xF3	; 243
    2dbe:	71 83       	std	Z+1, r23	; 0x01
    2dc0:	60 83       	st	Z, r22
    2dc2:	08 95       	ret

00002dc4 <uartSetBaudRate>:
	}
}

void uartSetBaudRate(u08 nUart, u32 baudrate)
{
    2dc4:	1f 93       	push	r17
    2dc6:	18 2f       	mov	r17, r24
    2dc8:	9a 01       	movw	r18, r20
    2dca:	ab 01       	movw	r20, r22
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(baudrate*8L))/(baudrate*16L)-1);
    2dcc:	ca 01       	movw	r24, r20
    2dce:	b9 01       	movw	r22, r18
    2dd0:	60 58       	subi	r22, 0x80	; 128
    2dd2:	7b 47       	sbci	r23, 0x7B	; 123
    2dd4:	81 4e       	sbci	r24, 0xE1	; 225
    2dd6:	9f 4f       	sbci	r25, 0xFF	; 255
    2dd8:	f3 e0       	ldi	r31, 0x03	; 3
    2dda:	66 0f       	add	r22, r22
    2ddc:	77 1f       	adc	r23, r23
    2dde:	88 1f       	adc	r24, r24
    2de0:	99 1f       	adc	r25, r25
    2de2:	fa 95       	dec	r31
    2de4:	d1 f7       	brne	.-12     	; 0x2dda <uartSetBaudRate+0x16>
    2de6:	e4 e0       	ldi	r30, 0x04	; 4
    2de8:	22 0f       	add	r18, r18
    2dea:	33 1f       	adc	r19, r19
    2dec:	44 1f       	adc	r20, r20
    2dee:	55 1f       	adc	r21, r21
    2df0:	ea 95       	dec	r30
    2df2:	d1 f7       	brne	.-12     	; 0x2de8 <uartSetBaudRate+0x24>
    2df4:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <__udivmodsi4>
    2df8:	21 50       	subi	r18, 0x01	; 1
    2dfa:	30 40       	sbci	r19, 0x00	; 0
	if(nUart==3)
    2dfc:	13 30       	cpi	r17, 0x03	; 3
    2dfe:	29 f4       	brne	.+10     	; 0x2e0a <uartSetBaudRate+0x46>
	{
		outb(UBRR3L, bauddiv);
    2e00:	20 93 34 01 	sts	0x0134, r18
		#ifdef UBRR3H
		outb(UBRR3H, bauddiv>>8);
    2e04:	30 93 35 01 	sts	0x0135, r19
    2e08:	12 c0       	rjmp	.+36     	; 0x2e2e <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==2)
    2e0a:	12 30       	cpi	r17, 0x02	; 2
    2e0c:	29 f4       	brne	.+10     	; 0x2e18 <uartSetBaudRate+0x54>
	{
		outb(UBRR2L, bauddiv);
    2e0e:	20 93 d4 00 	sts	0x00D4, r18
		#ifdef UBRR2H
		outb(UBRR2H, bauddiv>>8);
    2e12:	30 93 d5 00 	sts	0x00D5, r19
    2e16:	0b c0       	rjmp	.+22     	; 0x2e2e <uartSetBaudRate+0x6a>
		#endif
	}
	else if(nUart==1)
    2e18:	11 30       	cpi	r17, 0x01	; 1
    2e1a:	29 f4       	brne	.+10     	; 0x2e26 <uartSetBaudRate+0x62>
	{
		outb(UBRR1L, bauddiv);
    2e1c:	20 93 cc 00 	sts	0x00CC, r18
		#ifdef UBRR1H
		outb(UBRR1H, bauddiv>>8);
    2e20:	30 93 cd 00 	sts	0x00CD, r19
    2e24:	04 c0       	rjmp	.+8      	; 0x2e2e <uartSetBaudRate+0x6a>
		#endif
	}
	else
	{
		outb(UBRR0L, bauddiv);
    2e26:	20 93 c4 00 	sts	0x00C4, r18
		#ifdef UBRR0H
		outb(UBRR0H, bauddiv>>8);
    2e2a:	30 93 c5 00 	sts	0x00C5, r19
		#endif
	}
}
    2e2e:	1f 91       	pop	r17
    2e30:	08 95       	ret

00002e32 <uartGetRxBuffer>:

cBuffer* uartGetRxBuffer(u08 nUart)
{
    2e32:	28 2f       	mov	r18, r24
    2e34:	30 e0       	ldi	r19, 0x00	; 0
    2e36:	a3 e0       	ldi	r26, 0x03	; 3
    2e38:	22 0f       	add	r18, r18
    2e3a:	33 1f       	adc	r19, r19
    2e3c:	aa 95       	dec	r26
    2e3e:	e1 f7       	brne	.-8      	; 0x2e38 <uartGetRxBuffer+0x6>
    2e40:	20 55       	subi	r18, 0x50	; 80
    2e42:	33 4f       	sbci	r19, 0xF3	; 243
	// return rx buffer pointer
	return &uartRxBuffer[nUart];
}
    2e44:	c9 01       	movw	r24, r18
    2e46:	08 95       	ret

00002e48 <uartGetTxBuffer>:

cBuffer* uartGetTxBuffer(u08 nUart)
{
    2e48:	28 2f       	mov	r18, r24
    2e4a:	30 e0       	ldi	r19, 0x00	; 0
    2e4c:	b3 e0       	ldi	r27, 0x03	; 3
    2e4e:	22 0f       	add	r18, r18
    2e50:	33 1f       	adc	r19, r19
    2e52:	ba 95       	dec	r27
    2e54:	e1 f7       	brne	.-8      	; 0x2e4e <uartGetTxBuffer+0x6>
    2e56:	2c 52       	subi	r18, 0x2C	; 44
    2e58:	33 4f       	sbci	r19, 0xF3	; 243
	// return tx buffer pointer
	return &uartTxBuffer[nUart];
}
    2e5a:	c9 01       	movw	r24, r18
    2e5c:	08 95       	ret

00002e5e <uartSendByte>:

void uartSendByte(u08 nUart, u08 txData)
{
    2e5e:	e8 2f       	mov	r30, r24
	// wait for the transmitter to be ready
//	while(!uartReadyTx[nUart]);
	// send byte
	if(nUart==3)
    2e60:	83 30       	cpi	r24, 0x03	; 3
    2e62:	39 f4       	brne	.+14     	; 0x2e72 <uartSendByte+0x14>
	{
		while(!(UCSR3A & (1<<UDRE3)));
    2e64:	80 91 30 01 	lds	r24, 0x0130
    2e68:	85 ff       	sbrs	r24, 5
    2e6a:	fc cf       	rjmp	.-8      	; 0x2e64 <uartSendByte+0x6>
		outb(UDR3, txData);
    2e6c:	60 93 36 01 	sts	0x0136, r22
    2e70:	18 c0       	rjmp	.+48     	; 0x2ea2 <uartSendByte+0x44>
	}
	else if(nUart==2)
    2e72:	82 30       	cpi	r24, 0x02	; 2
    2e74:	39 f4       	brne	.+14     	; 0x2e84 <uartSendByte+0x26>
	{
		while(!(UCSR2A & (1<<UDRE2)));
    2e76:	80 91 d0 00 	lds	r24, 0x00D0
    2e7a:	85 ff       	sbrs	r24, 5
    2e7c:	fc cf       	rjmp	.-8      	; 0x2e76 <uartSendByte+0x18>
		outb(UDR2, txData);
    2e7e:	60 93 d6 00 	sts	0x00D6, r22
    2e82:	0f c0       	rjmp	.+30     	; 0x2ea2 <uartSendByte+0x44>
	}
	else if(nUart==1)
    2e84:	81 30       	cpi	r24, 0x01	; 1
    2e86:	39 f4       	brne	.+14     	; 0x2e96 <uartSendByte+0x38>
	{
		while(!(UCSR1A & (1<<UDRE1)));
    2e88:	80 91 c8 00 	lds	r24, 0x00C8
    2e8c:	85 ff       	sbrs	r24, 5
    2e8e:	fc cf       	rjmp	.-8      	; 0x2e88 <uartSendByte+0x2a>
		outb(UDR1, txData);
    2e90:	60 93 ce 00 	sts	0x00CE, r22
    2e94:	06 c0       	rjmp	.+12     	; 0x2ea2 <uartSendByte+0x44>
	}
	else
	{
		while(!(UCSR0A & (1<<UDRE0)));
    2e96:	80 91 c0 00 	lds	r24, 0x00C0
    2e9a:	85 ff       	sbrs	r24, 5
    2e9c:	fc cf       	rjmp	.-8      	; 0x2e96 <uartSendByte+0x38>
		outb(UDR0, txData);
    2e9e:	60 93 c6 00 	sts	0x00C6, r22
	}
	// set ready state to FALSE
	uartReadyTx[nUart] = FALSE;
    2ea2:	f0 e0       	ldi	r31, 0x00	; 0
    2ea4:	e4 55       	subi	r30, 0x54	; 84
    2ea6:	f3 4f       	sbci	r31, 0xF3	; 243
    2ea8:	10 82       	st	Z, r1
}
    2eaa:	08 95       	ret

00002eac <uart0SendByte>:

void uart0SendByte(u08 data)
{
    2eac:	68 2f       	mov	r22, r24
	// send byte on UART0
	uartSendByte(0, data);
    2eae:	80 e0       	ldi	r24, 0x00	; 0
    2eb0:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
}
    2eb4:	08 95       	ret

00002eb6 <uart1SendByte>:

void uart1SendByte(u08 data)
{
    2eb6:	68 2f       	mov	r22, r24
	// send byte on UART1
	uartSendByte(1, data);
    2eb8:	81 e0       	ldi	r24, 0x01	; 1
    2eba:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
}
    2ebe:	08 95       	ret

00002ec0 <uart2SendByte>:

void uart2SendByte(u08 data)
{
    2ec0:	68 2f       	mov	r22, r24
	// send byte on UART2
	uartSendByte(2, data);
    2ec2:	82 e0       	ldi	r24, 0x02	; 2
    2ec4:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
}
    2ec8:	08 95       	ret

00002eca <uart3SendByte>:

void uart3SendByte(u08 data)
{
    2eca:	68 2f       	mov	r22, r24
	// send byte on UART3
	uartSendByte(3, data);
    2ecc:	83 e0       	ldi	r24, 0x03	; 3
    2ece:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
}
    2ed2:	08 95       	ret

00002ed4 <uartReceiveBufferIsEmpty>:
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
}

u08 uartReceiveBufferIsEmpty(u08 nUart)
{
    2ed4:	20 e0       	ldi	r18, 0x00	; 0
    2ed6:	e8 2f       	mov	r30, r24
    2ed8:	f0 e0       	ldi	r31, 0x00	; 0
    2eda:	83 e0       	ldi	r24, 0x03	; 3
    2edc:	ee 0f       	add	r30, r30
    2ede:	ff 1f       	adc	r31, r31
    2ee0:	8a 95       	dec	r24
    2ee2:	e1 f7       	brne	.-8      	; 0x2edc <uartReceiveBufferIsEmpty+0x8>
    2ee4:	ec 54       	subi	r30, 0x4C	; 76
    2ee6:	f3 4f       	sbci	r31, 0xF3	; 243
    2ee8:	80 81       	ld	r24, Z
    2eea:	91 81       	ldd	r25, Z+1	; 0x01
    2eec:	89 2b       	or	r24, r25
    2eee:	09 f4       	brne	.+2      	; 0x2ef2 <uartReceiveBufferIsEmpty+0x1e>
    2ef0:	21 e0       	ldi	r18, 0x01	; 1
	return (uartRxBuffer[nUart].datalength == 0);
}
    2ef2:	82 2f       	mov	r24, r18
    2ef4:	08 95       	ret

00002ef6 <uartReceiveService>:
	}
}

// UART Receive Complete Interrupt Function
void uartReceiveService(u08 nUart)
{
    2ef6:	cf 93       	push	r28
    2ef8:	df 93       	push	r29
	u08 c;
	// get received char
	if(nUart==3)
    2efa:	83 30       	cpi	r24, 0x03	; 3
    2efc:	19 f4       	brne	.+6      	; 0x2f04 <uartReceiveService+0xe>
		c = inb(UDR3);
    2efe:	60 91 36 01 	lds	r22, 0x0136
    2f02:	0c c0       	rjmp	.+24     	; 0x2f1c <uartReceiveService+0x26>
	else if(nUart==2)
    2f04:	82 30       	cpi	r24, 0x02	; 2
    2f06:	19 f4       	brne	.+6      	; 0x2f0e <uartReceiveService+0x18>
		c = inb(UDR2);
    2f08:	60 91 d6 00 	lds	r22, 0x00D6
    2f0c:	07 c0       	rjmp	.+14     	; 0x2f1c <uartReceiveService+0x26>
	else if(nUart==1)
    2f0e:	81 30       	cpi	r24, 0x01	; 1
    2f10:	19 f4       	brne	.+6      	; 0x2f18 <uartReceiveService+0x22>
		c = inb(UDR1);
    2f12:	60 91 ce 00 	lds	r22, 0x00CE
    2f16:	02 c0       	rjmp	.+4      	; 0x2f1c <uartReceiveService+0x26>
	else
		c = inb(UDR0);
    2f18:	60 91 c6 00 	lds	r22, 0x00C6

	// if there's a user function to handle this receive event
	if(UartRxFunc[nUart])
    2f1c:	28 2f       	mov	r18, r24
    2f1e:	30 e0       	ldi	r19, 0x00	; 0
    2f20:	e9 01       	movw	r28, r18
    2f22:	cc 0f       	add	r28, r28
    2f24:	dd 1f       	adc	r29, r29
    2f26:	fe 01       	movw	r30, r28
    2f28:	ea 57       	subi	r30, 0x7A	; 122
    2f2a:	f3 4f       	sbci	r31, 0xF3	; 243
    2f2c:	80 81       	ld	r24, Z
    2f2e:	91 81       	ldd	r25, Z+1	; 0x01
    2f30:	89 2b       	or	r24, r25
    2f32:	31 f0       	breq	.+12     	; 0x2f40 <uartReceiveService+0x4a>
	{
		// call it and pass the received data
		UartRxFunc[nUart](c);
    2f34:	01 90       	ld	r0, Z+
    2f36:	f0 81       	ld	r31, Z
    2f38:	e0 2d       	mov	r30, r0
    2f3a:	86 2f       	mov	r24, r22
    2f3c:	09 95       	icall
    2f3e:	14 c0       	rjmp	.+40     	; 0x2f68 <uartReceiveService+0x72>
	else
	{
		// otherwise do default processing
		// put received char in buffer
		// check if there's space
		if( !bufferAddToEnd(&uartRxBuffer[nUart], c) )
    2f40:	93 e0       	ldi	r25, 0x03	; 3
    2f42:	22 0f       	add	r18, r18
    2f44:	33 1f       	adc	r19, r19
    2f46:	9a 95       	dec	r25
    2f48:	e1 f7       	brne	.-8      	; 0x2f42 <uartReceiveService+0x4c>
    2f4a:	c9 01       	movw	r24, r18
    2f4c:	80 55       	subi	r24, 0x50	; 80
    2f4e:	93 4f       	sbci	r25, 0xF3	; 243
    2f50:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
    2f54:	88 23       	and	r24, r24
    2f56:	41 f4       	brne	.+16     	; 0x2f68 <uartReceiveService+0x72>
		{
			// no space in buffer
			// count overflow
			uartRxOverflow[nUart]++;
    2f58:	fe 01       	movw	r30, r28
    2f5a:	ec 50       	subi	r30, 0x0C	; 12
    2f5c:	f3 4f       	sbci	r31, 0xF3	; 243
    2f5e:	80 81       	ld	r24, Z
    2f60:	91 81       	ldd	r25, Z+1	; 0x01
    2f62:	01 96       	adiw	r24, 0x01	; 1
    2f64:	91 83       	std	Z+1, r25	; 0x01
    2f66:	80 83       	st	Z, r24
		}
	}
}
    2f68:	df 91       	pop	r29
    2f6a:	cf 91       	pop	r28
    2f6c:	08 95       	ret

00002f6e <__vector_54>:
{
	uartReceiveService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_RECV)      
{
    2f6e:	1f 92       	push	r1
    2f70:	0f 92       	push	r0
    2f72:	0f b6       	in	r0, 0x3f	; 63
    2f74:	0f 92       	push	r0
    2f76:	11 24       	eor	r1, r1
    2f78:	2f 93       	push	r18
    2f7a:	3f 93       	push	r19
    2f7c:	4f 93       	push	r20
    2f7e:	5f 93       	push	r21
    2f80:	6f 93       	push	r22
    2f82:	7f 93       	push	r23
    2f84:	8f 93       	push	r24
    2f86:	9f 93       	push	r25
    2f88:	af 93       	push	r26
    2f8a:	bf 93       	push	r27
    2f8c:	ef 93       	push	r30
    2f8e:	ff 93       	push	r31
	uartReceiveService(3);
    2f90:	83 e0       	ldi	r24, 0x03	; 3
    2f92:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <uartReceiveService>
}
    2f96:	ff 91       	pop	r31
    2f98:	ef 91       	pop	r30
    2f9a:	bf 91       	pop	r27
    2f9c:	af 91       	pop	r26
    2f9e:	9f 91       	pop	r25
    2fa0:	8f 91       	pop	r24
    2fa2:	7f 91       	pop	r23
    2fa4:	6f 91       	pop	r22
    2fa6:	5f 91       	pop	r21
    2fa8:	4f 91       	pop	r20
    2faa:	3f 91       	pop	r19
    2fac:	2f 91       	pop	r18
    2fae:	0f 90       	pop	r0
    2fb0:	0f be       	out	0x3f, r0	; 63
    2fb2:	0f 90       	pop	r0
    2fb4:	1f 90       	pop	r1
    2fb6:	18 95       	reti

00002fb8 <__vector_51>:
{
	uartReceiveService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_RECV)      
{
    2fb8:	1f 92       	push	r1
    2fba:	0f 92       	push	r0
    2fbc:	0f b6       	in	r0, 0x3f	; 63
    2fbe:	0f 92       	push	r0
    2fc0:	11 24       	eor	r1, r1
    2fc2:	2f 93       	push	r18
    2fc4:	3f 93       	push	r19
    2fc6:	4f 93       	push	r20
    2fc8:	5f 93       	push	r21
    2fca:	6f 93       	push	r22
    2fcc:	7f 93       	push	r23
    2fce:	8f 93       	push	r24
    2fd0:	9f 93       	push	r25
    2fd2:	af 93       	push	r26
    2fd4:	bf 93       	push	r27
    2fd6:	ef 93       	push	r30
    2fd8:	ff 93       	push	r31
	uartReceiveService(2);
    2fda:	82 e0       	ldi	r24, 0x02	; 2
    2fdc:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <uartReceiveService>
}
    2fe0:	ff 91       	pop	r31
    2fe2:	ef 91       	pop	r30
    2fe4:	bf 91       	pop	r27
    2fe6:	af 91       	pop	r26
    2fe8:	9f 91       	pop	r25
    2fea:	8f 91       	pop	r24
    2fec:	7f 91       	pop	r23
    2fee:	6f 91       	pop	r22
    2ff0:	5f 91       	pop	r21
    2ff2:	4f 91       	pop	r20
    2ff4:	3f 91       	pop	r19
    2ff6:	2f 91       	pop	r18
    2ff8:	0f 90       	pop	r0
    2ffa:	0f be       	out	0x3f, r0	; 63
    2ffc:	0f 90       	pop	r0
    2ffe:	1f 90       	pop	r1
    3000:	18 95       	reti

00003002 <__vector_36>:
{
	uartReceiveService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_RECV)      
{
    3002:	1f 92       	push	r1
    3004:	0f 92       	push	r0
    3006:	0f b6       	in	r0, 0x3f	; 63
    3008:	0f 92       	push	r0
    300a:	11 24       	eor	r1, r1
    300c:	2f 93       	push	r18
    300e:	3f 93       	push	r19
    3010:	4f 93       	push	r20
    3012:	5f 93       	push	r21
    3014:	6f 93       	push	r22
    3016:	7f 93       	push	r23
    3018:	8f 93       	push	r24
    301a:	9f 93       	push	r25
    301c:	af 93       	push	r26
    301e:	bf 93       	push	r27
    3020:	ef 93       	push	r30
    3022:	ff 93       	push	r31
	uartReceiveService(1);
    3024:	81 e0       	ldi	r24, 0x01	; 1
    3026:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <uartReceiveService>
}
    302a:	ff 91       	pop	r31
    302c:	ef 91       	pop	r30
    302e:	bf 91       	pop	r27
    3030:	af 91       	pop	r26
    3032:	9f 91       	pop	r25
    3034:	8f 91       	pop	r24
    3036:	7f 91       	pop	r23
    3038:	6f 91       	pop	r22
    303a:	5f 91       	pop	r21
    303c:	4f 91       	pop	r20
    303e:	3f 91       	pop	r19
    3040:	2f 91       	pop	r18
    3042:	0f 90       	pop	r0
    3044:	0f be       	out	0x3f, r0	; 63
    3046:	0f 90       	pop	r0
    3048:	1f 90       	pop	r1
    304a:	18 95       	reti

0000304c <__vector_25>:
	uartTransmitService(3);
}

	// service UART receive interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_RECV)      
{
    304c:	1f 92       	push	r1
    304e:	0f 92       	push	r0
    3050:	0f b6       	in	r0, 0x3f	; 63
    3052:	0f 92       	push	r0
    3054:	11 24       	eor	r1, r1
    3056:	2f 93       	push	r18
    3058:	3f 93       	push	r19
    305a:	4f 93       	push	r20
    305c:	5f 93       	push	r21
    305e:	6f 93       	push	r22
    3060:	7f 93       	push	r23
    3062:	8f 93       	push	r24
    3064:	9f 93       	push	r25
    3066:	af 93       	push	r26
    3068:	bf 93       	push	r27
    306a:	ef 93       	push	r30
    306c:	ff 93       	push	r31
	uartReceiveService(0);
    306e:	80 e0       	ldi	r24, 0x00	; 0
    3070:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <uartReceiveService>
}
    3074:	ff 91       	pop	r31
    3076:	ef 91       	pop	r30
    3078:	bf 91       	pop	r27
    307a:	af 91       	pop	r26
    307c:	9f 91       	pop	r25
    307e:	8f 91       	pop	r24
    3080:	7f 91       	pop	r23
    3082:	6f 91       	pop	r22
    3084:	5f 91       	pop	r21
    3086:	4f 91       	pop	r20
    3088:	3f 91       	pop	r19
    308a:	2f 91       	pop	r18
    308c:	0f 90       	pop	r0
    308e:	0f be       	out	0x3f, r0	; 63
    3090:	0f 90       	pop	r0
    3092:	1f 90       	pop	r1
    3094:	18 95       	reti

00003096 <uartSendBuffer>:
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
}

u08 uartSendBuffer(u08 nUart, char *buffer, u16 nBytes)
{
    3096:	8f 92       	push	r8
    3098:	9f 92       	push	r9
    309a:	af 92       	push	r10
    309c:	bf 92       	push	r11
    309e:	cf 92       	push	r12
    30a0:	df 92       	push	r13
    30a2:	ef 92       	push	r14
    30a4:	ff 92       	push	r15
    30a6:	0f 93       	push	r16
    30a8:	1f 93       	push	r17
    30aa:	cf 93       	push	r28
    30ac:	df 93       	push	r29
    30ae:	88 2e       	mov	r8, r24
    30b0:	db 01       	movw	r26, r22
	register u08 first;
	register u16 i;

	// check if there's space (and that we have any bytes to send at all)
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
    30b2:	c8 2e       	mov	r12, r24
    30b4:	dd 24       	eor	r13, r13
    30b6:	f6 01       	movw	r30, r12
    30b8:	13 e0       	ldi	r17, 0x03	; 3
    30ba:	ee 0f       	add	r30, r30
    30bc:	ff 1f       	adc	r31, r31
    30be:	1a 95       	dec	r17
    30c0:	e1 f7       	brne	.-8      	; 0x30ba <uartSendBuffer+0x24>
    30c2:	e8 52       	subi	r30, 0x28	; 40
    30c4:	f3 4f       	sbci	r31, 0xF3	; 243
    30c6:	20 81       	ld	r18, Z
    30c8:	31 81       	ldd	r19, Z+1	; 0x01
    30ca:	24 0f       	add	r18, r20
    30cc:	35 1f       	adc	r19, r21
    30ce:	f6 01       	movw	r30, r12
    30d0:	73 e0       	ldi	r23, 0x03	; 3
    30d2:	ee 0f       	add	r30, r30
    30d4:	ff 1f       	adc	r31, r31
    30d6:	7a 95       	dec	r23
    30d8:	e1 f7       	brne	.-8      	; 0x30d2 <uartSendBuffer+0x3c>
    30da:	ea 52       	subi	r30, 0x2A	; 42
    30dc:	f3 4f       	sbci	r31, 0xF3	; 243
    30de:	80 81       	ld	r24, Z
    30e0:	91 81       	ldd	r25, Z+1	; 0x01
    30e2:	28 17       	cp	r18, r24
    30e4:	39 07       	cpc	r19, r25
    30e6:	70 f5       	brcc	.+92     	; 0x3144 <uartSendBuffer+0xae>
    30e8:	41 15       	cp	r20, r1
    30ea:	51 05       	cpc	r21, r1
    30ec:	59 f1       	breq	.+86     	; 0x3144 <uartSendBuffer+0xae>
	{
		// grab first character
		first = *buffer++;
    30ee:	9c 90       	ld	r9, X
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
		{
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
    30f0:	76 01       	movw	r14, r12
    30f2:	63 e0       	ldi	r22, 0x03	; 3
    30f4:	ee 0c       	add	r14, r14
    30f6:	ff 1c       	adc	r15, r15
    30f8:	6a 95       	dec	r22
    30fa:	e1 f7       	brne	.-8      	; 0x30f4 <uartSendBuffer+0x5e>
    30fc:	84 ed       	ldi	r24, 0xD4	; 212
    30fe:	9c e0       	ldi	r25, 0x0C	; 12
    3100:	e8 0e       	add	r14, r24
    3102:	f9 1e       	adc	r15, r25
    3104:	8d 01       	movw	r16, r26
    3106:	c0 e0       	ldi	r28, 0x00	; 0
    3108:	d0 e0       	ldi	r29, 0x00	; 0
	if((uartTxBuffer[nUart].datalength + nBytes < uartTxBuffer[nUart].size) && nBytes)
	{
		// grab first character
		first = *buffer++;
		// copy user buffer to uart transmit buffer
		for(i = 0; i < nBytes-1; i++)
    310a:	5a 01       	movw	r10, r20
    310c:	08 94       	sec
    310e:	a1 08       	sbc	r10, r1
    3110:	b1 08       	sbc	r11, r1
    3112:	06 c0       	rjmp	.+12     	; 0x3120 <uartSendBuffer+0x8a>
    3114:	c7 01       	movw	r24, r14
    3116:	f8 01       	movw	r30, r16
    3118:	60 81       	ld	r22, Z
    311a:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
    311e:	21 96       	adiw	r28, 0x01	; 1
    3120:	0f 5f       	subi	r16, 0xFF	; 255
    3122:	1f 4f       	sbci	r17, 0xFF	; 255
    3124:	ca 15       	cp	r28, r10
    3126:	db 05       	cpc	r29, r11
    3128:	a8 f3       	brcs	.-22     	; 0x3114 <uartSendBuffer+0x7e>
			// put data bytes at end of buffer
			bufferAddToEnd(&uartTxBuffer[nUart], *buffer++);
		}

		// send the first byte to get things going by interrupts
		uartBufferedTx[nUart] = TRUE;
    312a:	80 ed       	ldi	r24, 0xD0	; 208
    312c:	9c e0       	ldi	r25, 0x0C	; 12
    312e:	c8 0e       	add	r12, r24
    3130:	d9 1e       	adc	r13, r25
    3132:	8f ef       	ldi	r24, 0xFF	; 255
    3134:	f6 01       	movw	r30, r12
    3136:	80 83       	st	Z, r24
		uartSendByte(nUart, first);
    3138:	88 2d       	mov	r24, r8
    313a:	69 2d       	mov	r22, r9
    313c:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
    3140:	8f ef       	ldi	r24, 0xFF	; 255
    3142:	01 c0       	rjmp	.+2      	; 0x3146 <uartSendBuffer+0xb0>
		// return success
		return TRUE;
    3144:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		// return failure
		return FALSE;
	}
}
    3146:	df 91       	pop	r29
    3148:	cf 91       	pop	r28
    314a:	1f 91       	pop	r17
    314c:	0f 91       	pop	r16
    314e:	ff 90       	pop	r15
    3150:	ef 90       	pop	r14
    3152:	df 90       	pop	r13
    3154:	cf 90       	pop	r12
    3156:	bf 90       	pop	r11
    3158:	af 90       	pop	r10
    315a:	9f 90       	pop	r9
    315c:	8f 90       	pop	r8
    315e:	08 95       	ret

00003160 <uartAddToTxBuffer>:
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3160:	90 e0       	ldi	r25, 0x00	; 0
    3162:	23 e0       	ldi	r18, 0x03	; 3
    3164:	88 0f       	add	r24, r24
    3166:	99 1f       	adc	r25, r25
    3168:	2a 95       	dec	r18
    316a:	e1 f7       	brne	.-8      	; 0x3164 <uartAddToTxBuffer+0x4>
    316c:	8c 52       	subi	r24, 0x2C	; 44
    316e:	93 4f       	sbci	r25, 0xF3	; 243
    3170:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
}
    3174:	08 95       	ret

00003176 <uart3AddToTxBuffer>:
{
	uartAddToTxBuffer(2,data);
}

void uart3AddToTxBuffer(u08 data)
{
    3176:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3178:	8c ee       	ldi	r24, 0xEC	; 236
    317a:	9c e0       	ldi	r25, 0x0C	; 12
    317c:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
}

void uart3AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(3,data);
}
    3180:	08 95       	ret

00003182 <uart2AddToTxBuffer>:
{
	uartAddToTxBuffer(1,data);
}

void uart2AddToTxBuffer(u08 data)
{
    3182:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3184:	84 ee       	ldi	r24, 0xE4	; 228
    3186:	9c e0       	ldi	r25, 0x0C	; 12
    3188:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
}

void uart2AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(2,data);
}
    318c:	08 95       	ret

0000318e <uart1AddToTxBuffer>:
{
	uartAddToTxBuffer(0,data);
}

void uart1AddToTxBuffer(u08 data)
{
    318e:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    3190:	8c ed       	ldi	r24, 0xDC	; 220
    3192:	9c e0       	ldi	r25, 0x0C	; 12
    3194:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
}

void uart1AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(1,data);
}
    3198:	08 95       	ret

0000319a <uart0AddToTxBuffer>:
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
}

void uart0AddToTxBuffer(u08 data)
{
    319a:	68 2f       	mov	r22, r24
}

void uartAddToTxBuffer(u08 nUart, u08 data)
{
	// add data byte to the end of the tx buffer
	bufferAddToEnd(&uartTxBuffer[nUart], data);
    319c:	84 ed       	ldi	r24, 0xD4	; 212
    319e:	9c e0       	ldi	r25, 0x0C	; 12
    31a0:	0e 94 87 1b 	call	0x370e	; 0x370e <bufferAddToEnd>
}

void uart0AddToTxBuffer(u08 data)
{
	uartAddToTxBuffer(0,data);
}
    31a4:	08 95       	ret

000031a6 <uartTransmitService>:
	}
}

// UART Transmit Complete Interrupt Function
void uartTransmitService(u08 nUart)
{
    31a6:	cf 93       	push	r28
    31a8:	df 93       	push	r29
    31aa:	28 2f       	mov	r18, r24
	// check if buffered tx is enabled
	if(uartBufferedTx[nUart])
    31ac:	a8 2f       	mov	r26, r24
    31ae:	b0 e0       	ldi	r27, 0x00	; 0
    31b0:	ed 01       	movw	r28, r26
    31b2:	c0 53       	subi	r28, 0x30	; 48
    31b4:	d3 4f       	sbci	r29, 0xF3	; 243
    31b6:	88 81       	ld	r24, Y
    31b8:	88 23       	and	r24, r24
    31ba:	79 f1       	breq	.+94     	; 0x321a <uartTransmitService+0x74>
	{
		// check if there's data left in the buffer
		if(uartTxBuffer[nUart].datalength)
    31bc:	fd 01       	movw	r30, r26
    31be:	33 e0       	ldi	r19, 0x03	; 3
    31c0:	ee 0f       	add	r30, r30
    31c2:	ff 1f       	adc	r31, r31
    31c4:	3a 95       	dec	r19
    31c6:	e1 f7       	brne	.-8      	; 0x31c0 <uartTransmitService+0x1a>
    31c8:	e8 52       	subi	r30, 0x28	; 40
    31ca:	f3 4f       	sbci	r31, 0xF3	; 243
    31cc:	80 81       	ld	r24, Z
    31ce:	91 81       	ldd	r25, Z+1	; 0x01
    31d0:	89 2b       	or	r24, r25
    31d2:	11 f1       	breq	.+68     	; 0x3218 <uartTransmitService+0x72>
		{
			// send byte from top of buffer
			if(nUart==3)
    31d4:	23 30       	cpi	r18, 0x03	; 3
    31d6:	39 f4       	brne	.+14     	; 0x31e6 <uartTransmitService+0x40>
				outb(UDR3,  bufferGetFromFront(&uartTxBuffer[3]) );
    31d8:	8c ee       	ldi	r24, 0xEC	; 236
    31da:	9c e0       	ldi	r25, 0x0C	; 12
    31dc:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    31e0:	80 93 36 01 	sts	0x0136, r24
    31e4:	1e c0       	rjmp	.+60     	; 0x3222 <uartTransmitService+0x7c>
			else if(nUart==2)
    31e6:	22 30       	cpi	r18, 0x02	; 2
    31e8:	39 f4       	brne	.+14     	; 0x31f8 <uartTransmitService+0x52>
				outb(UDR2,  bufferGetFromFront(&uartTxBuffer[2]) );
    31ea:	84 ee       	ldi	r24, 0xE4	; 228
    31ec:	9c e0       	ldi	r25, 0x0C	; 12
    31ee:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    31f2:	80 93 d6 00 	sts	0x00D6, r24
    31f6:	15 c0       	rjmp	.+42     	; 0x3222 <uartTransmitService+0x7c>
			else if(nUart==1)
    31f8:	21 30       	cpi	r18, 0x01	; 1
    31fa:	39 f4       	brne	.+14     	; 0x320a <uartTransmitService+0x64>
				outb(UDR1,  bufferGetFromFront(&uartTxBuffer[1]) );
    31fc:	8c ed       	ldi	r24, 0xDC	; 220
    31fe:	9c e0       	ldi	r25, 0x0C	; 12
    3200:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    3204:	80 93 ce 00 	sts	0x00CE, r24
    3208:	0c c0       	rjmp	.+24     	; 0x3222 <uartTransmitService+0x7c>
			else
				outb(UDR0,  bufferGetFromFront(&uartTxBuffer[0]) );
    320a:	84 ed       	ldi	r24, 0xD4	; 212
    320c:	9c e0       	ldi	r25, 0x0C	; 12
    320e:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    3212:	80 93 c6 00 	sts	0x00C6, r24
    3216:	05 c0       	rjmp	.+10     	; 0x3222 <uartTransmitService+0x7c>
		}
		else
		{
			// no data left
			uartBufferedTx[nUart] = FALSE;
    3218:	18 82       	st	Y, r1
	}
	else
	{
		// we're using single-byte tx mode
		// indicate transmit complete, back to ready
		uartReadyTx[nUart] = TRUE;
    321a:	a4 55       	subi	r26, 0x54	; 84
    321c:	b3 4f       	sbci	r27, 0xF3	; 243
    321e:	8f ef       	ldi	r24, 0xFF	; 255
    3220:	8c 93       	st	X, r24
	}
}
    3222:	df 91       	pop	r29
    3224:	cf 91       	pop	r28
    3226:	08 95       	ret

00003228 <__vector_56>:
{
	uartTransmitService(2);
}

UART_INTERRUPT_HANDLER(SIG_USART3_TRANS)      
{
    3228:	1f 92       	push	r1
    322a:	0f 92       	push	r0
    322c:	0f b6       	in	r0, 0x3f	; 63
    322e:	0f 92       	push	r0
    3230:	11 24       	eor	r1, r1
    3232:	2f 93       	push	r18
    3234:	3f 93       	push	r19
    3236:	4f 93       	push	r20
    3238:	5f 93       	push	r21
    323a:	6f 93       	push	r22
    323c:	7f 93       	push	r23
    323e:	8f 93       	push	r24
    3240:	9f 93       	push	r25
    3242:	af 93       	push	r26
    3244:	bf 93       	push	r27
    3246:	ef 93       	push	r30
    3248:	ff 93       	push	r31
	uartTransmitService(3);
    324a:	83 e0       	ldi	r24, 0x03	; 3
    324c:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <uartTransmitService>
}
    3250:	ff 91       	pop	r31
    3252:	ef 91       	pop	r30
    3254:	bf 91       	pop	r27
    3256:	af 91       	pop	r26
    3258:	9f 91       	pop	r25
    325a:	8f 91       	pop	r24
    325c:	7f 91       	pop	r23
    325e:	6f 91       	pop	r22
    3260:	5f 91       	pop	r21
    3262:	4f 91       	pop	r20
    3264:	3f 91       	pop	r19
    3266:	2f 91       	pop	r18
    3268:	0f 90       	pop	r0
    326a:	0f be       	out	0x3f, r0	; 63
    326c:	0f 90       	pop	r0
    326e:	1f 90       	pop	r1
    3270:	18 95       	reti

00003272 <__vector_53>:
{
	uartTransmitService(1);
}

UART_INTERRUPT_HANDLER(SIG_USART2_TRANS)      
{
    3272:	1f 92       	push	r1
    3274:	0f 92       	push	r0
    3276:	0f b6       	in	r0, 0x3f	; 63
    3278:	0f 92       	push	r0
    327a:	11 24       	eor	r1, r1
    327c:	2f 93       	push	r18
    327e:	3f 93       	push	r19
    3280:	4f 93       	push	r20
    3282:	5f 93       	push	r21
    3284:	6f 93       	push	r22
    3286:	7f 93       	push	r23
    3288:	8f 93       	push	r24
    328a:	9f 93       	push	r25
    328c:	af 93       	push	r26
    328e:	bf 93       	push	r27
    3290:	ef 93       	push	r30
    3292:	ff 93       	push	r31
	uartTransmitService(2);
    3294:	82 e0       	ldi	r24, 0x02	; 2
    3296:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <uartTransmitService>
}
    329a:	ff 91       	pop	r31
    329c:	ef 91       	pop	r30
    329e:	bf 91       	pop	r27
    32a0:	af 91       	pop	r26
    32a2:	9f 91       	pop	r25
    32a4:	8f 91       	pop	r24
    32a6:	7f 91       	pop	r23
    32a8:	6f 91       	pop	r22
    32aa:	5f 91       	pop	r21
    32ac:	4f 91       	pop	r20
    32ae:	3f 91       	pop	r19
    32b0:	2f 91       	pop	r18
    32b2:	0f 90       	pop	r0
    32b4:	0f be       	out	0x3f, r0	; 63
    32b6:	0f 90       	pop	r0
    32b8:	1f 90       	pop	r1
    32ba:	18 95       	reti

000032bc <__vector_38>:
{
	uartTransmitService(0);
}

UART_INTERRUPT_HANDLER(SIG_USART1_TRANS)      
{
    32bc:	1f 92       	push	r1
    32be:	0f 92       	push	r0
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	0f 92       	push	r0
    32c4:	11 24       	eor	r1, r1
    32c6:	2f 93       	push	r18
    32c8:	3f 93       	push	r19
    32ca:	4f 93       	push	r20
    32cc:	5f 93       	push	r21
    32ce:	6f 93       	push	r22
    32d0:	7f 93       	push	r23
    32d2:	8f 93       	push	r24
    32d4:	9f 93       	push	r25
    32d6:	af 93       	push	r26
    32d8:	bf 93       	push	r27
    32da:	ef 93       	push	r30
    32dc:	ff 93       	push	r31
	uartTransmitService(1);
    32de:	81 e0       	ldi	r24, 0x01	; 1
    32e0:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <uartTransmitService>
}
    32e4:	ff 91       	pop	r31
    32e6:	ef 91       	pop	r30
    32e8:	bf 91       	pop	r27
    32ea:	af 91       	pop	r26
    32ec:	9f 91       	pop	r25
    32ee:	8f 91       	pop	r24
    32f0:	7f 91       	pop	r23
    32f2:	6f 91       	pop	r22
    32f4:	5f 91       	pop	r21
    32f6:	4f 91       	pop	r20
    32f8:	3f 91       	pop	r19
    32fa:	2f 91       	pop	r18
    32fc:	0f 90       	pop	r0
    32fe:	0f be       	out	0x3f, r0	; 63
    3300:	0f 90       	pop	r0
    3302:	1f 90       	pop	r1
    3304:	18 95       	reti

00003306 <__vector_27>:
	}
}

	// service UART transmit interrupt
UART_INTERRUPT_HANDLER(SIG_USART0_TRANS)      
{
    3306:	1f 92       	push	r1
    3308:	0f 92       	push	r0
    330a:	0f b6       	in	r0, 0x3f	; 63
    330c:	0f 92       	push	r0
    330e:	11 24       	eor	r1, r1
    3310:	2f 93       	push	r18
    3312:	3f 93       	push	r19
    3314:	4f 93       	push	r20
    3316:	5f 93       	push	r21
    3318:	6f 93       	push	r22
    331a:	7f 93       	push	r23
    331c:	8f 93       	push	r24
    331e:	9f 93       	push	r25
    3320:	af 93       	push	r26
    3322:	bf 93       	push	r27
    3324:	ef 93       	push	r30
    3326:	ff 93       	push	r31
	uartTransmitService(0);
    3328:	80 e0       	ldi	r24, 0x00	; 0
    332a:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <uartTransmitService>
}
    332e:	ff 91       	pop	r31
    3330:	ef 91       	pop	r30
    3332:	bf 91       	pop	r27
    3334:	af 91       	pop	r26
    3336:	9f 91       	pop	r25
    3338:	8f 91       	pop	r24
    333a:	7f 91       	pop	r23
    333c:	6f 91       	pop	r22
    333e:	5f 91       	pop	r21
    3340:	4f 91       	pop	r20
    3342:	3f 91       	pop	r19
    3344:	2f 91       	pop	r18
    3346:	0f 90       	pop	r0
    3348:	0f be       	out	0x3f, r0	; 63
    334a:	0f 90       	pop	r0
    334c:	1f 90       	pop	r1
    334e:	18 95       	reti

00003350 <uartSendTxBuffer>:
{
	uartAddToTxBuffer(3,data);
}

void uartSendTxBuffer(u08 nUart)
{
    3350:	1f 93       	push	r17
    3352:	18 2f       	mov	r17, r24
	// turn on buffered transmit
	uartBufferedTx[nUart] = TRUE;
    3354:	90 e0       	ldi	r25, 0x00	; 0
    3356:	fc 01       	movw	r30, r24
    3358:	e0 53       	subi	r30, 0x30	; 48
    335a:	f3 4f       	sbci	r31, 0xF3	; 243
    335c:	2f ef       	ldi	r18, 0xFF	; 255
    335e:	20 83       	st	Z, r18
	// send the first byte to get things going by interrupts
	uartSendByte(nUart, bufferGetFromFront(&uartTxBuffer[nUart]));
    3360:	43 e0       	ldi	r20, 0x03	; 3
    3362:	88 0f       	add	r24, r24
    3364:	99 1f       	adc	r25, r25
    3366:	4a 95       	dec	r20
    3368:	e1 f7       	brne	.-8      	; 0x3362 <uartSendTxBuffer+0x12>
    336a:	8c 52       	subi	r24, 0x2C	; 44
    336c:	93 4f       	sbci	r25, 0xF3	; 243
    336e:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    3372:	68 2f       	mov	r22, r24
    3374:	81 2f       	mov	r24, r17
    3376:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <uartSendByte>
}
    337a:	1f 91       	pop	r17
    337c:	08 95       	ret

0000337e <uartReceiveByte>:
		return -1;
}


u08 uartReceiveByte(u08 nUart, u08* rxData)
{
    337e:	cf 93       	push	r28
    3380:	df 93       	push	r29
    3382:	eb 01       	movw	r28, r22
	// make sure we have a receive buffer
	if(uartRxBuffer[nUart].size)
    3384:	28 2f       	mov	r18, r24
    3386:	30 e0       	ldi	r19, 0x00	; 0
    3388:	f9 01       	movw	r30, r18
    338a:	73 e0       	ldi	r23, 0x03	; 3
    338c:	ee 0f       	add	r30, r30
    338e:	ff 1f       	adc	r31, r31
    3390:	7a 95       	dec	r23
    3392:	e1 f7       	brne	.-8      	; 0x338c <uartReceiveByte+0xe>
    3394:	ee 54       	subi	r30, 0x4E	; 78
    3396:	f3 4f       	sbci	r31, 0xF3	; 243
    3398:	80 81       	ld	r24, Z
    339a:	91 81       	ldd	r25, Z+1	; 0x01
    339c:	89 2b       	or	r24, r25
    339e:	c9 f0       	breq	.+50     	; 0x33d2 <uartReceiveByte+0x54>
	{
		// make sure we have data
		if(uartRxBuffer[nUart].datalength)
    33a0:	f9 01       	movw	r30, r18
    33a2:	63 e0       	ldi	r22, 0x03	; 3
    33a4:	ee 0f       	add	r30, r30
    33a6:	ff 1f       	adc	r31, r31
    33a8:	6a 95       	dec	r22
    33aa:	e1 f7       	brne	.-8      	; 0x33a4 <uartReceiveByte+0x26>
    33ac:	ec 54       	subi	r30, 0x4C	; 76
    33ae:	f3 4f       	sbci	r31, 0xF3	; 243
    33b0:	80 81       	ld	r24, Z
    33b2:	91 81       	ldd	r25, Z+1	; 0x01
    33b4:	89 2b       	or	r24, r25
    33b6:	69 f0       	breq	.+26     	; 0x33d2 <uartReceiveByte+0x54>
		{
			// get byte from beginning of buffer
			*rxData = bufferGetFromFront(&uartRxBuffer[nUart]);
    33b8:	53 e0       	ldi	r21, 0x03	; 3
    33ba:	22 0f       	add	r18, r18
    33bc:	33 1f       	adc	r19, r19
    33be:	5a 95       	dec	r21
    33c0:	e1 f7       	brne	.-8      	; 0x33ba <uartReceiveByte+0x3c>
    33c2:	c9 01       	movw	r24, r18
    33c4:	80 55       	subi	r24, 0x50	; 80
    33c6:	93 4f       	sbci	r25, 0xF3	; 243
    33c8:	0e 94 1e 1b 	call	0x363c	; 0x363c <bufferGetFromFront>
    33cc:	88 83       	st	Y, r24
    33ce:	8f ef       	ldi	r24, 0xFF	; 255
    33d0:	01 c0       	rjmp	.+2      	; 0x33d4 <uartReceiveByte+0x56>
			return TRUE;
    33d2:	80 e0       	ldi	r24, 0x00	; 0
		else
			return FALSE;			// no data
	}
	else
		return FALSE;				// no buffer
}
    33d4:	df 91       	pop	r29
    33d6:	cf 91       	pop	r28
    33d8:	08 95       	ret

000033da <uart3GetByte>:
	else
		return -1;
}

int uart3GetByte(void)
{
    33da:	df 93       	push	r29
    33dc:	cf 93       	push	r28
    33de:	0f 92       	push	r0
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(3,&c))
    33e4:	83 e0       	ldi	r24, 0x03	; 3
    33e6:	be 01       	movw	r22, r28
    33e8:	6f 5f       	subi	r22, 0xFF	; 255
    33ea:	7f 4f       	sbci	r23, 0xFF	; 255
    33ec:	0e 94 bf 19 	call	0x337e	; 0x337e <uartReceiveByte>
    33f0:	88 23       	and	r24, r24
    33f2:	19 f4       	brne	.+6      	; 0x33fa <uart3GetByte+0x20>
    33f4:	2f ef       	ldi	r18, 0xFF	; 255
    33f6:	3f ef       	ldi	r19, 0xFF	; 255
    33f8:	03 c0       	rjmp	.+6      	; 0x3400 <uart3GetByte+0x26>
		return c;
    33fa:	89 81       	ldd	r24, Y+1	; 0x01
    33fc:	28 2f       	mov	r18, r24
    33fe:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3400:	c9 01       	movw	r24, r18
    3402:	0f 90       	pop	r0
    3404:	cf 91       	pop	r28
    3406:	df 91       	pop	r29
    3408:	08 95       	ret

0000340a <uart2GetByte>:
	else
		return -1;
}

int uart2GetByte(void)
{
    340a:	df 93       	push	r29
    340c:	cf 93       	push	r28
    340e:	0f 92       	push	r0
    3410:	cd b7       	in	r28, 0x3d	; 61
    3412:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(2,&c))
    3414:	82 e0       	ldi	r24, 0x02	; 2
    3416:	be 01       	movw	r22, r28
    3418:	6f 5f       	subi	r22, 0xFF	; 255
    341a:	7f 4f       	sbci	r23, 0xFF	; 255
    341c:	0e 94 bf 19 	call	0x337e	; 0x337e <uartReceiveByte>
    3420:	88 23       	and	r24, r24
    3422:	19 f4       	brne	.+6      	; 0x342a <uart2GetByte+0x20>
    3424:	2f ef       	ldi	r18, 0xFF	; 255
    3426:	3f ef       	ldi	r19, 0xFF	; 255
    3428:	03 c0       	rjmp	.+6      	; 0x3430 <uart2GetByte+0x26>
		return c;
    342a:	89 81       	ldd	r24, Y+1	; 0x01
    342c:	28 2f       	mov	r18, r24
    342e:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3430:	c9 01       	movw	r24, r18
    3432:	0f 90       	pop	r0
    3434:	cf 91       	pop	r28
    3436:	df 91       	pop	r29
    3438:	08 95       	ret

0000343a <uart1GetByte>:
	else
		return -1;
}

int uart1GetByte(void)
{
    343a:	df 93       	push	r29
    343c:	cf 93       	push	r28
    343e:	0f 92       	push	r0
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(1,&c))
    3444:	81 e0       	ldi	r24, 0x01	; 1
    3446:	be 01       	movw	r22, r28
    3448:	6f 5f       	subi	r22, 0xFF	; 255
    344a:	7f 4f       	sbci	r23, 0xFF	; 255
    344c:	0e 94 bf 19 	call	0x337e	; 0x337e <uartReceiveByte>
    3450:	88 23       	and	r24, r24
    3452:	19 f4       	brne	.+6      	; 0x345a <uart1GetByte+0x20>
    3454:	2f ef       	ldi	r18, 0xFF	; 255
    3456:	3f ef       	ldi	r19, 0xFF	; 255
    3458:	03 c0       	rjmp	.+6      	; 0x3460 <uart1GetByte+0x26>
		return c;
    345a:	89 81       	ldd	r24, Y+1	; 0x01
    345c:	28 2f       	mov	r18, r24
    345e:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3460:	c9 01       	movw	r24, r18
    3462:	0f 90       	pop	r0
    3464:	cf 91       	pop	r28
    3466:	df 91       	pop	r29
    3468:	08 95       	ret

0000346a <uart0GetByte>:
	// send byte on UART3
	uartSendByte(3, data);
}

int uart0GetByte(void)
{
    346a:	df 93       	push	r29
    346c:	cf 93       	push	r28
    346e:	0f 92       	push	r0
    3470:	cd b7       	in	r28, 0x3d	; 61
    3472:	de b7       	in	r29, 0x3e	; 62
	// get single byte from receive buffer (if available)
	u08 c;
	if(uartReceiveByte(0,&c))
    3474:	80 e0       	ldi	r24, 0x00	; 0
    3476:	be 01       	movw	r22, r28
    3478:	6f 5f       	subi	r22, 0xFF	; 255
    347a:	7f 4f       	sbci	r23, 0xFF	; 255
    347c:	0e 94 bf 19 	call	0x337e	; 0x337e <uartReceiveByte>
    3480:	88 23       	and	r24, r24
    3482:	19 f4       	brne	.+6      	; 0x348a <uart0GetByte+0x20>
    3484:	2f ef       	ldi	r18, 0xFF	; 255
    3486:	3f ef       	ldi	r19, 0xFF	; 255
    3488:	03 c0       	rjmp	.+6      	; 0x3490 <uart0GetByte+0x26>
		return c;
    348a:	89 81       	ldd	r24, Y+1	; 0x01
    348c:	28 2f       	mov	r18, r24
    348e:	30 e0       	ldi	r19, 0x00	; 0
	else
		return -1;
}
    3490:	c9 01       	movw	r24, r18
    3492:	0f 90       	pop	r0
    3494:	cf 91       	pop	r28
    3496:	df 91       	pop	r29
    3498:	08 95       	ret

0000349a <uartFlushReceiveBuffer>:
}

void uartFlushReceiveBuffer(u08 nUart)
{
	// flush all data from receive buffer
	bufferFlush(&uartRxBuffer[nUart]);
    349a:	90 e0       	ldi	r25, 0x00	; 0
    349c:	e3 e0       	ldi	r30, 0x03	; 3
    349e:	88 0f       	add	r24, r24
    34a0:	99 1f       	adc	r25, r25
    34a2:	ea 95       	dec	r30
    34a4:	e1 f7       	brne	.-8      	; 0x349e <uartFlushReceiveBuffer+0x4>
    34a6:	80 55       	subi	r24, 0x50	; 80
    34a8:	93 4f       	sbci	r25, 0xF3	; 243
    34aa:	0e 94 ba 1b 	call	0x3774	; 0x3774 <bufferFlush>
}
    34ae:	08 95       	ret

000034b0 <uart3InitBuffers>:

void uart3InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) uart3RxData, UART3_RX_BUFFER_SIZE);
    34b0:	88 ec       	ldi	r24, 0xC8	; 200
    34b2:	9c e0       	ldi	r25, 0x0C	; 12
    34b4:	66 ef       	ldi	r22, 0xF6	; 246
    34b6:	7b e0       	ldi	r23, 0x0B	; 11
    34b8:	40 e8       	ldi	r20, 0x80	; 128
    34ba:	50 e0       	ldi	r21, 0x00	; 0
    34bc:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
		bufferInit(&uartTxBuffer[3], (u08*) uart3TxData, UART3_TX_BUFFER_SIZE);
    34c0:	8c ee       	ldi	r24, 0xEC	; 236
    34c2:	9c e0       	ldi	r25, 0x0C	; 12
    34c4:	66 e7       	ldi	r22, 0x76	; 118
    34c6:	7c e0       	ldi	r23, 0x0C	; 12
    34c8:	40 e1       	ldi	r20, 0x10	; 16
    34ca:	50 e0       	ldi	r21, 0x00	; 0
    34cc:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
	#else
		// initialize the UART3 buffers
		bufferInit(&uartRxBuffer[3], (u08*) UART3_RX_BUFFER_ADDR, UART3_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[3], (u08*) UART3_TX_BUFFER_ADDR, UART3_TX_BUFFER_SIZE);
	#endif
}
    34d0:	08 95       	ret

000034d2 <uart3Init>:
}

void uart3Init(void)
{
	// initialize the buffers
	uart3InitBuffers();
    34d2:	0e 94 58 1a 	call	0x34b0	; 0x34b0 <uart3InitBuffers>
	// initialize user receive handlers
	UartRxFunc[3] = 0;
    34d6:	10 92 8d 0c 	sts	0x0C8D, r1
    34da:	10 92 8c 0c 	sts	0x0C8C, r1
	// enable RxD/TxD and interrupts
	outb(UCSR3B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    34de:	88 ed       	ldi	r24, 0xD8	; 216
    34e0:	80 93 31 01 	sts	0x0131, r24
	// set default baud rate
	uartSetBaudRate(3, UART3_DEFAULT_BAUD_RATE);
    34e4:	83 e0       	ldi	r24, 0x03	; 3
    34e6:	40 e8       	ldi	r20, 0x80	; 128
    34e8:	55 e2       	ldi	r21, 0x25	; 37
    34ea:	60 e0       	ldi	r22, 0x00	; 0
    34ec:	70 e0       	ldi	r23, 0x00	; 0
    34ee:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
	// initialize states
	uartReadyTx[3] = TRUE;
    34f2:	8f ef       	ldi	r24, 0xFF	; 255
    34f4:	80 93 af 0c 	sts	0x0CAF, r24
	uartBufferedTx[3] = FALSE;
    34f8:	10 92 d3 0c 	sts	0x0CD3, r1
	// clear overflow count
	uartRxOverflow[3] = 0;
    34fc:	10 92 fb 0c 	sts	0x0CFB, r1
    3500:	10 92 fa 0c 	sts	0x0CFA, r1
	// enable interrupts
	sei();
    3504:	78 94       	sei
}
    3506:	08 95       	ret

00003508 <uart2InitBuffers>:

void uart2InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) uart2RxData, UART2_RX_BUFFER_SIZE);
    3508:	80 ec       	ldi	r24, 0xC0	; 192
    350a:	9c e0       	ldi	r25, 0x0C	; 12
    350c:	66 e6       	ldi	r22, 0x66	; 102
    350e:	7b e0       	ldi	r23, 0x0B	; 11
    3510:	40 e8       	ldi	r20, 0x80	; 128
    3512:	50 e0       	ldi	r21, 0x00	; 0
    3514:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
		bufferInit(&uartTxBuffer[2], (u08*) uart2TxData, UART2_TX_BUFFER_SIZE);
    3518:	84 ee       	ldi	r24, 0xE4	; 228
    351a:	9c e0       	ldi	r25, 0x0C	; 12
    351c:	66 ee       	ldi	r22, 0xE6	; 230
    351e:	7b e0       	ldi	r23, 0x0B	; 11
    3520:	40 e1       	ldi	r20, 0x10	; 16
    3522:	50 e0       	ldi	r21, 0x00	; 0
    3524:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
	#else
		// initialize the UART2 buffers
		bufferInit(&uartRxBuffer[2], (u08*) UART2_RX_BUFFER_ADDR, UART2_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[2], (u08*) UART2_TX_BUFFER_ADDR, UART2_TX_BUFFER_SIZE);
	#endif
}
    3528:	08 95       	ret

0000352a <uart2Init>:
}

void uart2Init(void)
{
	// initialize the buffers
	uart2InitBuffers();
    352a:	0e 94 84 1a 	call	0x3508	; 0x3508 <uart2InitBuffers>
	// initialize user receive handlers
	UartRxFunc[2] = 0;
    352e:	10 92 8b 0c 	sts	0x0C8B, r1
    3532:	10 92 8a 0c 	sts	0x0C8A, r1
	// enable RxD/TxD and interrupts
	outb(UCSR2B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    3536:	88 ed       	ldi	r24, 0xD8	; 216
    3538:	80 93 d1 00 	sts	0x00D1, r24
	// set default baud rate
	uartSetBaudRate(2, UART2_DEFAULT_BAUD_RATE);
    353c:	82 e0       	ldi	r24, 0x02	; 2
    353e:	40 e8       	ldi	r20, 0x80	; 128
    3540:	55 e2       	ldi	r21, 0x25	; 37
    3542:	60 e0       	ldi	r22, 0x00	; 0
    3544:	70 e0       	ldi	r23, 0x00	; 0
    3546:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
	// initialize states
	uartReadyTx[2] = TRUE;
    354a:	8f ef       	ldi	r24, 0xFF	; 255
    354c:	80 93 ae 0c 	sts	0x0CAE, r24
	uartBufferedTx[2] = FALSE;
    3550:	10 92 d2 0c 	sts	0x0CD2, r1
	// clear overflow count
	uartRxOverflow[2] = 0;
    3554:	10 92 f9 0c 	sts	0x0CF9, r1
    3558:	10 92 f8 0c 	sts	0x0CF8, r1
	// enable interrupts
	sei();
    355c:	78 94       	sei
}
    355e:	08 95       	ret

00003560 <uart1InitBuffers>:

void uart1InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) uart1RxData, UART1_RX_BUFFER_SIZE);
    3560:	88 eb       	ldi	r24, 0xB8	; 184
    3562:	9c e0       	ldi	r25, 0x0C	; 12
    3564:	66 ed       	ldi	r22, 0xD6	; 214
    3566:	7a e0       	ldi	r23, 0x0A	; 10
    3568:	40 e8       	ldi	r20, 0x80	; 128
    356a:	50 e0       	ldi	r21, 0x00	; 0
    356c:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
		bufferInit(&uartTxBuffer[1], (u08*) uart1TxData, UART1_TX_BUFFER_SIZE);
    3570:	8c ed       	ldi	r24, 0xDC	; 220
    3572:	9c e0       	ldi	r25, 0x0C	; 12
    3574:	66 e5       	ldi	r22, 0x56	; 86
    3576:	7b e0       	ldi	r23, 0x0B	; 11
    3578:	40 e1       	ldi	r20, 0x10	; 16
    357a:	50 e0       	ldi	r21, 0x00	; 0
    357c:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
	#else
		// initialize the UART1 buffers
		bufferInit(&uartRxBuffer[1], (u08*) UART1_RX_BUFFER_ADDR, UART1_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[1], (u08*) UART1_TX_BUFFER_ADDR, UART1_TX_BUFFER_SIZE);
	#endif
}
    3580:	08 95       	ret

00003582 <uart1Init>:
}

void uart1Init(void)
{
	// initialize the buffers
	uart1InitBuffers();
    3582:	0e 94 b0 1a 	call	0x3560	; 0x3560 <uart1InitBuffers>
	// initialize user receive handlers
	UartRxFunc[1] = 0;
    3586:	10 92 89 0c 	sts	0x0C89, r1
    358a:	10 92 88 0c 	sts	0x0C88, r1
	// enable RxD/TxD and interrupts
	outb(UCSR1B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    358e:	88 ed       	ldi	r24, 0xD8	; 216
    3590:	80 93 c9 00 	sts	0x00C9, r24
	// set default baud rate
	uartSetBaudRate(1, UART1_DEFAULT_BAUD_RATE);
    3594:	81 e0       	ldi	r24, 0x01	; 1
    3596:	40 e8       	ldi	r20, 0x80	; 128
    3598:	55 e2       	ldi	r21, 0x25	; 37
    359a:	60 e0       	ldi	r22, 0x00	; 0
    359c:	70 e0       	ldi	r23, 0x00	; 0
    359e:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
	// initialize states
	uartReadyTx[1] = TRUE;
    35a2:	8f ef       	ldi	r24, 0xFF	; 255
    35a4:	80 93 ad 0c 	sts	0x0CAD, r24
	uartBufferedTx[1] = FALSE;
    35a8:	10 92 d1 0c 	sts	0x0CD1, r1
	// clear overflow count
	uartRxOverflow[1] = 0;
    35ac:	10 92 f7 0c 	sts	0x0CF7, r1
    35b0:	10 92 f6 0c 	sts	0x0CF6, r1
	// enable interrupts
	sei();
    35b4:	78 94       	sei
}
    35b6:	08 95       	ret

000035b8 <uart0InitBuffers>:

void uart0InitBuffers(void)
{
	#ifndef UART_BUFFER_EXTERNAL_RAM
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) uart0RxData, UART0_RX_BUFFER_SIZE);
    35b8:	80 eb       	ldi	r24, 0xB0	; 176
    35ba:	9c e0       	ldi	r25, 0x0C	; 12
    35bc:	66 e4       	ldi	r22, 0x46	; 70
    35be:	7a e0       	ldi	r23, 0x0A	; 10
    35c0:	40 e8       	ldi	r20, 0x80	; 128
    35c2:	50 e0       	ldi	r21, 0x00	; 0
    35c4:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
		bufferInit(&uartTxBuffer[0], (u08*) uart0TxData, UART0_TX_BUFFER_SIZE);
    35c8:	84 ed       	ldi	r24, 0xD4	; 212
    35ca:	9c e0       	ldi	r25, 0x0C	; 12
    35cc:	66 ec       	ldi	r22, 0xC6	; 198
    35ce:	7a e0       	ldi	r23, 0x0A	; 10
    35d0:	40 e1       	ldi	r20, 0x10	; 16
    35d2:	50 e0       	ldi	r21, 0x00	; 0
    35d4:	0e 94 11 1b 	call	0x3622	; 0x3622 <bufferInit>
	#else
		// initialize the UART0 buffers
		bufferInit(&uartRxBuffer[0], (u08*) UART0_RX_BUFFER_ADDR, UART0_RX_BUFFER_SIZE);
		bufferInit(&uartTxBuffer[0], (u08*) UART0_TX_BUFFER_ADDR, UART0_TX_BUFFER_SIZE);
	#endif
}
    35d8:	08 95       	ret

000035da <uart0Init>:
}

void uart0Init(void)
{
	// initialize the buffers
	uart0InitBuffers();
    35da:	0e 94 dc 1a 	call	0x35b8	; 0x35b8 <uart0InitBuffers>
	// initialize user receive handlers
	UartRxFunc[0] = 0;
    35de:	10 92 87 0c 	sts	0x0C87, r1
    35e2:	10 92 86 0c 	sts	0x0C86, r1
	// enable RxD/TxD and interrupts
	outb(UCSR0B, BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
    35e6:	88 ed       	ldi	r24, 0xD8	; 216
    35e8:	80 93 c1 00 	sts	0x00C1, r24
	// set default baud rate
	uartSetBaudRate(0, UART0_DEFAULT_BAUD_RATE); 
    35ec:	80 e0       	ldi	r24, 0x00	; 0
    35ee:	40 e8       	ldi	r20, 0x80	; 128
    35f0:	55 e2       	ldi	r21, 0x25	; 37
    35f2:	60 e0       	ldi	r22, 0x00	; 0
    35f4:	70 e0       	ldi	r23, 0x00	; 0
    35f6:	0e 94 e2 16 	call	0x2dc4	; 0x2dc4 <uartSetBaudRate>
	// initialize states
	uartReadyTx[0] = TRUE;
    35fa:	8f ef       	ldi	r24, 0xFF	; 255
    35fc:	80 93 ac 0c 	sts	0x0CAC, r24
	uartBufferedTx[0] = FALSE;
    3600:	10 92 d0 0c 	sts	0x0CD0, r1
	// clear overflow count
	uartRxOverflow[0] = 0;
    3604:	10 92 f5 0c 	sts	0x0CF5, r1
    3608:	10 92 f4 0c 	sts	0x0CF4, r1
	// enable interrupts
	sei();
    360c:	78 94       	sei
}
    360e:	08 95       	ret

00003610 <uartInit>:
volatile static voidFuncPtru08 UartRxFunc[4];

void uartInit(void)
{
	// initialize all uarts
	uart0Init();
    3610:	0e 94 ed 1a 	call	0x35da	; 0x35da <uart0Init>
	uart1Init();
    3614:	0e 94 c1 1a 	call	0x3582	; 0x3582 <uart1Init>
	uart2Init();
    3618:	0e 94 95 1a 	call	0x352a	; 0x352a <uart2Init>
	uart3Init();
    361c:	0e 94 69 1a 	call	0x34d2	; 0x34d2 <uart3Init>
}
    3620:	08 95       	ret

00003622 <bufferInit>:
// global variables

// initialization

void bufferInit(cBuffer* buffer, unsigned char *start, unsigned short size)
{
    3622:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3624:	8f b7       	in	r24, 0x3f	; 63
    3626:	f8 94       	cli
	// set start pointer of the buffer
	buffer->dataptr = start;
    3628:	71 83       	std	Z+1, r23	; 0x01
    362a:	60 83       	st	Z, r22
	buffer->size = size;
    362c:	53 83       	std	Z+3, r21	; 0x03
    362e:	42 83       	std	Z+2, r20	; 0x02
	// initialize index and length
	buffer->dataindex = 0;
    3630:	17 82       	std	Z+7, r1	; 0x07
    3632:	16 82       	std	Z+6, r1	; 0x06
	buffer->datalength = 0;
    3634:	15 82       	std	Z+5, r1	; 0x05
    3636:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    3638:	8f bf       	out	0x3f, r24	; 63
}
    363a:	08 95       	ret

0000363c <bufferGetFromFront>:

// access routines
unsigned char  bufferGetFromFront(cBuffer* buffer)
{
    363c:	dc 01       	movw	r26, r24
	unsigned char data = 0;
	// begin critical section
	CRITICAL_SECTION_START;
    363e:	4f b7       	in	r20, 0x3f	; 63
    3640:	f8 94       	cli
	// check to see if there's data in the buffer
	if(buffer->datalength)
    3642:	14 96       	adiw	r26, 0x04	; 4
    3644:	8d 91       	ld	r24, X+
    3646:	9c 91       	ld	r25, X
    3648:	15 97       	sbiw	r26, 0x05	; 5
    364a:	89 2b       	or	r24, r25
    364c:	11 f4       	brne	.+4      	; 0x3652 <bufferGetFromFront+0x16>
    364e:	e0 e0       	ldi	r30, 0x00	; 0
    3650:	25 c0       	rjmp	.+74     	; 0x369c <bufferGetFromFront+0x60>
	{
		// get the first character from buffer
		data = buffer->dataptr[buffer->dataindex];
    3652:	16 96       	adiw	r26, 0x06	; 6
    3654:	8d 91       	ld	r24, X+
    3656:	9c 91       	ld	r25, X
    3658:	17 97       	sbiw	r26, 0x07	; 7
    365a:	ed 91       	ld	r30, X+
    365c:	fc 91       	ld	r31, X
    365e:	11 97       	sbiw	r26, 0x01	; 1
    3660:	e8 0f       	add	r30, r24
    3662:	f9 1f       	adc	r31, r25
    3664:	e0 81       	ld	r30, Z
		// move index down and decrement length
		buffer->dataindex++;
    3666:	01 96       	adiw	r24, 0x01	; 1
    3668:	17 96       	adiw	r26, 0x07	; 7
    366a:	9c 93       	st	X, r25
    366c:	8e 93       	st	-X, r24
    366e:	16 97       	sbiw	r26, 0x06	; 6
		if(buffer->dataindex >= buffer->size)
    3670:	12 96       	adiw	r26, 0x02	; 2
    3672:	2d 91       	ld	r18, X+
    3674:	3c 91       	ld	r19, X
    3676:	13 97       	sbiw	r26, 0x03	; 3
    3678:	82 17       	cp	r24, r18
    367a:	93 07       	cpc	r25, r19
    367c:	30 f0       	brcs	.+12     	; 0x368a <bufferGetFromFront+0x4e>
		{
			buffer->dataindex -= buffer->size;
    367e:	82 1b       	sub	r24, r18
    3680:	93 0b       	sbc	r25, r19
    3682:	17 96       	adiw	r26, 0x07	; 7
    3684:	9c 93       	st	X, r25
    3686:	8e 93       	st	-X, r24
    3688:	16 97       	sbiw	r26, 0x06	; 6
		}
		buffer->datalength--;
    368a:	14 96       	adiw	r26, 0x04	; 4
    368c:	8d 91       	ld	r24, X+
    368e:	9c 91       	ld	r25, X
    3690:	15 97       	sbiw	r26, 0x05	; 5
    3692:	01 97       	sbiw	r24, 0x01	; 1
    3694:	15 96       	adiw	r26, 0x05	; 5
    3696:	9c 93       	st	X, r25
    3698:	8e 93       	st	-X, r24
    369a:	14 97       	sbiw	r26, 0x04	; 4
	}
	// end critical section
	CRITICAL_SECTION_END;
    369c:	4f bf       	out	0x3f, r20	; 63
	// return
	return data;
}
    369e:	8e 2f       	mov	r24, r30
    36a0:	08 95       	ret

000036a2 <bufferDumpFromFront>:

void bufferDumpFromFront(cBuffer* buffer, unsigned short numbytes)
{
    36a2:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    36a4:	4f b7       	in	r20, 0x3f	; 63
    36a6:	f8 94       	cli
	// dump numbytes from the front of the buffer
	// are we dumping less than the entire buffer?
	if(numbytes < buffer->datalength)
    36a8:	84 81       	ldd	r24, Z+4	; 0x04
    36aa:	95 81       	ldd	r25, Z+5	; 0x05
    36ac:	68 17       	cp	r22, r24
    36ae:	79 07       	cpc	r23, r25
    36b0:	b0 f4       	brcc	.+44     	; 0x36de <bufferDumpFromFront+0x3c>
	{
		// move index down by numbytes and decrement length by numbytes
		buffer->dataindex += numbytes;
    36b2:	86 81       	ldd	r24, Z+6	; 0x06
    36b4:	97 81       	ldd	r25, Z+7	; 0x07
    36b6:	86 0f       	add	r24, r22
    36b8:	97 1f       	adc	r25, r23
    36ba:	97 83       	std	Z+7, r25	; 0x07
    36bc:	86 83       	std	Z+6, r24	; 0x06
		if(buffer->dataindex >= buffer->size)
    36be:	22 81       	ldd	r18, Z+2	; 0x02
    36c0:	33 81       	ldd	r19, Z+3	; 0x03
    36c2:	82 17       	cp	r24, r18
    36c4:	93 07       	cpc	r25, r19
    36c6:	20 f0       	brcs	.+8      	; 0x36d0 <bufferDumpFromFront+0x2e>
		{
			buffer->dataindex -= buffer->size;
    36c8:	82 1b       	sub	r24, r18
    36ca:	93 0b       	sbc	r25, r19
    36cc:	97 83       	std	Z+7, r25	; 0x07
    36ce:	86 83       	std	Z+6, r24	; 0x06
		}
		buffer->datalength -= numbytes;
    36d0:	84 81       	ldd	r24, Z+4	; 0x04
    36d2:	95 81       	ldd	r25, Z+5	; 0x05
    36d4:	86 1b       	sub	r24, r22
    36d6:	97 0b       	sbc	r25, r23
    36d8:	95 83       	std	Z+5, r25	; 0x05
    36da:	84 83       	std	Z+4, r24	; 0x04
    36dc:	02 c0       	rjmp	.+4      	; 0x36e2 <bufferDumpFromFront+0x40>
	}
	else
	{
		// flush the whole buffer
		buffer->datalength = 0;
    36de:	15 82       	std	Z+5, r1	; 0x05
    36e0:	14 82       	std	Z+4, r1	; 0x04
	}
	// end critical section
	CRITICAL_SECTION_END;
    36e2:	4f bf       	out	0x3f, r20	; 63
}
    36e4:	08 95       	ret

000036e6 <bufferGetAtIndex>:

unsigned char bufferGetAtIndex(cBuffer* buffer, unsigned short index)
{
    36e6:	fc 01       	movw	r30, r24
    36e8:	cb 01       	movw	r24, r22
	// begin critical section
	CRITICAL_SECTION_START;
    36ea:	2f b7       	in	r18, 0x3f	; 63
    36ec:	f8 94       	cli
	// return character at index in buffer
	unsigned char data = buffer->dataptr[(buffer->dataindex+index)%(buffer->size)];
	// end critical section
	CRITICAL_SECTION_END;
    36ee:	2f bf       	out	0x3f, r18	; 63
    36f0:	26 81       	ldd	r18, Z+6	; 0x06
    36f2:	37 81       	ldd	r19, Z+7	; 0x07
    36f4:	62 81       	ldd	r22, Z+2	; 0x02
    36f6:	73 81       	ldd	r23, Z+3	; 0x03
    36f8:	82 0f       	add	r24, r18
    36fa:	93 1f       	adc	r25, r19
    36fc:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3700:	01 90       	ld	r0, Z+
    3702:	f0 81       	ld	r31, Z
    3704:	e0 2d       	mov	r30, r0
    3706:	e8 0f       	add	r30, r24
    3708:	f9 1f       	adc	r31, r25
	return data;
}
    370a:	80 81       	ld	r24, Z
    370c:	08 95       	ret

0000370e <bufferAddToEnd>:

unsigned char bufferAddToEnd(cBuffer* buffer, unsigned char data)
{
    370e:	1f 93       	push	r17
    3710:	cf 93       	push	r28
    3712:	df 93       	push	r29
    3714:	ec 01       	movw	r28, r24
    3716:	16 2f       	mov	r17, r22
	// begin critical section
	CRITICAL_SECTION_START;
    3718:	4f b7       	in	r20, 0x3f	; 63
    371a:	f8 94       	cli
	// make sure the buffer has room
	if(buffer->datalength < buffer->size)
    371c:	2c 81       	ldd	r18, Y+4	; 0x04
    371e:	3d 81       	ldd	r19, Y+5	; 0x05
    3720:	6a 81       	ldd	r22, Y+2	; 0x02
    3722:	7b 81       	ldd	r23, Y+3	; 0x03
    3724:	26 17       	cp	r18, r22
    3726:	37 07       	cpc	r19, r23
    3728:	98 f4       	brcc	.+38     	; 0x3750 <bufferAddToEnd+0x42>
	{
		// save data byte at end of buffer
		buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
    372a:	8e 81       	ldd	r24, Y+6	; 0x06
    372c:	9f 81       	ldd	r25, Y+7	; 0x07
    372e:	82 0f       	add	r24, r18
    3730:	93 1f       	adc	r25, r19
    3732:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3736:	e8 81       	ld	r30, Y
    3738:	f9 81       	ldd	r31, Y+1	; 0x01
    373a:	e8 0f       	add	r30, r24
    373c:	f9 1f       	adc	r31, r25
    373e:	10 83       	st	Z, r17
		// increment the length
		buffer->datalength++;
    3740:	8c 81       	ldd	r24, Y+4	; 0x04
    3742:	9d 81       	ldd	r25, Y+5	; 0x05
    3744:	01 96       	adiw	r24, 0x01	; 1
    3746:	9d 83       	std	Y+5, r25	; 0x05
    3748:	8c 83       	std	Y+4, r24	; 0x04
		// end critical section
		CRITICAL_SECTION_END;
    374a:	4f bf       	out	0x3f, r20	; 63
    374c:	8f ef       	ldi	r24, 0xFF	; 255
    374e:	02 c0       	rjmp	.+4      	; 0x3754 <bufferAddToEnd+0x46>
		// return success
		return -1;
	}
	// end critical section
	CRITICAL_SECTION_END;
    3750:	4f bf       	out	0x3f, r20	; 63
    3752:	80 e0       	ldi	r24, 0x00	; 0
	// return failure
	return 0;
}
    3754:	df 91       	pop	r29
    3756:	cf 91       	pop	r28
    3758:	1f 91       	pop	r17
    375a:	08 95       	ret

0000375c <bufferIsNotFull>:

unsigned short bufferIsNotFull(cBuffer* buffer)
{
    375c:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    375e:	8f b7       	in	r24, 0x3f	; 63
    3760:	f8 94       	cli
	// check to see if the buffer has room
	// return true if there is room
	unsigned short bytesleft = (buffer->size - buffer->datalength);
	// end critical section
	CRITICAL_SECTION_END;
    3762:	8f bf       	out	0x3f, r24	; 63
    3764:	22 81       	ldd	r18, Z+2	; 0x02
    3766:	33 81       	ldd	r19, Z+3	; 0x03
    3768:	84 81       	ldd	r24, Z+4	; 0x04
    376a:	95 81       	ldd	r25, Z+5	; 0x05
    376c:	28 1b       	sub	r18, r24
    376e:	39 0b       	sbc	r19, r25
	return bytesleft;
}
    3770:	c9 01       	movw	r24, r18
    3772:	08 95       	ret

00003774 <bufferFlush>:

void bufferFlush(cBuffer* buffer)
{
    3774:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
    3776:	8f b7       	in	r24, 0x3f	; 63
    3778:	f8 94       	cli
	// flush contents of the buffer
	buffer->datalength = 0;
    377a:	15 82       	std	Z+5, r1	; 0x05
    377c:	14 82       	std	Z+4, r1	; 0x04
	// end critical section
	CRITICAL_SECTION_END;
    377e:	8f bf       	out	0x3f, r24	; 63
}
    3780:	08 95       	ret

00003782 <a2dInit>:
// functions

// initialize a2d converter
void a2dInit(void)
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
    3782:	aa e7       	ldi	r26, 0x7A	; 122
    3784:	b0 e0       	ldi	r27, 0x00	; 0
    3786:	8c 91       	ld	r24, X
    3788:	80 68       	ori	r24, 0x80	; 128
    378a:	8c 93       	st	X, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
    378c:	8c 91       	ld	r24, X
    378e:	8f 7d       	andi	r24, 0xDF	; 223
    3790:	8c 93       	st	X, r24
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    3792:	8c 91       	ld	r24, X
    3794:	88 7f       	andi	r24, 0xF8	; 248
    3796:	86 60       	ori	r24, 0x06	; 6
    3798:	8c 93       	st	X, r24
}

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    379a:	ec e7       	ldi	r30, 0x7C	; 124
    379c:	f0 e0       	ldi	r31, 0x00	; 0
    379e:	80 81       	ld	r24, Z
    37a0:	8f 73       	andi	r24, 0x3F	; 63
    37a2:	80 64       	ori	r24, 0x40	; 64
    37a4:	80 83       	st	Z, r24
{
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
    37a6:	80 81       	ld	r24, Z
    37a8:	8f 7d       	andi	r24, 0xDF	; 223
    37aa:	80 83       	st	Z, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
    37ac:	8c 91       	ld	r24, X
    37ae:	88 60       	ori	r24, 0x08	; 8
    37b0:	8c 93       	st	X, r24

	a2dCompleteFlag = FALSE;		// clear conversion complete flag
    37b2:	10 92 fc 0c 	sts	0x0CFC, r1
	sei();							// turn on interrupts (if not already on)
    37b6:	78 94       	sei
}
    37b8:	08 95       	ret

000037ba <a2dOff>:

// turn off a2d converter
void a2dOff(void)
{
	cbi(ADCSR, ADIE);				// disable ADC interrupts
    37ba:	ea e7       	ldi	r30, 0x7A	; 122
    37bc:	f0 e0       	ldi	r31, 0x00	; 0
    37be:	80 81       	ld	r24, Z
    37c0:	87 7f       	andi	r24, 0xF7	; 247
    37c2:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
    37c4:	80 81       	ld	r24, Z
    37c6:	8f 77       	andi	r24, 0x7F	; 127
    37c8:	80 83       	st	Z, r24
}
    37ca:	08 95       	ret

000037cc <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(unsigned char prescale)
{
	outb(ADCSR, ((inb(ADCSR) & ~ADC_PRESCALE_MASK) | prescale));
    37cc:	ea e7       	ldi	r30, 0x7A	; 122
    37ce:	f0 e0       	ldi	r31, 0x00	; 0
    37d0:	90 81       	ld	r25, Z
    37d2:	98 7f       	andi	r25, 0xF8	; 248
    37d4:	98 2b       	or	r25, r24
    37d6:	90 83       	st	Z, r25
}
    37d8:	08 95       	ret

000037da <a2dSetReference>:

// configure A2D converter voltage reference
void a2dSetReference(unsigned char ref)
{
	outb(ADMUX, ((inb(ADMUX) & ~ADC_REFERENCE_MASK) | (ref<<6)));
    37da:	ec e7       	ldi	r30, 0x7C	; 124
    37dc:	f0 e0       	ldi	r31, 0x00	; 0
    37de:	90 81       	ld	r25, Z
    37e0:	82 95       	swap	r24
    37e2:	88 0f       	add	r24, r24
    37e4:	88 0f       	add	r24, r24
    37e6:	80 7c       	andi	r24, 0xC0	; 192
    37e8:	9f 73       	andi	r25, 0x3F	; 63
    37ea:	98 2b       	or	r25, r24
    37ec:	90 83       	st	Z, r25
}
    37ee:	08 95       	ret

000037f0 <a2dSetChannel>:

// sets the a2d input channel
void a2dSetChannel(unsigned char ch)
{
	outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
    37f0:	ec e7       	ldi	r30, 0x7C	; 124
    37f2:	f0 e0       	ldi	r31, 0x00	; 0
    37f4:	90 81       	ld	r25, Z
    37f6:	8f 71       	andi	r24, 0x1F	; 31
    37f8:	90 7e       	andi	r25, 0xE0	; 224
    37fa:	89 2b       	or	r24, r25
    37fc:	80 83       	st	Z, r24
}
    37fe:	08 95       	ret

00003800 <a2dStartConvert>:

// start a conversion on the current a2d input channel
void a2dStartConvert(void)
{
	sbi(ADCSR, ADIF);	// clear hardware "conversion complete" flag 
    3800:	ea e7       	ldi	r30, 0x7A	; 122
    3802:	f0 e0       	ldi	r31, 0x00	; 0
    3804:	80 81       	ld	r24, Z
    3806:	80 61       	ori	r24, 0x10	; 16
    3808:	80 83       	st	Z, r24
	sbi(ADCSR, ADSC);	// start conversion
    380a:	80 81       	ld	r24, Z
    380c:	80 64       	ori	r24, 0x40	; 64
    380e:	80 83       	st	Z, r24
}
    3810:	08 95       	ret

00003812 <a2dIsComplete>:

// return TRUE if conversion is complete
u08 a2dIsComplete(void)
{
	return bit_is_set(ADCSR, ADSC);
    3812:	80 91 7a 00 	lds	r24, 0x007A
}
    3816:	80 74       	andi	r24, 0x40	; 64
    3818:	08 95       	ret

0000381a <a2dConvert10bit>:

// Perform a 10-bit conversion
// starts conversion, waits until conversion is done, and returns result
unsigned short a2dConvert10bit(unsigned char ch)
{
    381a:	98 2f       	mov	r25, r24
	a2dCompleteFlag = FALSE;				// clear conversion complete flag
    381c:	10 92 fc 0c 	sts	0x0CFC, r1

if (ch >= 8)
    3820:	88 30       	cpi	r24, 0x08	; 8
    3822:	20 f0       	brcs	.+8      	; 0x382c <a2dConvert10bit+0x12>
    ADCSRB |= _BV(MUX5);
    3824:	80 91 7b 00 	lds	r24, 0x007B
    3828:	88 60       	ori	r24, 0x08	; 8
    382a:	03 c0       	rjmp	.+6      	; 0x3832 <a2dConvert10bit+0x18>
else
    ADCSRB &= ~_BV(MUX5);
    382c:	80 91 7b 00 	lds	r24, 0x007B
    3830:	87 7f       	andi	r24, 0xF7	; 247
    3832:	80 93 7b 00 	sts	0x007B, r24

   outb(ADMUX, (inb(ADMUX) & ~7) | (ch & 7));   // set channel
    3836:	80 91 7c 00 	lds	r24, 0x007C
    383a:	97 70       	andi	r25, 0x07	; 7
    383c:	88 7f       	andi	r24, 0xF8	; 248
    383e:	89 2b       	or	r24, r25
    3840:	80 93 7c 00 	sts	0x007C, r24

	//outb(ADMUX, (inb(ADMUX) & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK));	// set channel
	sbi(ADCSR, ADIF);						// clear hardware "conversion complete" flag 
    3844:	80 91 7a 00 	lds	r24, 0x007A
    3848:	80 61       	ori	r24, 0x10	; 16
    384a:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);						// start conversion
    384e:	80 91 7a 00 	lds	r24, 0x007A
    3852:	80 64       	ori	r24, 0x40	; 64
    3854:	80 93 7a 00 	sts	0x007A, r24
	//while(!a2dCompleteFlag);				// wait until conversion complete
	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
	while( bit_is_set(ADCSR, ADSC) );		// wait until conversion complete
    3858:	80 91 7a 00 	lds	r24, 0x007A
    385c:	86 fd       	sbrc	r24, 6
    385e:	fc cf       	rjmp	.-8      	; 0x3858 <a2dConvert10bit+0x3e>

	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
	//return (inb(ADCL) | (inb(ADCH)<<8));	// read ADC (full 10 bits) //old version
	return ADC;//new version code
    3860:	20 91 78 00 	lds	r18, 0x0078
    3864:	30 91 79 00 	lds	r19, 0x0079
}
    3868:	c9 01       	movw	r24, r18
    386a:	08 95       	ret

0000386c <a2dConvert8bit>:
// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
unsigned char a2dConvert8bit(unsigned char ch)
{
	// do 10-bit conversion and return highest 8 bits
	return a2dConvert10bit(ch)>>2;			// return ADC MSB byte
    386c:	0e 94 0d 1c 	call	0x381a	; 0x381a <a2dConvert10bit>
    3870:	96 95       	lsr	r25
    3872:	87 95       	ror	r24
    3874:	96 95       	lsr	r25
    3876:	87 95       	ror	r24
}
    3878:	08 95       	ret

0000387a <__vector_29>:

//! Interrupt handler for ADC complete interrupt.
SIGNAL(SIG_ADC)
{
    387a:	1f 92       	push	r1
    387c:	0f 92       	push	r0
    387e:	0f b6       	in	r0, 0x3f	; 63
    3880:	0f 92       	push	r0
    3882:	11 24       	eor	r1, r1
    3884:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
    3886:	8f ef       	ldi	r24, 0xFF	; 255
    3888:	80 93 fc 0c 	sts	0x0CFC, r24
}
    388c:	8f 91       	pop	r24
    388e:	0f 90       	pop	r0
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	0f 90       	pop	r0
    3894:	1f 90       	pop	r1
    3896:	18 95       	reti

00003898 <rprintfInit>:
// *** rprintf initialization ***
// you must call this function once and supply the character output
// routine before using other functions in this library
void rprintfInit(void (*putchar_func)(unsigned char c))
{
	rputchar = putchar_func;
    3898:	90 93 8f 0c 	sts	0x0C8F, r25
    389c:	80 93 8e 0c 	sts	0x0C8E, r24
}
    38a0:	08 95       	ret

000038a2 <rprintfChar>:

// *** rprintfChar ***
// send a character/byte to the current output device
void rprintfChar(unsigned char c)
{
    38a2:	1f 93       	push	r17
    38a4:	18 2f       	mov	r17, r24
	// do LF -> CR/LF translation
	if(c == '\n')
    38a6:	8a 30       	cpi	r24, 0x0A	; 10
    38a8:	31 f4       	brne	.+12     	; 0x38b6 <rprintfChar+0x14>
		rputchar('\r');
    38aa:	e0 91 8e 0c 	lds	r30, 0x0C8E
    38ae:	f0 91 8f 0c 	lds	r31, 0x0C8F
    38b2:	8d e0       	ldi	r24, 0x0D	; 13
    38b4:	09 95       	icall
	// send character
	rputchar(c);
    38b6:	e0 91 8e 0c 	lds	r30, 0x0C8E
    38ba:	f0 91 8f 0c 	lds	r31, 0x0C8F
    38be:	81 2f       	mov	r24, r17
    38c0:	09 95       	icall
}
    38c2:	1f 91       	pop	r17
    38c4:	08 95       	ret

000038c6 <rprintfStr>:

// *** rprintfStr ***
// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
    38c6:	cf 93       	push	r28
    38c8:	df 93       	push	r29
    38ca:	ec 01       	movw	r28, r24
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;
    38cc:	00 97       	sbiw	r24, 0x00	; 0
    38ce:	21 f4       	brne	.+8      	; 0x38d8 <rprintfStr+0x12>
    38d0:	06 c0       	rjmp	.+12     	; 0x38de <rprintfStr+0x18>

	// print the string until a null-terminator
	while (*str)
		rprintfChar(*str++);
    38d2:	21 96       	adiw	r28, 0x01	; 1
    38d4:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
	// send a string stored in RAM
	// check to make sure we have a good pointer
	if (!str) return;

	// print the string until a null-terminator
	while (*str)
    38d8:	88 81       	ld	r24, Y
    38da:	88 23       	and	r24, r24
    38dc:	d1 f7       	brne	.-12     	; 0x38d2 <rprintfStr+0xc>
		rprintfChar(*str++);
}
    38de:	df 91       	pop	r29
    38e0:	cf 91       	pop	r28
    38e2:	08 95       	ret

000038e4 <rprintfStrLen>:
// *** rprintfStrLen ***
// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], unsigned int start, unsigned int len)
{
    38e4:	ef 92       	push	r14
    38e6:	ff 92       	push	r15
    38e8:	0f 93       	push	r16
    38ea:	1f 93       	push	r17
    38ec:	cf 93       	push	r28
    38ee:	df 93       	push	r29
    38f0:	8c 01       	movw	r16, r24
    38f2:	7a 01       	movw	r14, r20
	register int i=0;

	// check to make sure we have a good pointer
	if (!str) return;
    38f4:	00 97       	sbiw	r24, 0x00	; 0
    38f6:	e9 f0       	breq	.+58     	; 0x3932 <rprintfStrLen+0x4e>
    38f8:	20 e0       	ldi	r18, 0x00	; 0
    38fa:	30 e0       	ldi	r19, 0x00	; 0
	// spin through characters up to requested start
	// keep going as long as there's no null
	while((i++<start) && (*str++));
    38fc:	26 17       	cp	r18, r22
    38fe:	37 07       	cpc	r19, r23
    3900:	38 f4       	brcc	.+14     	; 0x3910 <rprintfStrLen+0x2c>
    3902:	f8 01       	movw	r30, r16
    3904:	81 91       	ld	r24, Z+
    3906:	8f 01       	movw	r16, r30
    3908:	2f 5f       	subi	r18, 0xFF	; 255
    390a:	3f 4f       	sbci	r19, 0xFF	; 255
    390c:	88 23       	and	r24, r24
    390e:	b1 f7       	brne	.-20     	; 0x38fc <rprintfStrLen+0x18>
    3910:	c0 e0       	ldi	r28, 0x00	; 0
    3912:	d0 e0       	ldi	r29, 0x00	; 0
    3914:	0b c0       	rjmp	.+22     	; 0x392c <rprintfStrLen+0x48>
	// then print exactly len characters
	for(i=0; i<len; i++)
	{
		// print data out of the string as long as we haven't reached a null yet
		// at the null, start printing spaces
		if(*str)
    3916:	f8 01       	movw	r30, r16
    3918:	80 81       	ld	r24, Z
    391a:	88 23       	and	r24, r24
    391c:	19 f0       	breq	.+6      	; 0x3924 <rprintfStrLen+0x40>
			rprintfChar(*str++);
    391e:	0f 5f       	subi	r16, 0xFF	; 255
    3920:	1f 4f       	sbci	r17, 0xFF	; 255
    3922:	01 c0       	rjmp	.+2      	; 0x3926 <rprintfStrLen+0x42>
		else
			rprintfChar(' ');
    3924:	80 e2       	ldi	r24, 0x20	; 32
    3926:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
//		// keep steping through string as long as there's no null
//		if(*str) str++;
//	}

	// then print exactly len characters
	for(i=0; i<len; i++)
    392a:	21 96       	adiw	r28, 0x01	; 1
    392c:	ce 15       	cp	r28, r14
    392e:	df 05       	cpc	r29, r15
    3930:	90 f3       	brcs	.-28     	; 0x3916 <rprintfStrLen+0x32>
			rprintfChar(*str++);
		else
			rprintfChar(' ');
	}

}
    3932:	df 91       	pop	r29
    3934:	cf 91       	pop	r28
    3936:	1f 91       	pop	r17
    3938:	0f 91       	pop	r16
    393a:	ff 90       	pop	r15
    393c:	ef 90       	pop	r14
    393e:	08 95       	ret

00003940 <rprintfProgStr>:

// *** rprintfProgStr ***
// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
    3940:	cf 93       	push	r28
    3942:	df 93       	push	r29
    3944:	ec 01       	movw	r28, r24
	// print a string stored in program memory
	register char c;

	// check to make sure we have a good pointer
	if (!str) return;
    3946:	00 97       	sbiw	r24, 0x00	; 0
    3948:	19 f4       	brne	.+6      	; 0x3950 <rprintfProgStr+0x10>
    394a:	07 c0       	rjmp	.+14     	; 0x395a <rprintfProgStr+0x1a>
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
		rprintfChar(c);
    394c:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3950:	fe 01       	movw	r30, r28

	// check to make sure we have a good pointer
	if (!str) return;
	
	// print the string until the null-terminator
	while((c = pgm_read_byte(str++)))
    3952:	21 96       	adiw	r28, 0x01	; 1
    3954:	84 91       	lpm	r24, Z+
    3956:	88 23       	and	r24, r24
    3958:	c9 f7       	brne	.-14     	; 0x394c <rprintfProgStr+0xc>
		rprintfChar(c);
}
    395a:	df 91       	pop	r29
    395c:	cf 91       	pop	r28
    395e:	08 95       	ret

00003960 <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
    3960:	8a e0       	ldi	r24, 0x0A	; 10
    3962:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
}
    3966:	08 95       	ret

00003968 <rprintfu04>:
//	char Character = data&0x0f;
//	if (Character>9)
//		Character+='A'-10;
//	else
//		Character+='0';
	rprintfChar(hexchar(data));
    3968:	e8 2f       	mov	r30, r24
    396a:	f0 e0       	ldi	r31, 0x00	; 0
    396c:	ef 70       	andi	r30, 0x0F	; 15
    396e:	f0 70       	andi	r31, 0x00	; 0
    3970:	e2 5d       	subi	r30, 0xD2	; 210
    3972:	fe 4f       	sbci	r31, 0xFE	; 254
    3974:	e4 91       	lpm	r30, Z+
    3976:	8e 2f       	mov	r24, r30
    3978:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
}
    397c:	08 95       	ret

0000397e <rprintfu08>:

// *** rprintfu08 ***
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(unsigned char data)
{
    397e:	1f 93       	push	r17
    3980:	18 2f       	mov	r17, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
    3982:	82 95       	swap	r24
    3984:	8f 70       	andi	r24, 0x0F	; 15
    3986:	0e 94 b4 1c 	call	0x3968	; 0x3968 <rprintfu04>
	rprintfu04(data);
    398a:	81 2f       	mov	r24, r17
    398c:	0e 94 b4 1c 	call	0x3968	; 0x3968 <rprintfu04>
}
    3990:	1f 91       	pop	r17
    3992:	08 95       	ret

00003994 <rprintfu16>:

// *** rprintfu16 ***
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(unsigned short data)
{
    3994:	1f 93       	push	r17
    3996:	18 2f       	mov	r17, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
    3998:	89 2f       	mov	r24, r25
    399a:	0e 94 bf 1c 	call	0x397e	; 0x397e <rprintfu08>
	rprintfu08(data);
    399e:	81 2f       	mov	r24, r17
    39a0:	0e 94 bf 1c 	call	0x397e	; 0x397e <rprintfu08>
}
    39a4:	1f 91       	pop	r17
    39a6:	08 95       	ret

000039a8 <rprintfu32>:

// *** rprintfu32 ***
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(unsigned long data)
{
    39a8:	ef 92       	push	r14
    39aa:	ff 92       	push	r15
    39ac:	0f 93       	push	r16
    39ae:	1f 93       	push	r17
    39b0:	7b 01       	movw	r14, r22
    39b2:	8c 01       	movw	r16, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
    39b4:	c8 01       	movw	r24, r16
    39b6:	aa 27       	eor	r26, r26
    39b8:	bb 27       	eor	r27, r27
    39ba:	0e 94 ca 1c 	call	0x3994	; 0x3994 <rprintfu16>
	rprintfu16(data);
    39be:	c7 01       	movw	r24, r14
    39c0:	0e 94 ca 1c 	call	0x3994	; 0x3994 <rprintfu16>
}
    39c4:	1f 91       	pop	r17
    39c6:	0f 91       	pop	r16
    39c8:	ff 90       	pop	r15
    39ca:	ef 90       	pop	r14
    39cc:	08 95       	ret

000039ce <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
    39ce:	2f 92       	push	r2
    39d0:	3f 92       	push	r3
    39d2:	4f 92       	push	r4
    39d4:	5f 92       	push	r5
    39d6:	6f 92       	push	r6
    39d8:	7f 92       	push	r7
    39da:	8f 92       	push	r8
    39dc:	9f 92       	push	r9
    39de:	af 92       	push	r10
    39e0:	bf 92       	push	r11
    39e2:	cf 92       	push	r12
    39e4:	df 92       	push	r13
    39e6:	ef 92       	push	r14
    39e8:	ff 92       	push	r15
    39ea:	0f 93       	push	r16
    39ec:	1f 93       	push	r17
    39ee:	df 93       	push	r29
    39f0:	cf 93       	push	r28
    39f2:	cd b7       	in	r28, 0x3d	; 61
    39f4:	de b7       	in	r29, 0x3e	; 62
    39f6:	a3 97       	sbiw	r28, 0x23	; 35
    39f8:	0f b6       	in	r0, 0x3f	; 63
    39fa:	f8 94       	cli
    39fc:	de bf       	out	0x3e, r29	; 62
    39fe:	0f be       	out	0x3f, r0	; 63
    3a00:	cd bf       	out	0x3d, r28	; 61
    3a02:	6a a3       	std	Y+34, r22	; 0x22
    3a04:	24 2e       	mov	r2, r20
    3a06:	2b a3       	std	Y+35, r18	; 0x23
    3a08:	37 01       	movw	r6, r14
    3a0a:	48 01       	movw	r8, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) )
    3a0c:	44 23       	and	r20, r20
    3a0e:	51 f0       	breq	.+20     	; 0x3a24 <rprintfNum+0x56>
    3a10:	17 ff       	sbrs	r17, 7
    3a12:	08 c0       	rjmp	.+16     	; 0x3a24 <rprintfNum+0x56>
	{
		x = -n;
    3a14:	ee 24       	eor	r14, r14
    3a16:	ff 24       	eor	r15, r15
    3a18:	87 01       	movw	r16, r14
    3a1a:	e6 18       	sub	r14, r6
    3a1c:	f7 08       	sbc	r15, r7
    3a1e:	08 09       	sbc	r16, r8
    3a20:	19 09       	sbc	r17, r9
    3a22:	02 c0       	rjmp	.+4      	; 0x3a28 <rprintfNum+0x5a>
	}
	else
	{
	 	x = n;
    3a24:	84 01       	movw	r16, r8
    3a26:	73 01       	movw	r14, r6
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
    3a28:	2a a1       	ldd	r18, Y+34	; 0x22
    3a2a:	21 50       	subi	r18, 0x01	; 1
    3a2c:	90 e0       	ldi	r25, 0x00	; 0
    3a2e:	21 10       	cpse	r2, r1
    3a30:	91 e0       	ldi	r25, 0x01	; 1
    3a32:	29 1b       	sub	r18, r25
    3a34:	29 a3       	std	Y+33, r18	; 0x21
  	p = buf + sizeof (buf);
  	*--p = '\0';
    3a36:	18 a2       	std	Y+32, r1	; 0x20
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
    3a38:	a8 2e       	mov	r10, r24
    3a3a:	bb 24       	eor	r11, r11
    3a3c:	cc 24       	eor	r12, r12
    3a3e:	dd 24       	eor	r13, r13
    3a40:	c8 01       	movw	r24, r16
    3a42:	b7 01       	movw	r22, r14
    3a44:	a6 01       	movw	r20, r12
    3a46:	95 01       	movw	r18, r10
    3a48:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <__udivmodsi4>
    3a4c:	fb 01       	movw	r30, r22
    3a4e:	ef 70       	andi	r30, 0x0F	; 15
    3a50:	f0 70       	andi	r31, 0x00	; 0
    3a52:	e2 5d       	subi	r30, 0xD2	; 210
    3a54:	fe 4f       	sbci	r31, 0xFE	; 254
    3a56:	64 91       	lpm	r22, Z+
    3a58:	6f 8f       	std	Y+31, r22	; 0x1f
    3a5a:	c8 01       	movw	r24, r16
    3a5c:	b7 01       	movw	r22, r14
    3a5e:	a6 01       	movw	r20, r12
    3a60:	95 01       	movw	r18, r10
    3a62:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <__udivmodsi4>
    3a66:	c9 01       	movw	r24, r18
    3a68:	da 01       	movw	r26, r20
    3a6a:	7c 01       	movw	r14, r24
    3a6c:	8d 01       	movw	r16, r26
    3a6e:	9e e1       	ldi	r25, 0x1E	; 30
    3a70:	49 2e       	mov	r4, r25
    3a72:	51 2c       	mov	r5, r1
    3a74:	4c 0e       	add	r4, r28
    3a76:	5d 1e       	adc	r5, r29
    3a78:	39 a0       	ldd	r3, Y+33	; 0x21
    3a7a:	25 c0       	rjmp	.+74     	; 0x3ac6 <rprintfNum+0xf8>
	// calculate remaining digits
	while(count--)
	{
		if(x != 0)
    3a7c:	e1 14       	cp	r14, r1
    3a7e:	f1 04       	cpc	r15, r1
    3a80:	01 05       	cpc	r16, r1
    3a82:	11 05       	cpc	r17, r1
    3a84:	c9 f0       	breq	.+50     	; 0x3ab8 <rprintfNum+0xea>
		{
			// calculate next digit
			*--p = hexchar(x%base); x /= base;
    3a86:	c8 01       	movw	r24, r16
    3a88:	b7 01       	movw	r22, r14
    3a8a:	a6 01       	movw	r20, r12
    3a8c:	95 01       	movw	r18, r10
    3a8e:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <__udivmodsi4>
    3a92:	fb 01       	movw	r30, r22
    3a94:	ef 70       	andi	r30, 0x0F	; 15
    3a96:	f0 70       	andi	r31, 0x00	; 0
    3a98:	e2 5d       	subi	r30, 0xD2	; 210
    3a9a:	fe 4f       	sbci	r31, 0xFE	; 254
    3a9c:	64 91       	lpm	r22, Z+
    3a9e:	f2 01       	movw	r30, r4
    3aa0:	60 83       	st	Z, r22
    3aa2:	c8 01       	movw	r24, r16
    3aa4:	b7 01       	movw	r22, r14
    3aa6:	a6 01       	movw	r20, r12
    3aa8:	95 01       	movw	r18, r10
    3aaa:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <__udivmodsi4>
    3aae:	c9 01       	movw	r24, r18
    3ab0:	da 01       	movw	r26, r20
    3ab2:	7c 01       	movw	r14, r24
    3ab4:	8d 01       	movw	r16, r26
    3ab6:	03 c0       	rjmp	.+6      	; 0x3abe <rprintfNum+0xf0>
		}
		else
		{
			// no more digits left, pad out to desired length
			*--p = padchar;
    3ab8:	2b a1       	ldd	r18, Y+35	; 0x23
    3aba:	f2 01       	movw	r30, r4
    3abc:	20 83       	st	Z, r18
    3abe:	3a 94       	dec	r3
    3ac0:	08 94       	sec
    3ac2:	41 08       	sbc	r4, r1
    3ac4:	51 08       	sbc	r5, r1
	
	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x%base); x /= base;
	// calculate remaining digits
	while(count--)
    3ac6:	33 20       	and	r3, r3
    3ac8:	c9 f6       	brne	.-78     	; 0x3a7c <rprintfNum+0xae>
    3aca:	ce 01       	movw	r24, r28
    3acc:	4f 96       	adiw	r24, 0x1f	; 31
    3ace:	8c 01       	movw	r16, r24
    3ad0:	e9 a1       	ldd	r30, Y+33	; 0x21
    3ad2:	0e 1b       	sub	r16, r30
    3ad4:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )
    3ad6:	22 20       	and	r2, r2
    3ad8:	f1 f0       	breq	.+60     	; 0x3b16 <rprintfNum+0x148>
	{
		if(n < 0)
    3ada:	97 fe       	sbrs	r9, 7
    3adc:	05 c0       	rjmp	.+10     	; 0x3ae8 <rprintfNum+0x11a>
		{
   			*--p = '-';
    3ade:	8d e2       	ldi	r24, 0x2D	; 45
    3ae0:	f8 01       	movw	r30, r16
    3ae2:	82 93       	st	-Z, r24
    3ae4:	8f 01       	movw	r16, r30
    3ae6:	17 c0       	rjmp	.+46     	; 0x3b16 <rprintfNum+0x148>
    3ae8:	c8 01       	movw	r24, r16
    3aea:	01 97       	sbiw	r24, 0x01	; 1
		}
		else if(n > 0)
    3aec:	61 14       	cp	r6, r1
    3aee:	71 04       	cpc	r7, r1
    3af0:	81 04       	cpc	r8, r1
    3af2:	91 04       	cpc	r9, r1
    3af4:	19 f0       	breq	.+6      	; 0x3afc <rprintfNum+0x12e>
		{
	   		*--p = '+';
    3af6:	8c 01       	movw	r16, r24
    3af8:	8b e2       	ldi	r24, 0x2B	; 43
    3afa:	02 c0       	rjmp	.+4      	; 0x3b00 <rprintfNum+0x132>
		}
		else
		{
	   		*--p = ' ';
    3afc:	8c 01       	movw	r16, r24
    3afe:	80 e2       	ldi	r24, 0x20	; 32
    3b00:	f8 01       	movw	r30, r16
    3b02:	80 83       	st	Z, r24
    3b04:	08 c0       	rjmp	.+16     	; 0x3b16 <rprintfNum+0x148>

	// print the string right-justified
	count = numDigits;
	while(count--)
	{
		rprintfChar(*p++);
    3b06:	f8 01       	movw	r30, r16
    3b08:	81 91       	ld	r24, Z+
    3b0a:	8f 01       	movw	r16, r30
    3b0c:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3b10:	fa a1       	ldd	r31, Y+34	; 0x22
    3b12:	f1 50       	subi	r31, 0x01	; 1
    3b14:	fa a3       	std	Y+34, r31	; 0x22
		}
	}

	// print the string right-justified
	count = numDigits;
	while(count--)
    3b16:	2a a1       	ldd	r18, Y+34	; 0x22
    3b18:	22 23       	and	r18, r18
    3b1a:	a9 f7       	brne	.-22     	; 0x3b06 <rprintfNum+0x138>
	{
		rprintfChar(*p++);
	}
}
    3b1c:	a3 96       	adiw	r28, 0x23	; 35
    3b1e:	0f b6       	in	r0, 0x3f	; 63
    3b20:	f8 94       	cli
    3b22:	de bf       	out	0x3e, r29	; 62
    3b24:	0f be       	out	0x3f, r0	; 63
    3b26:	cd bf       	out	0x3d, r28	; 61
    3b28:	cf 91       	pop	r28
    3b2a:	df 91       	pop	r29
    3b2c:	1f 91       	pop	r17
    3b2e:	0f 91       	pop	r16
    3b30:	ff 90       	pop	r15
    3b32:	ef 90       	pop	r14
    3b34:	df 90       	pop	r13
    3b36:	cf 90       	pop	r12
    3b38:	bf 90       	pop	r11
    3b3a:	af 90       	pop	r10
    3b3c:	9f 90       	pop	r9
    3b3e:	8f 90       	pop	r8
    3b40:	7f 90       	pop	r7
    3b42:	6f 90       	pop	r6
    3b44:	5f 90       	pop	r5
    3b46:	4f 90       	pop	r4
    3b48:	3f 90       	pop	r3
    3b4a:	2f 90       	pop	r2
    3b4c:	08 95       	ret

00003b4e <rprintfFloat>:

#ifdef RPRINTF_FLOAT
// *** rprintfFloat ***
// floating-point print
void rprintfFloat(char numDigits, double x)
{
    3b4e:	4f 92       	push	r4
    3b50:	5f 92       	push	r5
    3b52:	6f 92       	push	r6
    3b54:	7f 92       	push	r7
    3b56:	8f 92       	push	r8
    3b58:	9f 92       	push	r9
    3b5a:	af 92       	push	r10
    3b5c:	bf 92       	push	r11
    3b5e:	cf 92       	push	r12
    3b60:	df 92       	push	r13
    3b62:	ef 92       	push	r14
    3b64:	ff 92       	push	r15
    3b66:	0f 93       	push	r16
    3b68:	1f 93       	push	r17
    3b6a:	cf 93       	push	r28
    3b6c:	df 93       	push	r29
    3b6e:	48 2e       	mov	r4, r24
    3b70:	5a 01       	movw	r10, r20
    3b72:	6b 01       	movw	r12, r22
	double place = 1.0;
	
	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
    3b74:	cb 01       	movw	r24, r22
    3b76:	ba 01       	movw	r22, r20
    3b78:	20 e0       	ldi	r18, 0x00	; 0
    3b7a:	30 e0       	ldi	r19, 0x00	; 0
    3b7c:	40 e0       	ldi	r20, 0x00	; 0
    3b7e:	50 e0       	ldi	r21, 0x00	; 0
    3b80:	0e 94 b0 22 	call	0x4560	; 0x4560 <__gtsf2>
    3b84:	18 16       	cp	r1, r24
    3b86:	1c f4       	brge	.+6      	; 0x3b8e <rprintfFloat+0x40>
    3b88:	35 01       	movw	r6, r10
    3b8a:	46 01       	movw	r8, r12
    3b8c:	06 c0       	rjmp	.+12     	; 0x3b9a <rprintfFloat+0x4c>
    3b8e:	35 01       	movw	r6, r10
    3b90:	46 01       	movw	r8, r12
    3b92:	97 fa       	bst	r9, 7
    3b94:	90 94       	com	r9
    3b96:	97 f8       	bld	r9, 7
    3b98:	90 94       	com	r9
    3b9a:	0f 2e       	mov	r0, r31
    3b9c:	f0 e0       	ldi	r31, 0x00	; 0
    3b9e:	ef 2e       	mov	r14, r31
    3ba0:	f0 e0       	ldi	r31, 0x00	; 0
    3ba2:	ff 2e       	mov	r15, r31
    3ba4:	f0 e8       	ldi	r31, 0x80	; 128
    3ba6:	0f 2f       	mov	r16, r31
    3ba8:	ff e3       	ldi	r31, 0x3F	; 63
    3baa:	1f 2f       	mov	r17, r31
    3bac:	f0 2d       	mov	r31, r0
    3bae:	55 24       	eor	r5, r5
	
	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
    3bb0:	c4 01       	movw	r24, r8
    3bb2:	b3 01       	movw	r22, r6
    3bb4:	a8 01       	movw	r20, r16
    3bb6:	97 01       	movw	r18, r14
    3bb8:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divsf3>
    3bbc:	20 e0       	ldi	r18, 0x00	; 0
    3bbe:	30 e0       	ldi	r19, 0x00	; 0
    3bc0:	40 e2       	ldi	r20, 0x20	; 32
    3bc2:	51 e4       	ldi	r21, 0x41	; 65
    3bc4:	0e 94 10 23 	call	0x4620	; 0x4620 <__ltsf2>
    3bc8:	87 fd       	sbrc	r24, 7
    3bca:	0e c0       	rjmp	.+28     	; 0x3be8 <rprintfFloat+0x9a>
			break;
		else
			place *= 10.0;
    3bcc:	c8 01       	movw	r24, r16
    3bce:	b7 01       	movw	r22, r14
    3bd0:	20 e0       	ldi	r18, 0x00	; 0
    3bd2:	30 e0       	ldi	r19, 0x00	; 0
    3bd4:	40 e2       	ldi	r20, 0x20	; 32
    3bd6:	51 e4       	ldi	r21, 0x41	; 65
    3bd8:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__mulsf3>
    3bdc:	7b 01       	movw	r14, r22
    3bde:	8c 01       	movw	r16, r24
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
	
	// find starting digit place
	for(i=0; i<15; i++)
    3be0:	53 94       	inc	r5
    3be2:	8f e0       	ldi	r24, 0x0F	; 15
    3be4:	58 16       	cp	r5, r24
    3be6:	21 f7       	brne	.-56     	; 0x3bb0 <rprintfFloat+0x62>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
    3be8:	c6 01       	movw	r24, r12
    3bea:	b5 01       	movw	r22, r10
    3bec:	20 e0       	ldi	r18, 0x00	; 0
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	40 e0       	ldi	r20, 0x00	; 0
    3bf2:	50 e0       	ldi	r21, 0x00	; 0
    3bf4:	0e 94 10 23 	call	0x4620	; 0x4620 <__ltsf2>
    3bf8:	88 23       	and	r24, r24
    3bfa:	14 f4       	brge	.+4      	; 0x3c00 <rprintfFloat+0xb2>
		rprintfChar('-');
    3bfc:	8d e2       	ldi	r24, 0x2D	; 45
    3bfe:	01 c0       	rjmp	.+2      	; 0x3c02 <rprintfFloat+0xb4>
	else
		rprintfChar('+');
    3c00:	8b e2       	ldi	r24, 0x2B	; 43
    3c02:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3c06:	dd 24       	eor	r13, r13
    3c08:	aa 24       	eor	r10, r10
    3c0a:	56 c0       	rjmp	.+172    	; 0x3cb8 <rprintfFloat+0x16a>

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
    3c0c:	c4 01       	movw	r24, r8
    3c0e:	b3 01       	movw	r22, r6
    3c10:	a8 01       	movw	r20, r16
    3c12:	97 01       	movw	r18, r14
    3c14:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divsf3>
    3c18:	0e 94 04 1f 	call	0x3e08	; 0x3e08 <__fixunssfsi>
    3c1c:	b6 2e       	mov	r11, r22

		if(digit | firstplace | (place == 1.0))
    3c1e:	d6 2a       	or	r13, r22
    3c20:	cd 2d       	mov	r28, r13
    3c22:	d0 e0       	ldi	r29, 0x00	; 0
    3c24:	cc 24       	eor	r12, r12
    3c26:	dd 24       	eor	r13, r13
    3c28:	c8 01       	movw	r24, r16
    3c2a:	b7 01       	movw	r22, r14
    3c2c:	20 e0       	ldi	r18, 0x00	; 0
    3c2e:	30 e0       	ldi	r19, 0x00	; 0
    3c30:	40 e8       	ldi	r20, 0x80	; 128
    3c32:	5f e3       	ldi	r21, 0x3F	; 63
    3c34:	0e 94 80 22 	call	0x4500	; 0x4500 <__eqsf2>
    3c38:	88 23       	and	r24, r24
    3c3a:	19 f4       	brne	.+6      	; 0x3c42 <rprintfFloat+0xf4>
    3c3c:	21 e0       	ldi	r18, 0x01	; 1
    3c3e:	c2 2e       	mov	r12, r18
    3c40:	d1 2c       	mov	r13, r1
    3c42:	cc 29       	or	r28, r12
    3c44:	dd 29       	or	r29, r13
    3c46:	cd 2b       	or	r28, r29
    3c48:	39 f0       	breq	.+14     	; 0x3c58 <rprintfFloat+0x10a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
    3c4a:	8b 2d       	mov	r24, r11
    3c4c:	80 5d       	subi	r24, 0xD0	; 208
    3c4e:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3c52:	dd 24       	eor	r13, r13
    3c54:	da 94       	dec	r13
    3c56:	04 c0       	rjmp	.+8      	; 0x3c60 <rprintfFloat+0x112>
		}
		else
			rprintfChar(' ');
    3c58:	80 e2       	ldi	r24, 0x20	; 32
    3c5a:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3c5e:	dd 24       	eor	r13, r13
		
		if(place == 1.0)
    3c60:	c8 01       	movw	r24, r16
    3c62:	b7 01       	movw	r22, r14
    3c64:	20 e0       	ldi	r18, 0x00	; 0
    3c66:	30 e0       	ldi	r19, 0x00	; 0
    3c68:	40 e8       	ldi	r20, 0x80	; 128
    3c6a:	5f e3       	ldi	r21, 0x3F	; 63
    3c6c:	0e 94 80 22 	call	0x4500	; 0x4500 <__eqsf2>
    3c70:	88 23       	and	r24, r24
    3c72:	19 f4       	brne	.+6      	; 0x3c7a <rprintfFloat+0x12c>
		{
			rprintfChar('.');
    3c74:	8e e2       	ldi	r24, 0x2E	; 46
    3c76:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
		}
		
		x -= (digit*place);
    3c7a:	6b 2d       	mov	r22, r11
    3c7c:	70 e0       	ldi	r23, 0x00	; 0
    3c7e:	88 27       	eor	r24, r24
    3c80:	77 fd       	sbrc	r23, 7
    3c82:	80 95       	com	r24
    3c84:	98 2f       	mov	r25, r24
    3c86:	0e 94 40 23 	call	0x4680	; 0x4680 <__floatsisf>
    3c8a:	a8 01       	movw	r20, r16
    3c8c:	97 01       	movw	r18, r14
    3c8e:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__mulsf3>
    3c92:	9b 01       	movw	r18, r22
    3c94:	ac 01       	movw	r20, r24
    3c96:	c4 01       	movw	r24, r8
    3c98:	b3 01       	movw	r22, r6
    3c9a:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <__subsf3>
    3c9e:	3b 01       	movw	r6, r22
    3ca0:	4c 01       	movw	r8, r24
		place /= 10.0;
    3ca2:	c8 01       	movw	r24, r16
    3ca4:	b7 01       	movw	r22, r14
    3ca6:	20 e0       	ldi	r18, 0x00	; 0
    3ca8:	30 e0       	ldi	r19, 0x00	; 0
    3caa:	40 e2       	ldi	r20, 0x20	; 32
    3cac:	51 e4       	ldi	r21, 0x41	; 65
    3cae:	0e 94 d4 21 	call	0x43a8	; 0x43a8 <__divsf3>
    3cb2:	7b 01       	movw	r14, r22
    3cb4:	8c 01       	movw	r16, r24
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
    3cb6:	a3 94       	inc	r10
    3cb8:	a4 14       	cp	r10, r4
    3cba:	08 f4       	brcc	.+2      	; 0x3cbe <rprintfFloat+0x170>
    3cbc:	a7 cf       	rjmp	.-178    	; 0x3c0c <rprintfFloat+0xbe>
		}
		
		x -= (digit*place);
		place /= 10.0;
	}
}
    3cbe:	df 91       	pop	r29
    3cc0:	cf 91       	pop	r28
    3cc2:	1f 91       	pop	r17
    3cc4:	0f 91       	pop	r16
    3cc6:	ff 90       	pop	r15
    3cc8:	ef 90       	pop	r14
    3cca:	df 90       	pop	r13
    3ccc:	cf 90       	pop	r12
    3cce:	bf 90       	pop	r11
    3cd0:	af 90       	pop	r10
    3cd2:	9f 90       	pop	r9
    3cd4:	8f 90       	pop	r8
    3cd6:	7f 90       	pop	r7
    3cd8:	6f 90       	pop	r6
    3cda:	5f 90       	pop	r5
    3cdc:	4f 90       	pop	r4
    3cde:	08 95       	ret

00003ce0 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
    3ce0:	7f 92       	push	r7
    3ce2:	8f 92       	push	r8
    3ce4:	9f 92       	push	r9
    3ce6:	af 92       	push	r10
    3ce8:	bf 92       	push	r11
    3cea:	cf 92       	push	r12
    3cec:	df 92       	push	r13
    3cee:	ef 92       	push	r14
    3cf0:	ff 92       	push	r15
    3cf2:	0f 93       	push	r16
    3cf4:	1f 93       	push	r17
    3cf6:	df 93       	push	r29
    3cf8:	cf 93       	push	r28
    3cfa:	cd b7       	in	r28, 0x3d	; 61
    3cfc:	de b7       	in	r29, 0x3e	; 62
    3cfe:	78 88       	ldd	r7, Y+16	; 0x10
    3d00:	c9 88       	ldd	r12, Y+17	; 0x11
    3d02:	da 88       	ldd	r13, Y+18	; 0x12
    3d04:	63 e1       	ldi	r22, 0x13	; 19
    3d06:	e6 2e       	mov	r14, r22
    3d08:	f1 2c       	mov	r15, r1
    3d0a:	ec 0e       	add	r14, r28
    3d0c:	fd 1e       	adc	r15, r29
    3d0e:	14 c0       	rjmp	.+40     	; 0x3d38 <rprintf1RamRom+0x58>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
    3d10:	88 23       	and	r24, r24
    3d12:	81 f4       	brne	.+32     	; 0x3d34 <rprintf1RamRom+0x54>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
    3d14:	80 e0       	ldi	r24, 0x00	; 0
    3d16:	90 e0       	ldi	r25, 0x00	; 0
    3d18:	cf 91       	pop	r28
    3d1a:	df 91       	pop	r29
    3d1c:	1f 91       	pop	r17
    3d1e:	0f 91       	pop	r16
    3d20:	ff 90       	pop	r15
    3d22:	ef 90       	pop	r14
    3d24:	df 90       	pop	r13
    3d26:	cf 90       	pop	r12
    3d28:	bf 90       	pop	r11
    3d2a:	af 90       	pop	r10
    3d2c:	9f 90       	pop	r9
    3d2e:	8f 90       	pop	r8
    3d30:	7f 90       	pop	r7
    3d32:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
    3d34:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3d38:	96 01       	movw	r18, r12
    3d3a:	2f 5f       	subi	r18, 0xFF	; 255
    3d3c:	3f 4f       	sbci	r19, 0xFF	; 255
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
    3d3e:	77 20       	and	r7, r7
    3d40:	21 f0       	breq	.+8      	; 0x3d4a <rprintf1RamRom+0x6a>
    3d42:	f6 01       	movw	r30, r12
    3d44:	69 01       	movw	r12, r18
    3d46:	84 91       	lpm	r24, Z+
    3d48:	03 c0       	rjmp	.+6      	; 0x3d50 <rprintf1RamRom+0x70>
    3d4a:	f6 01       	movw	r30, r12
    3d4c:	80 81       	ld	r24, Z
    3d4e:	69 01       	movw	r12, r18
    3d50:	85 32       	cpi	r24, 0x25	; 37
    3d52:	f1 f6       	brne	.-68     	; 0x3d10 <rprintf1RamRom+0x30>
    3d54:	2f 5f       	subi	r18, 0xFF	; 255
    3d56:	3f 4f       	sbci	r19, 0xFF	; 255
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
    3d58:	77 20       	and	r7, r7
    3d5a:	21 f0       	breq	.+8      	; 0x3d64 <rprintf1RamRom+0x84>
    3d5c:	f6 01       	movw	r30, r12
    3d5e:	69 01       	movw	r12, r18
    3d60:	84 91       	lpm	r24, Z+
    3d62:	03 c0       	rjmp	.+6      	; 0x3d6a <rprintf1RamRom+0x8a>
    3d64:	f6 01       	movw	r30, r12
    3d66:	80 81       	ld	r24, Z
    3d68:	69 01       	movw	r12, r18
    3d6a:	84 36       	cpi	r24, 0x64	; 100
    3d6c:	29 f0       	breq	.+10     	; 0x3d78 <rprintf1RamRom+0x98>
    3d6e:	88 37       	cpi	r24, 0x78	; 120
    3d70:	81 f0       	breq	.+32     	; 0x3d92 <rprintf1RamRom+0xb2>
    3d72:	83 36       	cpi	r24, 0x63	; 99
    3d74:	f9 f6       	brne	.-66     	; 0x3d34 <rprintf1RamRom+0x54>
    3d76:	06 c0       	rjmp	.+12     	; 0x3d84 <rprintf1RamRom+0xa4>
    3d78:	00 e1       	ldi	r16, 0x10	; 16
    3d7a:	17 e2       	ldi	r17, 0x27	; 39
    3d7c:	5a e0       	ldi	r21, 0x0A	; 10
    3d7e:	a5 2e       	mov	r10, r21
    3d80:	b1 2c       	mov	r11, r1
    3d82:	0c c0       	rjmp	.+24     	; 0x3d9c <rprintf1RamRom+0xbc>
		{
			case 'c': format_flag = va_arg(ap,int);
    3d84:	f7 01       	movw	r30, r14
    3d86:	80 81       	ld	r24, Z
    3d88:	22 e0       	ldi	r18, 0x02	; 2
    3d8a:	30 e0       	ldi	r19, 0x00	; 0
    3d8c:	e2 0e       	add	r14, r18
    3d8e:	f3 1e       	adc	r15, r19
    3d90:	d1 cf       	rjmp	.-94     	; 0x3d34 <rprintf1RamRom+0x54>
			default:  rprintfChar(format_flag); continue;
    3d92:	00 e0       	ldi	r16, 0x00	; 0
    3d94:	10 e1       	ldi	r17, 0x10	; 16
    3d96:	40 e1       	ldi	r20, 0x10	; 16
    3d98:	a4 2e       	mov	r10, r20
    3d9a:	b1 2c       	mov	r11, r1
			case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
//			case 'x': base = 16; div_val = 0x10;
			case 'x': base = 16; div_val = 0x1000;

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
    3d9c:	32 e0       	ldi	r19, 0x02	; 2
    3d9e:	83 2e       	mov	r8, r19
    3da0:	91 2c       	mov	r9, r1
    3da2:	8e 0c       	add	r8, r14
    3da4:	9f 1c       	adc	r9, r15
    3da6:	f7 01       	movw	r30, r14
    3da8:	e0 80       	ld	r14, Z
    3daa:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
    3dac:	84 36       	cpi	r24, 0x64	; 100
    3dae:	b1 f4       	brne	.+44     	; 0x3ddc <rprintf1RamRom+0xfc>
			{
				if (((int)u_val) < 0)
    3db0:	f7 fe       	sbrs	r15, 7
    3db2:	11 c0       	rjmp	.+34     	; 0x3dd6 <rprintf1RamRom+0xf6>
				{
					u_val = - u_val;
    3db4:	f0 94       	com	r15
    3db6:	e1 94       	neg	r14
    3db8:	f1 08       	sbc	r15, r1
    3dba:	f3 94       	inc	r15
					rprintfChar('-');
    3dbc:	8d e2       	ldi	r24, 0x2D	; 45
    3dbe:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <rprintfChar>
    3dc2:	09 c0       	rjmp	.+18     	; 0x3dd6 <rprintf1RamRom+0xf6>
				}
				while (div_val > 1 && div_val > u_val) div_val /= 10;
    3dc4:	c8 01       	movw	r24, r16
    3dc6:	6a e0       	ldi	r22, 0x0A	; 10
    3dc8:	70 e0       	ldi	r23, 0x00	; 0
    3dca:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3dce:	8b 01       	movw	r16, r22
    3dd0:	62 30       	cpi	r22, 0x02	; 2
    3dd2:	71 05       	cpc	r23, r1
    3dd4:	18 f0       	brcs	.+6      	; 0x3ddc <rprintf1RamRom+0xfc>
    3dd6:	e0 16       	cp	r14, r16
    3dd8:	f1 06       	cpc	r15, r17
    3dda:	a0 f3       	brcs	.-24     	; 0x3dc4 <rprintf1RamRom+0xe4>
			}
			do
			{
				//rprintfChar(pgm_read_byte(HexChars+(u_val/div_val)));
				rprintfu04(u_val/div_val);
    3ddc:	c7 01       	movw	r24, r14
    3dde:	b8 01       	movw	r22, r16
    3de0:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3de4:	86 2f       	mov	r24, r22
    3de6:	0e 94 b4 1c 	call	0x3968	; 0x3968 <rprintfu04>
				u_val %= div_val;
    3dea:	c7 01       	movw	r24, r14
    3dec:	b8 01       	movw	r22, r16
    3dee:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3df2:	7c 01       	movw	r14, r24
				div_val /= base;
    3df4:	c8 01       	movw	r24, r16
    3df6:	b5 01       	movw	r22, r10
    3df8:	0e 94 7f 26 	call	0x4cfe	; 0x4cfe <__udivmodhi4>
    3dfc:	8b 01       	movw	r16, r22
			} while (div_val);
    3dfe:	61 15       	cp	r22, r1
    3e00:	71 05       	cpc	r23, r1
    3e02:	61 f7       	brne	.-40     	; 0x3ddc <rprintf1RamRom+0xfc>
    3e04:	74 01       	movw	r14, r8
    3e06:	98 cf       	rjmp	.-208    	; 0x3d38 <rprintf1RamRom+0x58>

00003e08 <__fixunssfsi>:
    3e08:	ef 92       	push	r14
    3e0a:	ff 92       	push	r15
    3e0c:	0f 93       	push	r16
    3e0e:	1f 93       	push	r17
    3e10:	7b 01       	movw	r14, r22
    3e12:	8c 01       	movw	r16, r24
    3e14:	20 e0       	ldi	r18, 0x00	; 0
    3e16:	30 e0       	ldi	r19, 0x00	; 0
    3e18:	40 e0       	ldi	r20, 0x00	; 0
    3e1a:	5f e4       	ldi	r21, 0x4F	; 79
    3e1c:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <__gesf2>
    3e20:	88 23       	and	r24, r24
    3e22:	8c f0       	brlt	.+34     	; 0x3e46 <__fixunssfsi+0x3e>
    3e24:	c8 01       	movw	r24, r16
    3e26:	b7 01       	movw	r22, r14
    3e28:	20 e0       	ldi	r18, 0x00	; 0
    3e2a:	30 e0       	ldi	r19, 0x00	; 0
    3e2c:	40 e0       	ldi	r20, 0x00	; 0
    3e2e:	5f e4       	ldi	r21, 0x4F	; 79
    3e30:	0e 94 7c 20 	call	0x40f8	; 0x40f8 <__subsf3>
    3e34:	0e 94 9e 23 	call	0x473c	; 0x473c <__fixsfsi>
    3e38:	9b 01       	movw	r18, r22
    3e3a:	ac 01       	movw	r20, r24
    3e3c:	20 50       	subi	r18, 0x00	; 0
    3e3e:	30 40       	sbci	r19, 0x00	; 0
    3e40:	40 40       	sbci	r20, 0x00	; 0
    3e42:	50 48       	sbci	r21, 0x80	; 128
    3e44:	06 c0       	rjmp	.+12     	; 0x3e52 <__fixunssfsi+0x4a>
    3e46:	c8 01       	movw	r24, r16
    3e48:	b7 01       	movw	r22, r14
    3e4a:	0e 94 9e 23 	call	0x473c	; 0x473c <__fixsfsi>
    3e4e:	9b 01       	movw	r18, r22
    3e50:	ac 01       	movw	r20, r24
    3e52:	b9 01       	movw	r22, r18
    3e54:	ca 01       	movw	r24, r20
    3e56:	1f 91       	pop	r17
    3e58:	0f 91       	pop	r16
    3e5a:	ff 90       	pop	r15
    3e5c:	ef 90       	pop	r14
    3e5e:	08 95       	ret

00003e60 <_fpadd_parts>:
    3e60:	a0 e0       	ldi	r26, 0x00	; 0
    3e62:	b0 e0       	ldi	r27, 0x00	; 0
    3e64:	e6 e3       	ldi	r30, 0x36	; 54
    3e66:	ff e1       	ldi	r31, 0x1F	; 31
    3e68:	0c 94 e3 26 	jmp	0x4dc6	; 0x4dc6 <__prologue_saves__>
    3e6c:	dc 01       	movw	r26, r24
    3e6e:	2b 01       	movw	r4, r22
    3e70:	fa 01       	movw	r30, r20
    3e72:	9c 91       	ld	r25, X
    3e74:	92 30       	cpi	r25, 0x02	; 2
    3e76:	08 f4       	brcc	.+2      	; 0x3e7a <_fpadd_parts+0x1a>
    3e78:	39 c1       	rjmp	.+626    	; 0x40ec <_fpadd_parts+0x28c>
    3e7a:	eb 01       	movw	r28, r22
    3e7c:	88 81       	ld	r24, Y
    3e7e:	82 30       	cpi	r24, 0x02	; 2
    3e80:	08 f4       	brcc	.+2      	; 0x3e84 <_fpadd_parts+0x24>
    3e82:	33 c1       	rjmp	.+614    	; 0x40ea <_fpadd_parts+0x28a>
    3e84:	94 30       	cpi	r25, 0x04	; 4
    3e86:	69 f4       	brne	.+26     	; 0x3ea2 <_fpadd_parts+0x42>
    3e88:	84 30       	cpi	r24, 0x04	; 4
    3e8a:	09 f0       	breq	.+2      	; 0x3e8e <_fpadd_parts+0x2e>
    3e8c:	2f c1       	rjmp	.+606    	; 0x40ec <_fpadd_parts+0x28c>
    3e8e:	11 96       	adiw	r26, 0x01	; 1
    3e90:	9c 91       	ld	r25, X
    3e92:	11 97       	sbiw	r26, 0x01	; 1
    3e94:	89 81       	ldd	r24, Y+1	; 0x01
    3e96:	98 17       	cp	r25, r24
    3e98:	09 f4       	brne	.+2      	; 0x3e9c <_fpadd_parts+0x3c>
    3e9a:	28 c1       	rjmp	.+592    	; 0x40ec <_fpadd_parts+0x28c>
    3e9c:	a7 e9       	ldi	r26, 0x97	; 151
    3e9e:	b2 e0       	ldi	r27, 0x02	; 2
    3ea0:	25 c1       	rjmp	.+586    	; 0x40ec <_fpadd_parts+0x28c>
    3ea2:	84 30       	cpi	r24, 0x04	; 4
    3ea4:	09 f4       	brne	.+2      	; 0x3ea8 <_fpadd_parts+0x48>
    3ea6:	21 c1       	rjmp	.+578    	; 0x40ea <_fpadd_parts+0x28a>
    3ea8:	82 30       	cpi	r24, 0x02	; 2
    3eaa:	a9 f4       	brne	.+42     	; 0x3ed6 <_fpadd_parts+0x76>
    3eac:	92 30       	cpi	r25, 0x02	; 2
    3eae:	09 f0       	breq	.+2      	; 0x3eb2 <_fpadd_parts+0x52>
    3eb0:	1d c1       	rjmp	.+570    	; 0x40ec <_fpadd_parts+0x28c>
    3eb2:	9a 01       	movw	r18, r20
    3eb4:	ad 01       	movw	r20, r26
    3eb6:	88 e0       	ldi	r24, 0x08	; 8
    3eb8:	ea 01       	movw	r28, r20
    3eba:	09 90       	ld	r0, Y+
    3ebc:	ae 01       	movw	r20, r28
    3ebe:	e9 01       	movw	r28, r18
    3ec0:	09 92       	st	Y+, r0
    3ec2:	9e 01       	movw	r18, r28
    3ec4:	81 50       	subi	r24, 0x01	; 1
    3ec6:	c1 f7       	brne	.-16     	; 0x3eb8 <_fpadd_parts+0x58>
    3ec8:	e2 01       	movw	r28, r4
    3eca:	89 81       	ldd	r24, Y+1	; 0x01
    3ecc:	11 96       	adiw	r26, 0x01	; 1
    3ece:	9c 91       	ld	r25, X
    3ed0:	89 23       	and	r24, r25
    3ed2:	81 83       	std	Z+1, r24	; 0x01
    3ed4:	08 c1       	rjmp	.+528    	; 0x40e6 <_fpadd_parts+0x286>
    3ed6:	92 30       	cpi	r25, 0x02	; 2
    3ed8:	09 f4       	brne	.+2      	; 0x3edc <_fpadd_parts+0x7c>
    3eda:	07 c1       	rjmp	.+526    	; 0x40ea <_fpadd_parts+0x28a>
    3edc:	12 96       	adiw	r26, 0x02	; 2
    3ede:	2d 90       	ld	r2, X+
    3ee0:	3c 90       	ld	r3, X
    3ee2:	13 97       	sbiw	r26, 0x03	; 3
    3ee4:	eb 01       	movw	r28, r22
    3ee6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ee8:	9b 81       	ldd	r25, Y+3	; 0x03
    3eea:	14 96       	adiw	r26, 0x04	; 4
    3eec:	ad 90       	ld	r10, X+
    3eee:	bd 90       	ld	r11, X+
    3ef0:	cd 90       	ld	r12, X+
    3ef2:	dc 90       	ld	r13, X
    3ef4:	17 97       	sbiw	r26, 0x07	; 7
    3ef6:	ec 80       	ldd	r14, Y+4	; 0x04
    3ef8:	fd 80       	ldd	r15, Y+5	; 0x05
    3efa:	0e 81       	ldd	r16, Y+6	; 0x06
    3efc:	1f 81       	ldd	r17, Y+7	; 0x07
    3efe:	91 01       	movw	r18, r2
    3f00:	28 1b       	sub	r18, r24
    3f02:	39 0b       	sbc	r19, r25
    3f04:	b9 01       	movw	r22, r18
    3f06:	37 ff       	sbrs	r19, 7
    3f08:	04 c0       	rjmp	.+8      	; 0x3f12 <_fpadd_parts+0xb2>
    3f0a:	66 27       	eor	r22, r22
    3f0c:	77 27       	eor	r23, r23
    3f0e:	62 1b       	sub	r22, r18
    3f10:	73 0b       	sbc	r23, r19
    3f12:	60 32       	cpi	r22, 0x20	; 32
    3f14:	71 05       	cpc	r23, r1
    3f16:	0c f0       	brlt	.+2      	; 0x3f1a <_fpadd_parts+0xba>
    3f18:	61 c0       	rjmp	.+194    	; 0x3fdc <_fpadd_parts+0x17c>
    3f1a:	12 16       	cp	r1, r18
    3f1c:	13 06       	cpc	r1, r19
    3f1e:	6c f5       	brge	.+90     	; 0x3f7a <_fpadd_parts+0x11a>
    3f20:	37 01       	movw	r6, r14
    3f22:	48 01       	movw	r8, r16
    3f24:	06 2e       	mov	r0, r22
    3f26:	04 c0       	rjmp	.+8      	; 0x3f30 <_fpadd_parts+0xd0>
    3f28:	96 94       	lsr	r9
    3f2a:	87 94       	ror	r8
    3f2c:	77 94       	ror	r7
    3f2e:	67 94       	ror	r6
    3f30:	0a 94       	dec	r0
    3f32:	d2 f7       	brpl	.-12     	; 0x3f28 <_fpadd_parts+0xc8>
    3f34:	21 e0       	ldi	r18, 0x01	; 1
    3f36:	30 e0       	ldi	r19, 0x00	; 0
    3f38:	40 e0       	ldi	r20, 0x00	; 0
    3f3a:	50 e0       	ldi	r21, 0x00	; 0
    3f3c:	04 c0       	rjmp	.+8      	; 0x3f46 <_fpadd_parts+0xe6>
    3f3e:	22 0f       	add	r18, r18
    3f40:	33 1f       	adc	r19, r19
    3f42:	44 1f       	adc	r20, r20
    3f44:	55 1f       	adc	r21, r21
    3f46:	6a 95       	dec	r22
    3f48:	d2 f7       	brpl	.-12     	; 0x3f3e <_fpadd_parts+0xde>
    3f4a:	21 50       	subi	r18, 0x01	; 1
    3f4c:	30 40       	sbci	r19, 0x00	; 0
    3f4e:	40 40       	sbci	r20, 0x00	; 0
    3f50:	50 40       	sbci	r21, 0x00	; 0
    3f52:	2e 21       	and	r18, r14
    3f54:	3f 21       	and	r19, r15
    3f56:	40 23       	and	r20, r16
    3f58:	51 23       	and	r21, r17
    3f5a:	21 15       	cp	r18, r1
    3f5c:	31 05       	cpc	r19, r1
    3f5e:	41 05       	cpc	r20, r1
    3f60:	51 05       	cpc	r21, r1
    3f62:	21 f0       	breq	.+8      	; 0x3f6c <_fpadd_parts+0x10c>
    3f64:	21 e0       	ldi	r18, 0x01	; 1
    3f66:	30 e0       	ldi	r19, 0x00	; 0
    3f68:	40 e0       	ldi	r20, 0x00	; 0
    3f6a:	50 e0       	ldi	r21, 0x00	; 0
    3f6c:	79 01       	movw	r14, r18
    3f6e:	8a 01       	movw	r16, r20
    3f70:	e6 28       	or	r14, r6
    3f72:	f7 28       	or	r15, r7
    3f74:	08 29       	or	r16, r8
    3f76:	19 29       	or	r17, r9
    3f78:	3c c0       	rjmp	.+120    	; 0x3ff2 <_fpadd_parts+0x192>
    3f7a:	23 2b       	or	r18, r19
    3f7c:	d1 f1       	breq	.+116    	; 0x3ff2 <_fpadd_parts+0x192>
    3f7e:	26 0e       	add	r2, r22
    3f80:	37 1e       	adc	r3, r23
    3f82:	35 01       	movw	r6, r10
    3f84:	46 01       	movw	r8, r12
    3f86:	06 2e       	mov	r0, r22
    3f88:	04 c0       	rjmp	.+8      	; 0x3f92 <_fpadd_parts+0x132>
    3f8a:	96 94       	lsr	r9
    3f8c:	87 94       	ror	r8
    3f8e:	77 94       	ror	r7
    3f90:	67 94       	ror	r6
    3f92:	0a 94       	dec	r0
    3f94:	d2 f7       	brpl	.-12     	; 0x3f8a <_fpadd_parts+0x12a>
    3f96:	21 e0       	ldi	r18, 0x01	; 1
    3f98:	30 e0       	ldi	r19, 0x00	; 0
    3f9a:	40 e0       	ldi	r20, 0x00	; 0
    3f9c:	50 e0       	ldi	r21, 0x00	; 0
    3f9e:	04 c0       	rjmp	.+8      	; 0x3fa8 <_fpadd_parts+0x148>
    3fa0:	22 0f       	add	r18, r18
    3fa2:	33 1f       	adc	r19, r19
    3fa4:	44 1f       	adc	r20, r20
    3fa6:	55 1f       	adc	r21, r21
    3fa8:	6a 95       	dec	r22
    3faa:	d2 f7       	brpl	.-12     	; 0x3fa0 <_fpadd_parts+0x140>
    3fac:	21 50       	subi	r18, 0x01	; 1
    3fae:	30 40       	sbci	r19, 0x00	; 0
    3fb0:	40 40       	sbci	r20, 0x00	; 0
    3fb2:	50 40       	sbci	r21, 0x00	; 0
    3fb4:	2a 21       	and	r18, r10
    3fb6:	3b 21       	and	r19, r11
    3fb8:	4c 21       	and	r20, r12
    3fba:	5d 21       	and	r21, r13
    3fbc:	21 15       	cp	r18, r1
    3fbe:	31 05       	cpc	r19, r1
    3fc0:	41 05       	cpc	r20, r1
    3fc2:	51 05       	cpc	r21, r1
    3fc4:	21 f0       	breq	.+8      	; 0x3fce <_fpadd_parts+0x16e>
    3fc6:	21 e0       	ldi	r18, 0x01	; 1
    3fc8:	30 e0       	ldi	r19, 0x00	; 0
    3fca:	40 e0       	ldi	r20, 0x00	; 0
    3fcc:	50 e0       	ldi	r21, 0x00	; 0
    3fce:	59 01       	movw	r10, r18
    3fd0:	6a 01       	movw	r12, r20
    3fd2:	a6 28       	or	r10, r6
    3fd4:	b7 28       	or	r11, r7
    3fd6:	c8 28       	or	r12, r8
    3fd8:	d9 28       	or	r13, r9
    3fda:	0b c0       	rjmp	.+22     	; 0x3ff2 <_fpadd_parts+0x192>
    3fdc:	82 15       	cp	r24, r2
    3fde:	93 05       	cpc	r25, r3
    3fe0:	2c f0       	brlt	.+10     	; 0x3fec <_fpadd_parts+0x18c>
    3fe2:	1c 01       	movw	r2, r24
    3fe4:	aa 24       	eor	r10, r10
    3fe6:	bb 24       	eor	r11, r11
    3fe8:	65 01       	movw	r12, r10
    3fea:	03 c0       	rjmp	.+6      	; 0x3ff2 <_fpadd_parts+0x192>
    3fec:	ee 24       	eor	r14, r14
    3fee:	ff 24       	eor	r15, r15
    3ff0:	87 01       	movw	r16, r14
    3ff2:	11 96       	adiw	r26, 0x01	; 1
    3ff4:	9c 91       	ld	r25, X
    3ff6:	d2 01       	movw	r26, r4
    3ff8:	11 96       	adiw	r26, 0x01	; 1
    3ffa:	8c 91       	ld	r24, X
    3ffc:	98 17       	cp	r25, r24
    3ffe:	09 f4       	brne	.+2      	; 0x4002 <_fpadd_parts+0x1a2>
    4000:	45 c0       	rjmp	.+138    	; 0x408c <_fpadd_parts+0x22c>
    4002:	99 23       	and	r25, r25
    4004:	39 f0       	breq	.+14     	; 0x4014 <_fpadd_parts+0x1b4>
    4006:	a8 01       	movw	r20, r16
    4008:	97 01       	movw	r18, r14
    400a:	2a 19       	sub	r18, r10
    400c:	3b 09       	sbc	r19, r11
    400e:	4c 09       	sbc	r20, r12
    4010:	5d 09       	sbc	r21, r13
    4012:	06 c0       	rjmp	.+12     	; 0x4020 <_fpadd_parts+0x1c0>
    4014:	a6 01       	movw	r20, r12
    4016:	95 01       	movw	r18, r10
    4018:	2e 19       	sub	r18, r14
    401a:	3f 09       	sbc	r19, r15
    401c:	40 0b       	sbc	r20, r16
    401e:	51 0b       	sbc	r21, r17
    4020:	57 fd       	sbrc	r21, 7
    4022:	08 c0       	rjmp	.+16     	; 0x4034 <_fpadd_parts+0x1d4>
    4024:	11 82       	std	Z+1, r1	; 0x01
    4026:	33 82       	std	Z+3, r3	; 0x03
    4028:	22 82       	std	Z+2, r2	; 0x02
    402a:	24 83       	std	Z+4, r18	; 0x04
    402c:	35 83       	std	Z+5, r19	; 0x05
    402e:	46 83       	std	Z+6, r20	; 0x06
    4030:	57 83       	std	Z+7, r21	; 0x07
    4032:	1d c0       	rjmp	.+58     	; 0x406e <_fpadd_parts+0x20e>
    4034:	81 e0       	ldi	r24, 0x01	; 1
    4036:	81 83       	std	Z+1, r24	; 0x01
    4038:	33 82       	std	Z+3, r3	; 0x03
    403a:	22 82       	std	Z+2, r2	; 0x02
    403c:	88 27       	eor	r24, r24
    403e:	99 27       	eor	r25, r25
    4040:	dc 01       	movw	r26, r24
    4042:	82 1b       	sub	r24, r18
    4044:	93 0b       	sbc	r25, r19
    4046:	a4 0b       	sbc	r26, r20
    4048:	b5 0b       	sbc	r27, r21
    404a:	84 83       	std	Z+4, r24	; 0x04
    404c:	95 83       	std	Z+5, r25	; 0x05
    404e:	a6 83       	std	Z+6, r26	; 0x06
    4050:	b7 83       	std	Z+7, r27	; 0x07
    4052:	0d c0       	rjmp	.+26     	; 0x406e <_fpadd_parts+0x20e>
    4054:	22 0f       	add	r18, r18
    4056:	33 1f       	adc	r19, r19
    4058:	44 1f       	adc	r20, r20
    405a:	55 1f       	adc	r21, r21
    405c:	24 83       	std	Z+4, r18	; 0x04
    405e:	35 83       	std	Z+5, r19	; 0x05
    4060:	46 83       	std	Z+6, r20	; 0x06
    4062:	57 83       	std	Z+7, r21	; 0x07
    4064:	82 81       	ldd	r24, Z+2	; 0x02
    4066:	93 81       	ldd	r25, Z+3	; 0x03
    4068:	01 97       	sbiw	r24, 0x01	; 1
    406a:	93 83       	std	Z+3, r25	; 0x03
    406c:	82 83       	std	Z+2, r24	; 0x02
    406e:	24 81       	ldd	r18, Z+4	; 0x04
    4070:	35 81       	ldd	r19, Z+5	; 0x05
    4072:	46 81       	ldd	r20, Z+6	; 0x06
    4074:	57 81       	ldd	r21, Z+7	; 0x07
    4076:	da 01       	movw	r26, r20
    4078:	c9 01       	movw	r24, r18
    407a:	01 97       	sbiw	r24, 0x01	; 1
    407c:	a1 09       	sbc	r26, r1
    407e:	b1 09       	sbc	r27, r1
    4080:	8f 5f       	subi	r24, 0xFF	; 255
    4082:	9f 4f       	sbci	r25, 0xFF	; 255
    4084:	af 4f       	sbci	r26, 0xFF	; 255
    4086:	bf 43       	sbci	r27, 0x3F	; 63
    4088:	28 f3       	brcs	.-54     	; 0x4054 <_fpadd_parts+0x1f4>
    408a:	0b c0       	rjmp	.+22     	; 0x40a2 <_fpadd_parts+0x242>
    408c:	91 83       	std	Z+1, r25	; 0x01
    408e:	33 82       	std	Z+3, r3	; 0x03
    4090:	22 82       	std	Z+2, r2	; 0x02
    4092:	ea 0c       	add	r14, r10
    4094:	fb 1c       	adc	r15, r11
    4096:	0c 1d       	adc	r16, r12
    4098:	1d 1d       	adc	r17, r13
    409a:	e4 82       	std	Z+4, r14	; 0x04
    409c:	f5 82       	std	Z+5, r15	; 0x05
    409e:	06 83       	std	Z+6, r16	; 0x06
    40a0:	17 83       	std	Z+7, r17	; 0x07
    40a2:	83 e0       	ldi	r24, 0x03	; 3
    40a4:	80 83       	st	Z, r24
    40a6:	24 81       	ldd	r18, Z+4	; 0x04
    40a8:	35 81       	ldd	r19, Z+5	; 0x05
    40aa:	46 81       	ldd	r20, Z+6	; 0x06
    40ac:	57 81       	ldd	r21, Z+7	; 0x07
    40ae:	57 ff       	sbrs	r21, 7
    40b0:	1a c0       	rjmp	.+52     	; 0x40e6 <_fpadd_parts+0x286>
    40b2:	c9 01       	movw	r24, r18
    40b4:	aa 27       	eor	r26, r26
    40b6:	97 fd       	sbrc	r25, 7
    40b8:	a0 95       	com	r26
    40ba:	ba 2f       	mov	r27, r26
    40bc:	81 70       	andi	r24, 0x01	; 1
    40be:	90 70       	andi	r25, 0x00	; 0
    40c0:	a0 70       	andi	r26, 0x00	; 0
    40c2:	b0 70       	andi	r27, 0x00	; 0
    40c4:	56 95       	lsr	r21
    40c6:	47 95       	ror	r20
    40c8:	37 95       	ror	r19
    40ca:	27 95       	ror	r18
    40cc:	82 2b       	or	r24, r18
    40ce:	93 2b       	or	r25, r19
    40d0:	a4 2b       	or	r26, r20
    40d2:	b5 2b       	or	r27, r21
    40d4:	84 83       	std	Z+4, r24	; 0x04
    40d6:	95 83       	std	Z+5, r25	; 0x05
    40d8:	a6 83       	std	Z+6, r26	; 0x06
    40da:	b7 83       	std	Z+7, r27	; 0x07
    40dc:	82 81       	ldd	r24, Z+2	; 0x02
    40de:	93 81       	ldd	r25, Z+3	; 0x03
    40e0:	01 96       	adiw	r24, 0x01	; 1
    40e2:	93 83       	std	Z+3, r25	; 0x03
    40e4:	82 83       	std	Z+2, r24	; 0x02
    40e6:	df 01       	movw	r26, r30
    40e8:	01 c0       	rjmp	.+2      	; 0x40ec <_fpadd_parts+0x28c>
    40ea:	d2 01       	movw	r26, r4
    40ec:	cd 01       	movw	r24, r26
    40ee:	cd b7       	in	r28, 0x3d	; 61
    40f0:	de b7       	in	r29, 0x3e	; 62
    40f2:	e2 e1       	ldi	r30, 0x12	; 18
    40f4:	0c 94 ff 26 	jmp	0x4dfe	; 0x4dfe <__epilogue_restores__>

000040f8 <__subsf3>:
    40f8:	a0 e2       	ldi	r26, 0x20	; 32
    40fa:	b0 e0       	ldi	r27, 0x00	; 0
    40fc:	e2 e8       	ldi	r30, 0x82	; 130
    40fe:	f0 e2       	ldi	r31, 0x20	; 32
    4100:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    4104:	69 83       	std	Y+1, r22	; 0x01
    4106:	7a 83       	std	Y+2, r23	; 0x02
    4108:	8b 83       	std	Y+3, r24	; 0x03
    410a:	9c 83       	std	Y+4, r25	; 0x04
    410c:	2d 83       	std	Y+5, r18	; 0x05
    410e:	3e 83       	std	Y+6, r19	; 0x06
    4110:	4f 83       	std	Y+7, r20	; 0x07
    4112:	58 87       	std	Y+8, r21	; 0x08
    4114:	e9 e0       	ldi	r30, 0x09	; 9
    4116:	ee 2e       	mov	r14, r30
    4118:	f1 2c       	mov	r15, r1
    411a:	ec 0e       	add	r14, r28
    411c:	fd 1e       	adc	r15, r29
    411e:	ce 01       	movw	r24, r28
    4120:	01 96       	adiw	r24, 0x01	; 1
    4122:	b7 01       	movw	r22, r14
    4124:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4128:	8e 01       	movw	r16, r28
    412a:	0f 5e       	subi	r16, 0xEF	; 239
    412c:	1f 4f       	sbci	r17, 0xFF	; 255
    412e:	ce 01       	movw	r24, r28
    4130:	05 96       	adiw	r24, 0x05	; 5
    4132:	b8 01       	movw	r22, r16
    4134:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4138:	8a 89       	ldd	r24, Y+18	; 0x12
    413a:	91 e0       	ldi	r25, 0x01	; 1
    413c:	89 27       	eor	r24, r25
    413e:	8a 8b       	std	Y+18, r24	; 0x12
    4140:	c7 01       	movw	r24, r14
    4142:	b8 01       	movw	r22, r16
    4144:	ae 01       	movw	r20, r28
    4146:	47 5e       	subi	r20, 0xE7	; 231
    4148:	5f 4f       	sbci	r21, 0xFF	; 255
    414a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_fpadd_parts>
    414e:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    4152:	a0 96       	adiw	r28, 0x20	; 32
    4154:	e6 e0       	ldi	r30, 0x06	; 6
    4156:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

0000415a <__addsf3>:
    415a:	a0 e2       	ldi	r26, 0x20	; 32
    415c:	b0 e0       	ldi	r27, 0x00	; 0
    415e:	e3 eb       	ldi	r30, 0xB3	; 179
    4160:	f0 e2       	ldi	r31, 0x20	; 32
    4162:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    4166:	69 83       	std	Y+1, r22	; 0x01
    4168:	7a 83       	std	Y+2, r23	; 0x02
    416a:	8b 83       	std	Y+3, r24	; 0x03
    416c:	9c 83       	std	Y+4, r25	; 0x04
    416e:	2d 83       	std	Y+5, r18	; 0x05
    4170:	3e 83       	std	Y+6, r19	; 0x06
    4172:	4f 83       	std	Y+7, r20	; 0x07
    4174:	58 87       	std	Y+8, r21	; 0x08
    4176:	f9 e0       	ldi	r31, 0x09	; 9
    4178:	ef 2e       	mov	r14, r31
    417a:	f1 2c       	mov	r15, r1
    417c:	ec 0e       	add	r14, r28
    417e:	fd 1e       	adc	r15, r29
    4180:	ce 01       	movw	r24, r28
    4182:	01 96       	adiw	r24, 0x01	; 1
    4184:	b7 01       	movw	r22, r14
    4186:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    418a:	8e 01       	movw	r16, r28
    418c:	0f 5e       	subi	r16, 0xEF	; 239
    418e:	1f 4f       	sbci	r17, 0xFF	; 255
    4190:	ce 01       	movw	r24, r28
    4192:	05 96       	adiw	r24, 0x05	; 5
    4194:	b8 01       	movw	r22, r16
    4196:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    419a:	c7 01       	movw	r24, r14
    419c:	b8 01       	movw	r22, r16
    419e:	ae 01       	movw	r20, r28
    41a0:	47 5e       	subi	r20, 0xE7	; 231
    41a2:	5f 4f       	sbci	r21, 0xFF	; 255
    41a4:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_fpadd_parts>
    41a8:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    41ac:	a0 96       	adiw	r28, 0x20	; 32
    41ae:	e6 e0       	ldi	r30, 0x06	; 6
    41b0:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

000041b4 <__mulsf3>:
    41b4:	a0 e2       	ldi	r26, 0x20	; 32
    41b6:	b0 e0       	ldi	r27, 0x00	; 0
    41b8:	e0 ee       	ldi	r30, 0xE0	; 224
    41ba:	f0 e2       	ldi	r31, 0x20	; 32
    41bc:	0c 94 e3 26 	jmp	0x4dc6	; 0x4dc6 <__prologue_saves__>
    41c0:	69 83       	std	Y+1, r22	; 0x01
    41c2:	7a 83       	std	Y+2, r23	; 0x02
    41c4:	8b 83       	std	Y+3, r24	; 0x03
    41c6:	9c 83       	std	Y+4, r25	; 0x04
    41c8:	2d 83       	std	Y+5, r18	; 0x05
    41ca:	3e 83       	std	Y+6, r19	; 0x06
    41cc:	4f 83       	std	Y+7, r20	; 0x07
    41ce:	58 87       	std	Y+8, r21	; 0x08
    41d0:	ce 01       	movw	r24, r28
    41d2:	01 96       	adiw	r24, 0x01	; 1
    41d4:	be 01       	movw	r22, r28
    41d6:	67 5f       	subi	r22, 0xF7	; 247
    41d8:	7f 4f       	sbci	r23, 0xFF	; 255
    41da:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    41de:	ce 01       	movw	r24, r28
    41e0:	05 96       	adiw	r24, 0x05	; 5
    41e2:	be 01       	movw	r22, r28
    41e4:	6f 5e       	subi	r22, 0xEF	; 239
    41e6:	7f 4f       	sbci	r23, 0xFF	; 255
    41e8:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    41ec:	99 85       	ldd	r25, Y+9	; 0x09
    41ee:	92 30       	cpi	r25, 0x02	; 2
    41f0:	88 f0       	brcs	.+34     	; 0x4214 <__mulsf3+0x60>
    41f2:	89 89       	ldd	r24, Y+17	; 0x11
    41f4:	82 30       	cpi	r24, 0x02	; 2
    41f6:	c8 f0       	brcs	.+50     	; 0x422a <__mulsf3+0x76>
    41f8:	94 30       	cpi	r25, 0x04	; 4
    41fa:	19 f4       	brne	.+6      	; 0x4202 <__mulsf3+0x4e>
    41fc:	82 30       	cpi	r24, 0x02	; 2
    41fe:	51 f4       	brne	.+20     	; 0x4214 <__mulsf3+0x60>
    4200:	04 c0       	rjmp	.+8      	; 0x420a <__mulsf3+0x56>
    4202:	84 30       	cpi	r24, 0x04	; 4
    4204:	29 f4       	brne	.+10     	; 0x4210 <__mulsf3+0x5c>
    4206:	92 30       	cpi	r25, 0x02	; 2
    4208:	81 f4       	brne	.+32     	; 0x422a <__mulsf3+0x76>
    420a:	87 e9       	ldi	r24, 0x97	; 151
    420c:	92 e0       	ldi	r25, 0x02	; 2
    420e:	c6 c0       	rjmp	.+396    	; 0x439c <__mulsf3+0x1e8>
    4210:	92 30       	cpi	r25, 0x02	; 2
    4212:	49 f4       	brne	.+18     	; 0x4226 <__mulsf3+0x72>
    4214:	20 e0       	ldi	r18, 0x00	; 0
    4216:	9a 85       	ldd	r25, Y+10	; 0x0a
    4218:	8a 89       	ldd	r24, Y+18	; 0x12
    421a:	98 13       	cpse	r25, r24
    421c:	21 e0       	ldi	r18, 0x01	; 1
    421e:	2a 87       	std	Y+10, r18	; 0x0a
    4220:	ce 01       	movw	r24, r28
    4222:	09 96       	adiw	r24, 0x09	; 9
    4224:	bb c0       	rjmp	.+374    	; 0x439c <__mulsf3+0x1e8>
    4226:	82 30       	cpi	r24, 0x02	; 2
    4228:	49 f4       	brne	.+18     	; 0x423c <__mulsf3+0x88>
    422a:	20 e0       	ldi	r18, 0x00	; 0
    422c:	9a 85       	ldd	r25, Y+10	; 0x0a
    422e:	8a 89       	ldd	r24, Y+18	; 0x12
    4230:	98 13       	cpse	r25, r24
    4232:	21 e0       	ldi	r18, 0x01	; 1
    4234:	2a 8b       	std	Y+18, r18	; 0x12
    4236:	ce 01       	movw	r24, r28
    4238:	41 96       	adiw	r24, 0x11	; 17
    423a:	b0 c0       	rjmp	.+352    	; 0x439c <__mulsf3+0x1e8>
    423c:	2d 84       	ldd	r2, Y+13	; 0x0d
    423e:	3e 84       	ldd	r3, Y+14	; 0x0e
    4240:	4f 84       	ldd	r4, Y+15	; 0x0f
    4242:	58 88       	ldd	r5, Y+16	; 0x10
    4244:	6d 88       	ldd	r6, Y+21	; 0x15
    4246:	7e 88       	ldd	r7, Y+22	; 0x16
    4248:	8f 88       	ldd	r8, Y+23	; 0x17
    424a:	98 8c       	ldd	r9, Y+24	; 0x18
    424c:	ee 24       	eor	r14, r14
    424e:	ff 24       	eor	r15, r15
    4250:	87 01       	movw	r16, r14
    4252:	aa 24       	eor	r10, r10
    4254:	bb 24       	eor	r11, r11
    4256:	65 01       	movw	r12, r10
    4258:	40 e0       	ldi	r20, 0x00	; 0
    425a:	50 e0       	ldi	r21, 0x00	; 0
    425c:	60 e0       	ldi	r22, 0x00	; 0
    425e:	70 e0       	ldi	r23, 0x00	; 0
    4260:	e0 e0       	ldi	r30, 0x00	; 0
    4262:	f0 e0       	ldi	r31, 0x00	; 0
    4264:	c1 01       	movw	r24, r2
    4266:	81 70       	andi	r24, 0x01	; 1
    4268:	90 70       	andi	r25, 0x00	; 0
    426a:	89 2b       	or	r24, r25
    426c:	e9 f0       	breq	.+58     	; 0x42a8 <__mulsf3+0xf4>
    426e:	e6 0c       	add	r14, r6
    4270:	f7 1c       	adc	r15, r7
    4272:	08 1d       	adc	r16, r8
    4274:	19 1d       	adc	r17, r9
    4276:	9a 01       	movw	r18, r20
    4278:	ab 01       	movw	r20, r22
    427a:	2a 0d       	add	r18, r10
    427c:	3b 1d       	adc	r19, r11
    427e:	4c 1d       	adc	r20, r12
    4280:	5d 1d       	adc	r21, r13
    4282:	80 e0       	ldi	r24, 0x00	; 0
    4284:	90 e0       	ldi	r25, 0x00	; 0
    4286:	a0 e0       	ldi	r26, 0x00	; 0
    4288:	b0 e0       	ldi	r27, 0x00	; 0
    428a:	e6 14       	cp	r14, r6
    428c:	f7 04       	cpc	r15, r7
    428e:	08 05       	cpc	r16, r8
    4290:	19 05       	cpc	r17, r9
    4292:	20 f4       	brcc	.+8      	; 0x429c <__mulsf3+0xe8>
    4294:	81 e0       	ldi	r24, 0x01	; 1
    4296:	90 e0       	ldi	r25, 0x00	; 0
    4298:	a0 e0       	ldi	r26, 0x00	; 0
    429a:	b0 e0       	ldi	r27, 0x00	; 0
    429c:	ba 01       	movw	r22, r20
    429e:	a9 01       	movw	r20, r18
    42a0:	48 0f       	add	r20, r24
    42a2:	59 1f       	adc	r21, r25
    42a4:	6a 1f       	adc	r22, r26
    42a6:	7b 1f       	adc	r23, r27
    42a8:	aa 0c       	add	r10, r10
    42aa:	bb 1c       	adc	r11, r11
    42ac:	cc 1c       	adc	r12, r12
    42ae:	dd 1c       	adc	r13, r13
    42b0:	97 fe       	sbrs	r9, 7
    42b2:	08 c0       	rjmp	.+16     	; 0x42c4 <__mulsf3+0x110>
    42b4:	81 e0       	ldi	r24, 0x01	; 1
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	a0 e0       	ldi	r26, 0x00	; 0
    42ba:	b0 e0       	ldi	r27, 0x00	; 0
    42bc:	a8 2a       	or	r10, r24
    42be:	b9 2a       	or	r11, r25
    42c0:	ca 2a       	or	r12, r26
    42c2:	db 2a       	or	r13, r27
    42c4:	31 96       	adiw	r30, 0x01	; 1
    42c6:	e0 32       	cpi	r30, 0x20	; 32
    42c8:	f1 05       	cpc	r31, r1
    42ca:	49 f0       	breq	.+18     	; 0x42de <__mulsf3+0x12a>
    42cc:	66 0c       	add	r6, r6
    42ce:	77 1c       	adc	r7, r7
    42d0:	88 1c       	adc	r8, r8
    42d2:	99 1c       	adc	r9, r9
    42d4:	56 94       	lsr	r5
    42d6:	47 94       	ror	r4
    42d8:	37 94       	ror	r3
    42da:	27 94       	ror	r2
    42dc:	c3 cf       	rjmp	.-122    	; 0x4264 <__mulsf3+0xb0>
    42de:	fa 85       	ldd	r31, Y+10	; 0x0a
    42e0:	ea 89       	ldd	r30, Y+18	; 0x12
    42e2:	2b 89       	ldd	r18, Y+19	; 0x13
    42e4:	3c 89       	ldd	r19, Y+20	; 0x14
    42e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    42e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    42ea:	28 0f       	add	r18, r24
    42ec:	39 1f       	adc	r19, r25
    42ee:	2e 5f       	subi	r18, 0xFE	; 254
    42f0:	3f 4f       	sbci	r19, 0xFF	; 255
    42f2:	17 c0       	rjmp	.+46     	; 0x4322 <__mulsf3+0x16e>
    42f4:	ca 01       	movw	r24, r20
    42f6:	81 70       	andi	r24, 0x01	; 1
    42f8:	90 70       	andi	r25, 0x00	; 0
    42fa:	89 2b       	or	r24, r25
    42fc:	61 f0       	breq	.+24     	; 0x4316 <__mulsf3+0x162>
    42fe:	16 95       	lsr	r17
    4300:	07 95       	ror	r16
    4302:	f7 94       	ror	r15
    4304:	e7 94       	ror	r14
    4306:	80 e0       	ldi	r24, 0x00	; 0
    4308:	90 e0       	ldi	r25, 0x00	; 0
    430a:	a0 e0       	ldi	r26, 0x00	; 0
    430c:	b0 e8       	ldi	r27, 0x80	; 128
    430e:	e8 2a       	or	r14, r24
    4310:	f9 2a       	or	r15, r25
    4312:	0a 2b       	or	r16, r26
    4314:	1b 2b       	or	r17, r27
    4316:	76 95       	lsr	r23
    4318:	67 95       	ror	r22
    431a:	57 95       	ror	r21
    431c:	47 95       	ror	r20
    431e:	2f 5f       	subi	r18, 0xFF	; 255
    4320:	3f 4f       	sbci	r19, 0xFF	; 255
    4322:	77 fd       	sbrc	r23, 7
    4324:	e7 cf       	rjmp	.-50     	; 0x42f4 <__mulsf3+0x140>
    4326:	0c c0       	rjmp	.+24     	; 0x4340 <__mulsf3+0x18c>
    4328:	44 0f       	add	r20, r20
    432a:	55 1f       	adc	r21, r21
    432c:	66 1f       	adc	r22, r22
    432e:	77 1f       	adc	r23, r23
    4330:	17 fd       	sbrc	r17, 7
    4332:	41 60       	ori	r20, 0x01	; 1
    4334:	ee 0c       	add	r14, r14
    4336:	ff 1c       	adc	r15, r15
    4338:	00 1f       	adc	r16, r16
    433a:	11 1f       	adc	r17, r17
    433c:	21 50       	subi	r18, 0x01	; 1
    433e:	30 40       	sbci	r19, 0x00	; 0
    4340:	40 30       	cpi	r20, 0x00	; 0
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	59 07       	cpc	r21, r25
    4346:	90 e0       	ldi	r25, 0x00	; 0
    4348:	69 07       	cpc	r22, r25
    434a:	90 e4       	ldi	r25, 0x40	; 64
    434c:	79 07       	cpc	r23, r25
    434e:	60 f3       	brcs	.-40     	; 0x4328 <__mulsf3+0x174>
    4350:	2b 8f       	std	Y+27, r18	; 0x1b
    4352:	3c 8f       	std	Y+28, r19	; 0x1c
    4354:	db 01       	movw	r26, r22
    4356:	ca 01       	movw	r24, r20
    4358:	8f 77       	andi	r24, 0x7F	; 127
    435a:	90 70       	andi	r25, 0x00	; 0
    435c:	a0 70       	andi	r26, 0x00	; 0
    435e:	b0 70       	andi	r27, 0x00	; 0
    4360:	80 34       	cpi	r24, 0x40	; 64
    4362:	91 05       	cpc	r25, r1
    4364:	a1 05       	cpc	r26, r1
    4366:	b1 05       	cpc	r27, r1
    4368:	61 f4       	brne	.+24     	; 0x4382 <__mulsf3+0x1ce>
    436a:	47 fd       	sbrc	r20, 7
    436c:	0a c0       	rjmp	.+20     	; 0x4382 <__mulsf3+0x1ce>
    436e:	e1 14       	cp	r14, r1
    4370:	f1 04       	cpc	r15, r1
    4372:	01 05       	cpc	r16, r1
    4374:	11 05       	cpc	r17, r1
    4376:	29 f0       	breq	.+10     	; 0x4382 <__mulsf3+0x1ce>
    4378:	40 5c       	subi	r20, 0xC0	; 192
    437a:	5f 4f       	sbci	r21, 0xFF	; 255
    437c:	6f 4f       	sbci	r22, 0xFF	; 255
    437e:	7f 4f       	sbci	r23, 0xFF	; 255
    4380:	40 78       	andi	r20, 0x80	; 128
    4382:	1a 8e       	std	Y+26, r1	; 0x1a
    4384:	fe 17       	cp	r31, r30
    4386:	11 f0       	breq	.+4      	; 0x438c <__mulsf3+0x1d8>
    4388:	81 e0       	ldi	r24, 0x01	; 1
    438a:	8a 8f       	std	Y+26, r24	; 0x1a
    438c:	4d 8f       	std	Y+29, r20	; 0x1d
    438e:	5e 8f       	std	Y+30, r21	; 0x1e
    4390:	6f 8f       	std	Y+31, r22	; 0x1f
    4392:	78 a3       	std	Y+32, r23	; 0x20
    4394:	83 e0       	ldi	r24, 0x03	; 3
    4396:	89 8f       	std	Y+25, r24	; 0x19
    4398:	ce 01       	movw	r24, r28
    439a:	49 96       	adiw	r24, 0x19	; 25
    439c:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    43a0:	a0 96       	adiw	r28, 0x20	; 32
    43a2:	e2 e1       	ldi	r30, 0x12	; 18
    43a4:	0c 94 ff 26 	jmp	0x4dfe	; 0x4dfe <__epilogue_restores__>

000043a8 <__divsf3>:
    43a8:	a8 e1       	ldi	r26, 0x18	; 24
    43aa:	b0 e0       	ldi	r27, 0x00	; 0
    43ac:	ea ed       	ldi	r30, 0xDA	; 218
    43ae:	f1 e2       	ldi	r31, 0x21	; 33
    43b0:	0c 94 eb 26 	jmp	0x4dd6	; 0x4dd6 <__prologue_saves__+0x10>
    43b4:	69 83       	std	Y+1, r22	; 0x01
    43b6:	7a 83       	std	Y+2, r23	; 0x02
    43b8:	8b 83       	std	Y+3, r24	; 0x03
    43ba:	9c 83       	std	Y+4, r25	; 0x04
    43bc:	2d 83       	std	Y+5, r18	; 0x05
    43be:	3e 83       	std	Y+6, r19	; 0x06
    43c0:	4f 83       	std	Y+7, r20	; 0x07
    43c2:	58 87       	std	Y+8, r21	; 0x08
    43c4:	b9 e0       	ldi	r27, 0x09	; 9
    43c6:	eb 2e       	mov	r14, r27
    43c8:	f1 2c       	mov	r15, r1
    43ca:	ec 0e       	add	r14, r28
    43cc:	fd 1e       	adc	r15, r29
    43ce:	ce 01       	movw	r24, r28
    43d0:	01 96       	adiw	r24, 0x01	; 1
    43d2:	b7 01       	movw	r22, r14
    43d4:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    43d8:	8e 01       	movw	r16, r28
    43da:	0f 5e       	subi	r16, 0xEF	; 239
    43dc:	1f 4f       	sbci	r17, 0xFF	; 255
    43de:	ce 01       	movw	r24, r28
    43e0:	05 96       	adiw	r24, 0x05	; 5
    43e2:	b8 01       	movw	r22, r16
    43e4:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    43e8:	29 85       	ldd	r18, Y+9	; 0x09
    43ea:	22 30       	cpi	r18, 0x02	; 2
    43ec:	08 f4       	brcc	.+2      	; 0x43f0 <__divsf3+0x48>
    43ee:	7e c0       	rjmp	.+252    	; 0x44ec <__divsf3+0x144>
    43f0:	39 89       	ldd	r19, Y+17	; 0x11
    43f2:	32 30       	cpi	r19, 0x02	; 2
    43f4:	10 f4       	brcc	.+4      	; 0x43fa <__divsf3+0x52>
    43f6:	b8 01       	movw	r22, r16
    43f8:	7c c0       	rjmp	.+248    	; 0x44f2 <__divsf3+0x14a>
    43fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    43fc:	9a 89       	ldd	r25, Y+18	; 0x12
    43fe:	89 27       	eor	r24, r25
    4400:	8a 87       	std	Y+10, r24	; 0x0a
    4402:	24 30       	cpi	r18, 0x04	; 4
    4404:	11 f0       	breq	.+4      	; 0x440a <__divsf3+0x62>
    4406:	22 30       	cpi	r18, 0x02	; 2
    4408:	31 f4       	brne	.+12     	; 0x4416 <__divsf3+0x6e>
    440a:	23 17       	cp	r18, r19
    440c:	09 f0       	breq	.+2      	; 0x4410 <__divsf3+0x68>
    440e:	6e c0       	rjmp	.+220    	; 0x44ec <__divsf3+0x144>
    4410:	67 e9       	ldi	r22, 0x97	; 151
    4412:	72 e0       	ldi	r23, 0x02	; 2
    4414:	6e c0       	rjmp	.+220    	; 0x44f2 <__divsf3+0x14a>
    4416:	34 30       	cpi	r19, 0x04	; 4
    4418:	39 f4       	brne	.+14     	; 0x4428 <__divsf3+0x80>
    441a:	1d 86       	std	Y+13, r1	; 0x0d
    441c:	1e 86       	std	Y+14, r1	; 0x0e
    441e:	1f 86       	std	Y+15, r1	; 0x0f
    4420:	18 8a       	std	Y+16, r1	; 0x10
    4422:	1c 86       	std	Y+12, r1	; 0x0c
    4424:	1b 86       	std	Y+11, r1	; 0x0b
    4426:	04 c0       	rjmp	.+8      	; 0x4430 <__divsf3+0x88>
    4428:	32 30       	cpi	r19, 0x02	; 2
    442a:	21 f4       	brne	.+8      	; 0x4434 <__divsf3+0x8c>
    442c:	84 e0       	ldi	r24, 0x04	; 4
    442e:	89 87       	std	Y+9, r24	; 0x09
    4430:	b7 01       	movw	r22, r14
    4432:	5f c0       	rjmp	.+190    	; 0x44f2 <__divsf3+0x14a>
    4434:	2b 85       	ldd	r18, Y+11	; 0x0b
    4436:	3c 85       	ldd	r19, Y+12	; 0x0c
    4438:	8b 89       	ldd	r24, Y+19	; 0x13
    443a:	9c 89       	ldd	r25, Y+20	; 0x14
    443c:	28 1b       	sub	r18, r24
    443e:	39 0b       	sbc	r19, r25
    4440:	3c 87       	std	Y+12, r19	; 0x0c
    4442:	2b 87       	std	Y+11, r18	; 0x0b
    4444:	ed 84       	ldd	r14, Y+13	; 0x0d
    4446:	fe 84       	ldd	r15, Y+14	; 0x0e
    4448:	0f 85       	ldd	r16, Y+15	; 0x0f
    444a:	18 89       	ldd	r17, Y+16	; 0x10
    444c:	ad 88       	ldd	r10, Y+21	; 0x15
    444e:	be 88       	ldd	r11, Y+22	; 0x16
    4450:	cf 88       	ldd	r12, Y+23	; 0x17
    4452:	d8 8c       	ldd	r13, Y+24	; 0x18
    4454:	ea 14       	cp	r14, r10
    4456:	fb 04       	cpc	r15, r11
    4458:	0c 05       	cpc	r16, r12
    445a:	1d 05       	cpc	r17, r13
    445c:	40 f4       	brcc	.+16     	; 0x446e <__divsf3+0xc6>
    445e:	ee 0c       	add	r14, r14
    4460:	ff 1c       	adc	r15, r15
    4462:	00 1f       	adc	r16, r16
    4464:	11 1f       	adc	r17, r17
    4466:	21 50       	subi	r18, 0x01	; 1
    4468:	30 40       	sbci	r19, 0x00	; 0
    446a:	3c 87       	std	Y+12, r19	; 0x0c
    446c:	2b 87       	std	Y+11, r18	; 0x0b
    446e:	20 e0       	ldi	r18, 0x00	; 0
    4470:	30 e0       	ldi	r19, 0x00	; 0
    4472:	40 e0       	ldi	r20, 0x00	; 0
    4474:	50 e0       	ldi	r21, 0x00	; 0
    4476:	80 e0       	ldi	r24, 0x00	; 0
    4478:	90 e0       	ldi	r25, 0x00	; 0
    447a:	a0 e0       	ldi	r26, 0x00	; 0
    447c:	b0 e4       	ldi	r27, 0x40	; 64
    447e:	60 e0       	ldi	r22, 0x00	; 0
    4480:	70 e0       	ldi	r23, 0x00	; 0
    4482:	ea 14       	cp	r14, r10
    4484:	fb 04       	cpc	r15, r11
    4486:	0c 05       	cpc	r16, r12
    4488:	1d 05       	cpc	r17, r13
    448a:	40 f0       	brcs	.+16     	; 0x449c <__divsf3+0xf4>
    448c:	28 2b       	or	r18, r24
    448e:	39 2b       	or	r19, r25
    4490:	4a 2b       	or	r20, r26
    4492:	5b 2b       	or	r21, r27
    4494:	ea 18       	sub	r14, r10
    4496:	fb 08       	sbc	r15, r11
    4498:	0c 09       	sbc	r16, r12
    449a:	1d 09       	sbc	r17, r13
    449c:	b6 95       	lsr	r27
    449e:	a7 95       	ror	r26
    44a0:	97 95       	ror	r25
    44a2:	87 95       	ror	r24
    44a4:	ee 0c       	add	r14, r14
    44a6:	ff 1c       	adc	r15, r15
    44a8:	00 1f       	adc	r16, r16
    44aa:	11 1f       	adc	r17, r17
    44ac:	6f 5f       	subi	r22, 0xFF	; 255
    44ae:	7f 4f       	sbci	r23, 0xFF	; 255
    44b0:	6f 31       	cpi	r22, 0x1F	; 31
    44b2:	71 05       	cpc	r23, r1
    44b4:	31 f7       	brne	.-52     	; 0x4482 <__divsf3+0xda>
    44b6:	da 01       	movw	r26, r20
    44b8:	c9 01       	movw	r24, r18
    44ba:	8f 77       	andi	r24, 0x7F	; 127
    44bc:	90 70       	andi	r25, 0x00	; 0
    44be:	a0 70       	andi	r26, 0x00	; 0
    44c0:	b0 70       	andi	r27, 0x00	; 0
    44c2:	80 34       	cpi	r24, 0x40	; 64
    44c4:	91 05       	cpc	r25, r1
    44c6:	a1 05       	cpc	r26, r1
    44c8:	b1 05       	cpc	r27, r1
    44ca:	61 f4       	brne	.+24     	; 0x44e4 <__divsf3+0x13c>
    44cc:	27 fd       	sbrc	r18, 7
    44ce:	0a c0       	rjmp	.+20     	; 0x44e4 <__divsf3+0x13c>
    44d0:	e1 14       	cp	r14, r1
    44d2:	f1 04       	cpc	r15, r1
    44d4:	01 05       	cpc	r16, r1
    44d6:	11 05       	cpc	r17, r1
    44d8:	29 f0       	breq	.+10     	; 0x44e4 <__divsf3+0x13c>
    44da:	20 5c       	subi	r18, 0xC0	; 192
    44dc:	3f 4f       	sbci	r19, 0xFF	; 255
    44de:	4f 4f       	sbci	r20, 0xFF	; 255
    44e0:	5f 4f       	sbci	r21, 0xFF	; 255
    44e2:	20 78       	andi	r18, 0x80	; 128
    44e4:	2d 87       	std	Y+13, r18	; 0x0d
    44e6:	3e 87       	std	Y+14, r19	; 0x0e
    44e8:	4f 87       	std	Y+15, r20	; 0x0f
    44ea:	58 8b       	std	Y+16, r21	; 0x10
    44ec:	be 01       	movw	r22, r28
    44ee:	67 5f       	subi	r22, 0xF7	; 247
    44f0:	7f 4f       	sbci	r23, 0xFF	; 255
    44f2:	cb 01       	movw	r24, r22
    44f4:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    44f8:	68 96       	adiw	r28, 0x18	; 24
    44fa:	ea e0       	ldi	r30, 0x0A	; 10
    44fc:	0c 94 07 27 	jmp	0x4e0e	; 0x4e0e <__epilogue_restores__+0x10>

00004500 <__eqsf2>:
    4500:	a8 e1       	ldi	r26, 0x18	; 24
    4502:	b0 e0       	ldi	r27, 0x00	; 0
    4504:	e6 e8       	ldi	r30, 0x86	; 134
    4506:	f2 e2       	ldi	r31, 0x22	; 34
    4508:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    450c:	69 83       	std	Y+1, r22	; 0x01
    450e:	7a 83       	std	Y+2, r23	; 0x02
    4510:	8b 83       	std	Y+3, r24	; 0x03
    4512:	9c 83       	std	Y+4, r25	; 0x04
    4514:	2d 83       	std	Y+5, r18	; 0x05
    4516:	3e 83       	std	Y+6, r19	; 0x06
    4518:	4f 83       	std	Y+7, r20	; 0x07
    451a:	58 87       	std	Y+8, r21	; 0x08
    451c:	89 e0       	ldi	r24, 0x09	; 9
    451e:	e8 2e       	mov	r14, r24
    4520:	f1 2c       	mov	r15, r1
    4522:	ec 0e       	add	r14, r28
    4524:	fd 1e       	adc	r15, r29
    4526:	ce 01       	movw	r24, r28
    4528:	01 96       	adiw	r24, 0x01	; 1
    452a:	b7 01       	movw	r22, r14
    452c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4530:	8e 01       	movw	r16, r28
    4532:	0f 5e       	subi	r16, 0xEF	; 239
    4534:	1f 4f       	sbci	r17, 0xFF	; 255
    4536:	ce 01       	movw	r24, r28
    4538:	05 96       	adiw	r24, 0x05	; 5
    453a:	b8 01       	movw	r22, r16
    453c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4540:	89 85       	ldd	r24, Y+9	; 0x09
    4542:	82 30       	cpi	r24, 0x02	; 2
    4544:	40 f0       	brcs	.+16     	; 0x4556 <__eqsf2+0x56>
    4546:	89 89       	ldd	r24, Y+17	; 0x11
    4548:	82 30       	cpi	r24, 0x02	; 2
    454a:	28 f0       	brcs	.+10     	; 0x4556 <__eqsf2+0x56>
    454c:	c7 01       	movw	r24, r14
    454e:	b8 01       	movw	r22, r16
    4550:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <__fpcmp_parts_f>
    4554:	01 c0       	rjmp	.+2      	; 0x4558 <__eqsf2+0x58>
    4556:	81 e0       	ldi	r24, 0x01	; 1
    4558:	68 96       	adiw	r28, 0x18	; 24
    455a:	e6 e0       	ldi	r30, 0x06	; 6
    455c:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

00004560 <__gtsf2>:
    4560:	a8 e1       	ldi	r26, 0x18	; 24
    4562:	b0 e0       	ldi	r27, 0x00	; 0
    4564:	e6 eb       	ldi	r30, 0xB6	; 182
    4566:	f2 e2       	ldi	r31, 0x22	; 34
    4568:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    456c:	69 83       	std	Y+1, r22	; 0x01
    456e:	7a 83       	std	Y+2, r23	; 0x02
    4570:	8b 83       	std	Y+3, r24	; 0x03
    4572:	9c 83       	std	Y+4, r25	; 0x04
    4574:	2d 83       	std	Y+5, r18	; 0x05
    4576:	3e 83       	std	Y+6, r19	; 0x06
    4578:	4f 83       	std	Y+7, r20	; 0x07
    457a:	58 87       	std	Y+8, r21	; 0x08
    457c:	89 e0       	ldi	r24, 0x09	; 9
    457e:	e8 2e       	mov	r14, r24
    4580:	f1 2c       	mov	r15, r1
    4582:	ec 0e       	add	r14, r28
    4584:	fd 1e       	adc	r15, r29
    4586:	ce 01       	movw	r24, r28
    4588:	01 96       	adiw	r24, 0x01	; 1
    458a:	b7 01       	movw	r22, r14
    458c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4590:	8e 01       	movw	r16, r28
    4592:	0f 5e       	subi	r16, 0xEF	; 239
    4594:	1f 4f       	sbci	r17, 0xFF	; 255
    4596:	ce 01       	movw	r24, r28
    4598:	05 96       	adiw	r24, 0x05	; 5
    459a:	b8 01       	movw	r22, r16
    459c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    45a0:	89 85       	ldd	r24, Y+9	; 0x09
    45a2:	82 30       	cpi	r24, 0x02	; 2
    45a4:	40 f0       	brcs	.+16     	; 0x45b6 <__gtsf2+0x56>
    45a6:	89 89       	ldd	r24, Y+17	; 0x11
    45a8:	82 30       	cpi	r24, 0x02	; 2
    45aa:	28 f0       	brcs	.+10     	; 0x45b6 <__gtsf2+0x56>
    45ac:	c7 01       	movw	r24, r14
    45ae:	b8 01       	movw	r22, r16
    45b0:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <__fpcmp_parts_f>
    45b4:	01 c0       	rjmp	.+2      	; 0x45b8 <__gtsf2+0x58>
    45b6:	8f ef       	ldi	r24, 0xFF	; 255
    45b8:	68 96       	adiw	r28, 0x18	; 24
    45ba:	e6 e0       	ldi	r30, 0x06	; 6
    45bc:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

000045c0 <__gesf2>:
    45c0:	a8 e1       	ldi	r26, 0x18	; 24
    45c2:	b0 e0       	ldi	r27, 0x00	; 0
    45c4:	e6 ee       	ldi	r30, 0xE6	; 230
    45c6:	f2 e2       	ldi	r31, 0x22	; 34
    45c8:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    45cc:	69 83       	std	Y+1, r22	; 0x01
    45ce:	7a 83       	std	Y+2, r23	; 0x02
    45d0:	8b 83       	std	Y+3, r24	; 0x03
    45d2:	9c 83       	std	Y+4, r25	; 0x04
    45d4:	2d 83       	std	Y+5, r18	; 0x05
    45d6:	3e 83       	std	Y+6, r19	; 0x06
    45d8:	4f 83       	std	Y+7, r20	; 0x07
    45da:	58 87       	std	Y+8, r21	; 0x08
    45dc:	89 e0       	ldi	r24, 0x09	; 9
    45de:	e8 2e       	mov	r14, r24
    45e0:	f1 2c       	mov	r15, r1
    45e2:	ec 0e       	add	r14, r28
    45e4:	fd 1e       	adc	r15, r29
    45e6:	ce 01       	movw	r24, r28
    45e8:	01 96       	adiw	r24, 0x01	; 1
    45ea:	b7 01       	movw	r22, r14
    45ec:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    45f0:	8e 01       	movw	r16, r28
    45f2:	0f 5e       	subi	r16, 0xEF	; 239
    45f4:	1f 4f       	sbci	r17, 0xFF	; 255
    45f6:	ce 01       	movw	r24, r28
    45f8:	05 96       	adiw	r24, 0x05	; 5
    45fa:	b8 01       	movw	r22, r16
    45fc:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4600:	89 85       	ldd	r24, Y+9	; 0x09
    4602:	82 30       	cpi	r24, 0x02	; 2
    4604:	40 f0       	brcs	.+16     	; 0x4616 <__gesf2+0x56>
    4606:	89 89       	ldd	r24, Y+17	; 0x11
    4608:	82 30       	cpi	r24, 0x02	; 2
    460a:	28 f0       	brcs	.+10     	; 0x4616 <__gesf2+0x56>
    460c:	c7 01       	movw	r24, r14
    460e:	b8 01       	movw	r22, r16
    4610:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <__fpcmp_parts_f>
    4614:	01 c0       	rjmp	.+2      	; 0x4618 <__gesf2+0x58>
    4616:	8f ef       	ldi	r24, 0xFF	; 255
    4618:	68 96       	adiw	r28, 0x18	; 24
    461a:	e6 e0       	ldi	r30, 0x06	; 6
    461c:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

00004620 <__ltsf2>:
    4620:	a8 e1       	ldi	r26, 0x18	; 24
    4622:	b0 e0       	ldi	r27, 0x00	; 0
    4624:	e6 e1       	ldi	r30, 0x16	; 22
    4626:	f3 e2       	ldi	r31, 0x23	; 35
    4628:	0c 94 ef 26 	jmp	0x4dde	; 0x4dde <__prologue_saves__+0x18>
    462c:	69 83       	std	Y+1, r22	; 0x01
    462e:	7a 83       	std	Y+2, r23	; 0x02
    4630:	8b 83       	std	Y+3, r24	; 0x03
    4632:	9c 83       	std	Y+4, r25	; 0x04
    4634:	2d 83       	std	Y+5, r18	; 0x05
    4636:	3e 83       	std	Y+6, r19	; 0x06
    4638:	4f 83       	std	Y+7, r20	; 0x07
    463a:	58 87       	std	Y+8, r21	; 0x08
    463c:	89 e0       	ldi	r24, 0x09	; 9
    463e:	e8 2e       	mov	r14, r24
    4640:	f1 2c       	mov	r15, r1
    4642:	ec 0e       	add	r14, r28
    4644:	fd 1e       	adc	r15, r29
    4646:	ce 01       	movw	r24, r28
    4648:	01 96       	adiw	r24, 0x01	; 1
    464a:	b7 01       	movw	r22, r14
    464c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4650:	8e 01       	movw	r16, r28
    4652:	0f 5e       	subi	r16, 0xEF	; 239
    4654:	1f 4f       	sbci	r17, 0xFF	; 255
    4656:	ce 01       	movw	r24, r28
    4658:	05 96       	adiw	r24, 0x05	; 5
    465a:	b8 01       	movw	r22, r16
    465c:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    4660:	89 85       	ldd	r24, Y+9	; 0x09
    4662:	82 30       	cpi	r24, 0x02	; 2
    4664:	40 f0       	brcs	.+16     	; 0x4676 <__ltsf2+0x56>
    4666:	89 89       	ldd	r24, Y+17	; 0x11
    4668:	82 30       	cpi	r24, 0x02	; 2
    466a:	28 f0       	brcs	.+10     	; 0x4676 <__ltsf2+0x56>
    466c:	c7 01       	movw	r24, r14
    466e:	b8 01       	movw	r22, r16
    4670:	0e 94 07 26 	call	0x4c0e	; 0x4c0e <__fpcmp_parts_f>
    4674:	01 c0       	rjmp	.+2      	; 0x4678 <__ltsf2+0x58>
    4676:	81 e0       	ldi	r24, 0x01	; 1
    4678:	68 96       	adiw	r28, 0x18	; 24
    467a:	e6 e0       	ldi	r30, 0x06	; 6
    467c:	0c 94 0b 27 	jmp	0x4e16	; 0x4e16 <__epilogue_restores__+0x18>

00004680 <__floatsisf>:
    4680:	a8 e0       	ldi	r26, 0x08	; 8
    4682:	b0 e0       	ldi	r27, 0x00	; 0
    4684:	e6 e4       	ldi	r30, 0x46	; 70
    4686:	f3 e2       	ldi	r31, 0x23	; 35
    4688:	0c 94 ec 26 	jmp	0x4dd8	; 0x4dd8 <__prologue_saves__+0x12>
    468c:	9b 01       	movw	r18, r22
    468e:	ac 01       	movw	r20, r24
    4690:	83 e0       	ldi	r24, 0x03	; 3
    4692:	89 83       	std	Y+1, r24	; 0x01
    4694:	da 01       	movw	r26, r20
    4696:	c9 01       	movw	r24, r18
    4698:	88 27       	eor	r24, r24
    469a:	b7 fd       	sbrc	r27, 7
    469c:	83 95       	inc	r24
    469e:	99 27       	eor	r25, r25
    46a0:	aa 27       	eor	r26, r26
    46a2:	bb 27       	eor	r27, r27
    46a4:	b8 2e       	mov	r11, r24
    46a6:	21 15       	cp	r18, r1
    46a8:	31 05       	cpc	r19, r1
    46aa:	41 05       	cpc	r20, r1
    46ac:	51 05       	cpc	r21, r1
    46ae:	19 f4       	brne	.+6      	; 0x46b6 <__floatsisf+0x36>
    46b0:	82 e0       	ldi	r24, 0x02	; 2
    46b2:	89 83       	std	Y+1, r24	; 0x01
    46b4:	3a c0       	rjmp	.+116    	; 0x472a <__floatsisf+0xaa>
    46b6:	88 23       	and	r24, r24
    46b8:	a9 f0       	breq	.+42     	; 0x46e4 <__floatsisf+0x64>
    46ba:	20 30       	cpi	r18, 0x00	; 0
    46bc:	80 e0       	ldi	r24, 0x00	; 0
    46be:	38 07       	cpc	r19, r24
    46c0:	80 e0       	ldi	r24, 0x00	; 0
    46c2:	48 07       	cpc	r20, r24
    46c4:	80 e8       	ldi	r24, 0x80	; 128
    46c6:	58 07       	cpc	r21, r24
    46c8:	29 f4       	brne	.+10     	; 0x46d4 <__floatsisf+0x54>
    46ca:	60 e0       	ldi	r22, 0x00	; 0
    46cc:	70 e0       	ldi	r23, 0x00	; 0
    46ce:	80 e0       	ldi	r24, 0x00	; 0
    46d0:	9f ec       	ldi	r25, 0xCF	; 207
    46d2:	30 c0       	rjmp	.+96     	; 0x4734 <__floatsisf+0xb4>
    46d4:	ee 24       	eor	r14, r14
    46d6:	ff 24       	eor	r15, r15
    46d8:	87 01       	movw	r16, r14
    46da:	e2 1a       	sub	r14, r18
    46dc:	f3 0a       	sbc	r15, r19
    46de:	04 0b       	sbc	r16, r20
    46e0:	15 0b       	sbc	r17, r21
    46e2:	02 c0       	rjmp	.+4      	; 0x46e8 <__floatsisf+0x68>
    46e4:	79 01       	movw	r14, r18
    46e6:	8a 01       	movw	r16, r20
    46e8:	8e e1       	ldi	r24, 0x1E	; 30
    46ea:	c8 2e       	mov	r12, r24
    46ec:	d1 2c       	mov	r13, r1
    46ee:	dc 82       	std	Y+4, r13	; 0x04
    46f0:	cb 82       	std	Y+3, r12	; 0x03
    46f2:	ed 82       	std	Y+5, r14	; 0x05
    46f4:	fe 82       	std	Y+6, r15	; 0x06
    46f6:	0f 83       	std	Y+7, r16	; 0x07
    46f8:	18 87       	std	Y+8, r17	; 0x08
    46fa:	c8 01       	movw	r24, r16
    46fc:	b7 01       	movw	r22, r14
    46fe:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <__clzsi2>
    4702:	01 97       	sbiw	r24, 0x01	; 1
    4704:	18 16       	cp	r1, r24
    4706:	19 06       	cpc	r1, r25
    4708:	84 f4       	brge	.+32     	; 0x472a <__floatsisf+0xaa>
    470a:	08 2e       	mov	r0, r24
    470c:	04 c0       	rjmp	.+8      	; 0x4716 <__floatsisf+0x96>
    470e:	ee 0c       	add	r14, r14
    4710:	ff 1c       	adc	r15, r15
    4712:	00 1f       	adc	r16, r16
    4714:	11 1f       	adc	r17, r17
    4716:	0a 94       	dec	r0
    4718:	d2 f7       	brpl	.-12     	; 0x470e <__floatsisf+0x8e>
    471a:	ed 82       	std	Y+5, r14	; 0x05
    471c:	fe 82       	std	Y+6, r15	; 0x06
    471e:	0f 83       	std	Y+7, r16	; 0x07
    4720:	18 87       	std	Y+8, r17	; 0x08
    4722:	c8 1a       	sub	r12, r24
    4724:	d9 0a       	sbc	r13, r25
    4726:	dc 82       	std	Y+4, r13	; 0x04
    4728:	cb 82       	std	Y+3, r12	; 0x03
    472a:	ba 82       	std	Y+2, r11	; 0x02
    472c:	ce 01       	movw	r24, r28
    472e:	01 96       	adiw	r24, 0x01	; 1
    4730:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    4734:	28 96       	adiw	r28, 0x08	; 8
    4736:	e9 e0       	ldi	r30, 0x09	; 9
    4738:	0c 94 08 27 	jmp	0x4e10	; 0x4e10 <__epilogue_restores__+0x12>

0000473c <__fixsfsi>:
    473c:	ac e0       	ldi	r26, 0x0C	; 12
    473e:	b0 e0       	ldi	r27, 0x00	; 0
    4740:	e4 ea       	ldi	r30, 0xA4	; 164
    4742:	f3 e2       	ldi	r31, 0x23	; 35
    4744:	0c 94 f3 26 	jmp	0x4de6	; 0x4de6 <__prologue_saves__+0x20>
    4748:	69 83       	std	Y+1, r22	; 0x01
    474a:	7a 83       	std	Y+2, r23	; 0x02
    474c:	8b 83       	std	Y+3, r24	; 0x03
    474e:	9c 83       	std	Y+4, r25	; 0x04
    4750:	ce 01       	movw	r24, r28
    4752:	01 96       	adiw	r24, 0x01	; 1
    4754:	be 01       	movw	r22, r28
    4756:	6b 5f       	subi	r22, 0xFB	; 251
    4758:	7f 4f       	sbci	r23, 0xFF	; 255
    475a:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <__unpack_f>
    475e:	8d 81       	ldd	r24, Y+5	; 0x05
    4760:	82 30       	cpi	r24, 0x02	; 2
    4762:	61 f1       	breq	.+88     	; 0x47bc <__fixsfsi+0x80>
    4764:	82 30       	cpi	r24, 0x02	; 2
    4766:	50 f1       	brcs	.+84     	; 0x47bc <__fixsfsi+0x80>
    4768:	84 30       	cpi	r24, 0x04	; 4
    476a:	21 f4       	brne	.+8      	; 0x4774 <__fixsfsi+0x38>
    476c:	8e 81       	ldd	r24, Y+6	; 0x06
    476e:	88 23       	and	r24, r24
    4770:	51 f1       	breq	.+84     	; 0x47c6 <__fixsfsi+0x8a>
    4772:	2e c0       	rjmp	.+92     	; 0x47d0 <__fixsfsi+0x94>
    4774:	2f 81       	ldd	r18, Y+7	; 0x07
    4776:	38 85       	ldd	r19, Y+8	; 0x08
    4778:	37 fd       	sbrc	r19, 7
    477a:	20 c0       	rjmp	.+64     	; 0x47bc <__fixsfsi+0x80>
    477c:	6e 81       	ldd	r22, Y+6	; 0x06
    477e:	2f 31       	cpi	r18, 0x1F	; 31
    4780:	31 05       	cpc	r19, r1
    4782:	1c f0       	brlt	.+6      	; 0x478a <__fixsfsi+0x4e>
    4784:	66 23       	and	r22, r22
    4786:	f9 f0       	breq	.+62     	; 0x47c6 <__fixsfsi+0x8a>
    4788:	23 c0       	rjmp	.+70     	; 0x47d0 <__fixsfsi+0x94>
    478a:	8e e1       	ldi	r24, 0x1E	; 30
    478c:	90 e0       	ldi	r25, 0x00	; 0
    478e:	82 1b       	sub	r24, r18
    4790:	93 0b       	sbc	r25, r19
    4792:	29 85       	ldd	r18, Y+9	; 0x09
    4794:	3a 85       	ldd	r19, Y+10	; 0x0a
    4796:	4b 85       	ldd	r20, Y+11	; 0x0b
    4798:	5c 85       	ldd	r21, Y+12	; 0x0c
    479a:	04 c0       	rjmp	.+8      	; 0x47a4 <__fixsfsi+0x68>
    479c:	56 95       	lsr	r21
    479e:	47 95       	ror	r20
    47a0:	37 95       	ror	r19
    47a2:	27 95       	ror	r18
    47a4:	8a 95       	dec	r24
    47a6:	d2 f7       	brpl	.-12     	; 0x479c <__fixsfsi+0x60>
    47a8:	66 23       	and	r22, r22
    47aa:	b1 f0       	breq	.+44     	; 0x47d8 <__fixsfsi+0x9c>
    47ac:	50 95       	com	r21
    47ae:	40 95       	com	r20
    47b0:	30 95       	com	r19
    47b2:	21 95       	neg	r18
    47b4:	3f 4f       	sbci	r19, 0xFF	; 255
    47b6:	4f 4f       	sbci	r20, 0xFF	; 255
    47b8:	5f 4f       	sbci	r21, 0xFF	; 255
    47ba:	0e c0       	rjmp	.+28     	; 0x47d8 <__fixsfsi+0x9c>
    47bc:	20 e0       	ldi	r18, 0x00	; 0
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	40 e0       	ldi	r20, 0x00	; 0
    47c2:	50 e0       	ldi	r21, 0x00	; 0
    47c4:	09 c0       	rjmp	.+18     	; 0x47d8 <__fixsfsi+0x9c>
    47c6:	2f ef       	ldi	r18, 0xFF	; 255
    47c8:	3f ef       	ldi	r19, 0xFF	; 255
    47ca:	4f ef       	ldi	r20, 0xFF	; 255
    47cc:	5f e7       	ldi	r21, 0x7F	; 127
    47ce:	04 c0       	rjmp	.+8      	; 0x47d8 <__fixsfsi+0x9c>
    47d0:	20 e0       	ldi	r18, 0x00	; 0
    47d2:	30 e0       	ldi	r19, 0x00	; 0
    47d4:	40 e0       	ldi	r20, 0x00	; 0
    47d6:	50 e8       	ldi	r21, 0x80	; 128
    47d8:	b9 01       	movw	r22, r18
    47da:	ca 01       	movw	r24, r20
    47dc:	2c 96       	adiw	r28, 0x0c	; 12
    47de:	e2 e0       	ldi	r30, 0x02	; 2
    47e0:	0c 94 0f 27 	jmp	0x4e1e	; 0x4e1e <__epilogue_restores__+0x20>

000047e4 <__floatunsisf>:
    47e4:	a8 e0       	ldi	r26, 0x08	; 8
    47e6:	b0 e0       	ldi	r27, 0x00	; 0
    47e8:	e8 ef       	ldi	r30, 0xF8	; 248
    47ea:	f3 e2       	ldi	r31, 0x23	; 35
    47ec:	0c 94 eb 26 	jmp	0x4dd6	; 0x4dd6 <__prologue_saves__+0x10>
    47f0:	7b 01       	movw	r14, r22
    47f2:	8c 01       	movw	r16, r24
    47f4:	61 15       	cp	r22, r1
    47f6:	71 05       	cpc	r23, r1
    47f8:	81 05       	cpc	r24, r1
    47fa:	91 05       	cpc	r25, r1
    47fc:	19 f4       	brne	.+6      	; 0x4804 <__floatunsisf+0x20>
    47fe:	82 e0       	ldi	r24, 0x02	; 2
    4800:	89 83       	std	Y+1, r24	; 0x01
    4802:	60 c0       	rjmp	.+192    	; 0x48c4 <__floatunsisf+0xe0>
    4804:	83 e0       	ldi	r24, 0x03	; 3
    4806:	89 83       	std	Y+1, r24	; 0x01
    4808:	8e e1       	ldi	r24, 0x1E	; 30
    480a:	c8 2e       	mov	r12, r24
    480c:	d1 2c       	mov	r13, r1
    480e:	dc 82       	std	Y+4, r13	; 0x04
    4810:	cb 82       	std	Y+3, r12	; 0x03
    4812:	ed 82       	std	Y+5, r14	; 0x05
    4814:	fe 82       	std	Y+6, r15	; 0x06
    4816:	0f 83       	std	Y+7, r16	; 0x07
    4818:	18 87       	std	Y+8, r17	; 0x08
    481a:	c8 01       	movw	r24, r16
    481c:	b7 01       	movw	r22, r14
    481e:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <__clzsi2>
    4822:	fc 01       	movw	r30, r24
    4824:	31 97       	sbiw	r30, 0x01	; 1
    4826:	f7 ff       	sbrs	r31, 7
    4828:	3b c0       	rjmp	.+118    	; 0x48a0 <__floatunsisf+0xbc>
    482a:	22 27       	eor	r18, r18
    482c:	33 27       	eor	r19, r19
    482e:	2e 1b       	sub	r18, r30
    4830:	3f 0b       	sbc	r19, r31
    4832:	57 01       	movw	r10, r14
    4834:	68 01       	movw	r12, r16
    4836:	02 2e       	mov	r0, r18
    4838:	04 c0       	rjmp	.+8      	; 0x4842 <__floatunsisf+0x5e>
    483a:	d6 94       	lsr	r13
    483c:	c7 94       	ror	r12
    483e:	b7 94       	ror	r11
    4840:	a7 94       	ror	r10
    4842:	0a 94       	dec	r0
    4844:	d2 f7       	brpl	.-12     	; 0x483a <__floatunsisf+0x56>
    4846:	40 e0       	ldi	r20, 0x00	; 0
    4848:	50 e0       	ldi	r21, 0x00	; 0
    484a:	60 e0       	ldi	r22, 0x00	; 0
    484c:	70 e0       	ldi	r23, 0x00	; 0
    484e:	81 e0       	ldi	r24, 0x01	; 1
    4850:	90 e0       	ldi	r25, 0x00	; 0
    4852:	a0 e0       	ldi	r26, 0x00	; 0
    4854:	b0 e0       	ldi	r27, 0x00	; 0
    4856:	04 c0       	rjmp	.+8      	; 0x4860 <__floatunsisf+0x7c>
    4858:	88 0f       	add	r24, r24
    485a:	99 1f       	adc	r25, r25
    485c:	aa 1f       	adc	r26, r26
    485e:	bb 1f       	adc	r27, r27
    4860:	2a 95       	dec	r18
    4862:	d2 f7       	brpl	.-12     	; 0x4858 <__floatunsisf+0x74>
    4864:	01 97       	sbiw	r24, 0x01	; 1
    4866:	a1 09       	sbc	r26, r1
    4868:	b1 09       	sbc	r27, r1
    486a:	8e 21       	and	r24, r14
    486c:	9f 21       	and	r25, r15
    486e:	a0 23       	and	r26, r16
    4870:	b1 23       	and	r27, r17
    4872:	00 97       	sbiw	r24, 0x00	; 0
    4874:	a1 05       	cpc	r26, r1
    4876:	b1 05       	cpc	r27, r1
    4878:	21 f0       	breq	.+8      	; 0x4882 <__floatunsisf+0x9e>
    487a:	41 e0       	ldi	r20, 0x01	; 1
    487c:	50 e0       	ldi	r21, 0x00	; 0
    487e:	60 e0       	ldi	r22, 0x00	; 0
    4880:	70 e0       	ldi	r23, 0x00	; 0
    4882:	4a 29       	or	r20, r10
    4884:	5b 29       	or	r21, r11
    4886:	6c 29       	or	r22, r12
    4888:	7d 29       	or	r23, r13
    488a:	4d 83       	std	Y+5, r20	; 0x05
    488c:	5e 83       	std	Y+6, r21	; 0x06
    488e:	6f 83       	std	Y+7, r22	; 0x07
    4890:	78 87       	std	Y+8, r23	; 0x08
    4892:	8e e1       	ldi	r24, 0x1E	; 30
    4894:	90 e0       	ldi	r25, 0x00	; 0
    4896:	8e 1b       	sub	r24, r30
    4898:	9f 0b       	sbc	r25, r31
    489a:	9c 83       	std	Y+4, r25	; 0x04
    489c:	8b 83       	std	Y+3, r24	; 0x03
    489e:	12 c0       	rjmp	.+36     	; 0x48c4 <__floatunsisf+0xe0>
    48a0:	30 97       	sbiw	r30, 0x00	; 0
    48a2:	81 f0       	breq	.+32     	; 0x48c4 <__floatunsisf+0xe0>
    48a4:	0e 2e       	mov	r0, r30
    48a6:	04 c0       	rjmp	.+8      	; 0x48b0 <__floatunsisf+0xcc>
    48a8:	ee 0c       	add	r14, r14
    48aa:	ff 1c       	adc	r15, r15
    48ac:	00 1f       	adc	r16, r16
    48ae:	11 1f       	adc	r17, r17
    48b0:	0a 94       	dec	r0
    48b2:	d2 f7       	brpl	.-12     	; 0x48a8 <__floatunsisf+0xc4>
    48b4:	ed 82       	std	Y+5, r14	; 0x05
    48b6:	fe 82       	std	Y+6, r15	; 0x06
    48b8:	0f 83       	std	Y+7, r16	; 0x07
    48ba:	18 87       	std	Y+8, r17	; 0x08
    48bc:	ce 1a       	sub	r12, r30
    48be:	df 0a       	sbc	r13, r31
    48c0:	dc 82       	std	Y+4, r13	; 0x04
    48c2:	cb 82       	std	Y+3, r12	; 0x03
    48c4:	1a 82       	std	Y+2, r1	; 0x02
    48c6:	ce 01       	movw	r24, r28
    48c8:	01 96       	adiw	r24, 0x01	; 1
    48ca:	0e 94 ba 24 	call	0x4974	; 0x4974 <__pack_f>
    48ce:	28 96       	adiw	r28, 0x08	; 8
    48d0:	ea e0       	ldi	r30, 0x0A	; 10
    48d2:	0c 94 07 27 	jmp	0x4e0e	; 0x4e0e <__epilogue_restores__+0x10>

000048d6 <__clzsi2>:
    48d6:	ef 92       	push	r14
    48d8:	ff 92       	push	r15
    48da:	0f 93       	push	r16
    48dc:	1f 93       	push	r17
    48de:	7b 01       	movw	r14, r22
    48e0:	8c 01       	movw	r16, r24
    48e2:	80 e0       	ldi	r24, 0x00	; 0
    48e4:	e8 16       	cp	r14, r24
    48e6:	80 e0       	ldi	r24, 0x00	; 0
    48e8:	f8 06       	cpc	r15, r24
    48ea:	81 e0       	ldi	r24, 0x01	; 1
    48ec:	08 07       	cpc	r16, r24
    48ee:	80 e0       	ldi	r24, 0x00	; 0
    48f0:	18 07       	cpc	r17, r24
    48f2:	88 f4       	brcc	.+34     	; 0x4916 <__clzsi2+0x40>
    48f4:	8f ef       	ldi	r24, 0xFF	; 255
    48f6:	e8 16       	cp	r14, r24
    48f8:	f1 04       	cpc	r15, r1
    48fa:	01 05       	cpc	r16, r1
    48fc:	11 05       	cpc	r17, r1
    48fe:	31 f0       	breq	.+12     	; 0x490c <__clzsi2+0x36>
    4900:	28 f0       	brcs	.+10     	; 0x490c <__clzsi2+0x36>
    4902:	88 e0       	ldi	r24, 0x08	; 8
    4904:	90 e0       	ldi	r25, 0x00	; 0
    4906:	a0 e0       	ldi	r26, 0x00	; 0
    4908:	b0 e0       	ldi	r27, 0x00	; 0
    490a:	17 c0       	rjmp	.+46     	; 0x493a <__clzsi2+0x64>
    490c:	80 e0       	ldi	r24, 0x00	; 0
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	a0 e0       	ldi	r26, 0x00	; 0
    4912:	b0 e0       	ldi	r27, 0x00	; 0
    4914:	12 c0       	rjmp	.+36     	; 0x493a <__clzsi2+0x64>
    4916:	80 e0       	ldi	r24, 0x00	; 0
    4918:	e8 16       	cp	r14, r24
    491a:	80 e0       	ldi	r24, 0x00	; 0
    491c:	f8 06       	cpc	r15, r24
    491e:	80 e0       	ldi	r24, 0x00	; 0
    4920:	08 07       	cpc	r16, r24
    4922:	81 e0       	ldi	r24, 0x01	; 1
    4924:	18 07       	cpc	r17, r24
    4926:	28 f0       	brcs	.+10     	; 0x4932 <__clzsi2+0x5c>
    4928:	88 e1       	ldi	r24, 0x18	; 24
    492a:	90 e0       	ldi	r25, 0x00	; 0
    492c:	a0 e0       	ldi	r26, 0x00	; 0
    492e:	b0 e0       	ldi	r27, 0x00	; 0
    4930:	04 c0       	rjmp	.+8      	; 0x493a <__clzsi2+0x64>
    4932:	80 e1       	ldi	r24, 0x10	; 16
    4934:	90 e0       	ldi	r25, 0x00	; 0
    4936:	a0 e0       	ldi	r26, 0x00	; 0
    4938:	b0 e0       	ldi	r27, 0x00	; 0
    493a:	20 e2       	ldi	r18, 0x20	; 32
    493c:	30 e0       	ldi	r19, 0x00	; 0
    493e:	40 e0       	ldi	r20, 0x00	; 0
    4940:	50 e0       	ldi	r21, 0x00	; 0
    4942:	28 1b       	sub	r18, r24
    4944:	39 0b       	sbc	r19, r25
    4946:	4a 0b       	sbc	r20, r26
    4948:	5b 0b       	sbc	r21, r27
    494a:	04 c0       	rjmp	.+8      	; 0x4954 <__clzsi2+0x7e>
    494c:	16 95       	lsr	r17
    494e:	07 95       	ror	r16
    4950:	f7 94       	ror	r15
    4952:	e7 94       	ror	r14
    4954:	8a 95       	dec	r24
    4956:	d2 f7       	brpl	.-12     	; 0x494c <__clzsi2+0x76>
    4958:	f7 01       	movw	r30, r14
    495a:	e1 56       	subi	r30, 0x61	; 97
    495c:	fd 4f       	sbci	r31, 0xFD	; 253
    495e:	80 81       	ld	r24, Z
    4960:	28 1b       	sub	r18, r24
    4962:	31 09       	sbc	r19, r1
    4964:	41 09       	sbc	r20, r1
    4966:	51 09       	sbc	r21, r1
    4968:	c9 01       	movw	r24, r18
    496a:	1f 91       	pop	r17
    496c:	0f 91       	pop	r16
    496e:	ff 90       	pop	r15
    4970:	ef 90       	pop	r14
    4972:	08 95       	ret

00004974 <__pack_f>:
    4974:	df 92       	push	r13
    4976:	ef 92       	push	r14
    4978:	ff 92       	push	r15
    497a:	0f 93       	push	r16
    497c:	1f 93       	push	r17
    497e:	fc 01       	movw	r30, r24
    4980:	e4 80       	ldd	r14, Z+4	; 0x04
    4982:	f5 80       	ldd	r15, Z+5	; 0x05
    4984:	06 81       	ldd	r16, Z+6	; 0x06
    4986:	17 81       	ldd	r17, Z+7	; 0x07
    4988:	d1 80       	ldd	r13, Z+1	; 0x01
    498a:	80 81       	ld	r24, Z
    498c:	82 30       	cpi	r24, 0x02	; 2
    498e:	48 f4       	brcc	.+18     	; 0x49a2 <__pack_f+0x2e>
    4990:	80 e0       	ldi	r24, 0x00	; 0
    4992:	90 e0       	ldi	r25, 0x00	; 0
    4994:	a0 e1       	ldi	r26, 0x10	; 16
    4996:	b0 e0       	ldi	r27, 0x00	; 0
    4998:	e8 2a       	or	r14, r24
    499a:	f9 2a       	or	r15, r25
    499c:	0a 2b       	or	r16, r26
    499e:	1b 2b       	or	r17, r27
    49a0:	a5 c0       	rjmp	.+330    	; 0x4aec <__pack_f+0x178>
    49a2:	84 30       	cpi	r24, 0x04	; 4
    49a4:	09 f4       	brne	.+2      	; 0x49a8 <__pack_f+0x34>
    49a6:	9f c0       	rjmp	.+318    	; 0x4ae6 <__pack_f+0x172>
    49a8:	82 30       	cpi	r24, 0x02	; 2
    49aa:	21 f4       	brne	.+8      	; 0x49b4 <__pack_f+0x40>
    49ac:	ee 24       	eor	r14, r14
    49ae:	ff 24       	eor	r15, r15
    49b0:	87 01       	movw	r16, r14
    49b2:	05 c0       	rjmp	.+10     	; 0x49be <__pack_f+0x4a>
    49b4:	e1 14       	cp	r14, r1
    49b6:	f1 04       	cpc	r15, r1
    49b8:	01 05       	cpc	r16, r1
    49ba:	11 05       	cpc	r17, r1
    49bc:	19 f4       	brne	.+6      	; 0x49c4 <__pack_f+0x50>
    49be:	e0 e0       	ldi	r30, 0x00	; 0
    49c0:	f0 e0       	ldi	r31, 0x00	; 0
    49c2:	96 c0       	rjmp	.+300    	; 0x4af0 <__pack_f+0x17c>
    49c4:	62 81       	ldd	r22, Z+2	; 0x02
    49c6:	73 81       	ldd	r23, Z+3	; 0x03
    49c8:	9f ef       	ldi	r25, 0xFF	; 255
    49ca:	62 38       	cpi	r22, 0x82	; 130
    49cc:	79 07       	cpc	r23, r25
    49ce:	0c f0       	brlt	.+2      	; 0x49d2 <__pack_f+0x5e>
    49d0:	5b c0       	rjmp	.+182    	; 0x4a88 <__pack_f+0x114>
    49d2:	22 e8       	ldi	r18, 0x82	; 130
    49d4:	3f ef       	ldi	r19, 0xFF	; 255
    49d6:	26 1b       	sub	r18, r22
    49d8:	37 0b       	sbc	r19, r23
    49da:	2a 31       	cpi	r18, 0x1A	; 26
    49dc:	31 05       	cpc	r19, r1
    49de:	2c f0       	brlt	.+10     	; 0x49ea <__pack_f+0x76>
    49e0:	20 e0       	ldi	r18, 0x00	; 0
    49e2:	30 e0       	ldi	r19, 0x00	; 0
    49e4:	40 e0       	ldi	r20, 0x00	; 0
    49e6:	50 e0       	ldi	r21, 0x00	; 0
    49e8:	2a c0       	rjmp	.+84     	; 0x4a3e <__pack_f+0xca>
    49ea:	b8 01       	movw	r22, r16
    49ec:	a7 01       	movw	r20, r14
    49ee:	02 2e       	mov	r0, r18
    49f0:	04 c0       	rjmp	.+8      	; 0x49fa <__pack_f+0x86>
    49f2:	76 95       	lsr	r23
    49f4:	67 95       	ror	r22
    49f6:	57 95       	ror	r21
    49f8:	47 95       	ror	r20
    49fa:	0a 94       	dec	r0
    49fc:	d2 f7       	brpl	.-12     	; 0x49f2 <__pack_f+0x7e>
    49fe:	81 e0       	ldi	r24, 0x01	; 1
    4a00:	90 e0       	ldi	r25, 0x00	; 0
    4a02:	a0 e0       	ldi	r26, 0x00	; 0
    4a04:	b0 e0       	ldi	r27, 0x00	; 0
    4a06:	04 c0       	rjmp	.+8      	; 0x4a10 <__pack_f+0x9c>
    4a08:	88 0f       	add	r24, r24
    4a0a:	99 1f       	adc	r25, r25
    4a0c:	aa 1f       	adc	r26, r26
    4a0e:	bb 1f       	adc	r27, r27
    4a10:	2a 95       	dec	r18
    4a12:	d2 f7       	brpl	.-12     	; 0x4a08 <__pack_f+0x94>
    4a14:	01 97       	sbiw	r24, 0x01	; 1
    4a16:	a1 09       	sbc	r26, r1
    4a18:	b1 09       	sbc	r27, r1
    4a1a:	8e 21       	and	r24, r14
    4a1c:	9f 21       	and	r25, r15
    4a1e:	a0 23       	and	r26, r16
    4a20:	b1 23       	and	r27, r17
    4a22:	00 97       	sbiw	r24, 0x00	; 0
    4a24:	a1 05       	cpc	r26, r1
    4a26:	b1 05       	cpc	r27, r1
    4a28:	21 f0       	breq	.+8      	; 0x4a32 <__pack_f+0xbe>
    4a2a:	81 e0       	ldi	r24, 0x01	; 1
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	a0 e0       	ldi	r26, 0x00	; 0
    4a30:	b0 e0       	ldi	r27, 0x00	; 0
    4a32:	9a 01       	movw	r18, r20
    4a34:	ab 01       	movw	r20, r22
    4a36:	28 2b       	or	r18, r24
    4a38:	39 2b       	or	r19, r25
    4a3a:	4a 2b       	or	r20, r26
    4a3c:	5b 2b       	or	r21, r27
    4a3e:	da 01       	movw	r26, r20
    4a40:	c9 01       	movw	r24, r18
    4a42:	8f 77       	andi	r24, 0x7F	; 127
    4a44:	90 70       	andi	r25, 0x00	; 0
    4a46:	a0 70       	andi	r26, 0x00	; 0
    4a48:	b0 70       	andi	r27, 0x00	; 0
    4a4a:	80 34       	cpi	r24, 0x40	; 64
    4a4c:	91 05       	cpc	r25, r1
    4a4e:	a1 05       	cpc	r26, r1
    4a50:	b1 05       	cpc	r27, r1
    4a52:	39 f4       	brne	.+14     	; 0x4a62 <__pack_f+0xee>
    4a54:	27 ff       	sbrs	r18, 7
    4a56:	09 c0       	rjmp	.+18     	; 0x4a6a <__pack_f+0xf6>
    4a58:	20 5c       	subi	r18, 0xC0	; 192
    4a5a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a5c:	4f 4f       	sbci	r20, 0xFF	; 255
    4a5e:	5f 4f       	sbci	r21, 0xFF	; 255
    4a60:	04 c0       	rjmp	.+8      	; 0x4a6a <__pack_f+0xf6>
    4a62:	21 5c       	subi	r18, 0xC1	; 193
    4a64:	3f 4f       	sbci	r19, 0xFF	; 255
    4a66:	4f 4f       	sbci	r20, 0xFF	; 255
    4a68:	5f 4f       	sbci	r21, 0xFF	; 255
    4a6a:	e0 e0       	ldi	r30, 0x00	; 0
    4a6c:	f0 e0       	ldi	r31, 0x00	; 0
    4a6e:	20 30       	cpi	r18, 0x00	; 0
    4a70:	a0 e0       	ldi	r26, 0x00	; 0
    4a72:	3a 07       	cpc	r19, r26
    4a74:	a0 e0       	ldi	r26, 0x00	; 0
    4a76:	4a 07       	cpc	r20, r26
    4a78:	a0 e4       	ldi	r26, 0x40	; 64
    4a7a:	5a 07       	cpc	r21, r26
    4a7c:	10 f0       	brcs	.+4      	; 0x4a82 <__pack_f+0x10e>
    4a7e:	e1 e0       	ldi	r30, 0x01	; 1
    4a80:	f0 e0       	ldi	r31, 0x00	; 0
    4a82:	79 01       	movw	r14, r18
    4a84:	8a 01       	movw	r16, r20
    4a86:	27 c0       	rjmp	.+78     	; 0x4ad6 <__pack_f+0x162>
    4a88:	60 38       	cpi	r22, 0x80	; 128
    4a8a:	71 05       	cpc	r23, r1
    4a8c:	64 f5       	brge	.+88     	; 0x4ae6 <__pack_f+0x172>
    4a8e:	fb 01       	movw	r30, r22
    4a90:	e1 58       	subi	r30, 0x81	; 129
    4a92:	ff 4f       	sbci	r31, 0xFF	; 255
    4a94:	d8 01       	movw	r26, r16
    4a96:	c7 01       	movw	r24, r14
    4a98:	8f 77       	andi	r24, 0x7F	; 127
    4a9a:	90 70       	andi	r25, 0x00	; 0
    4a9c:	a0 70       	andi	r26, 0x00	; 0
    4a9e:	b0 70       	andi	r27, 0x00	; 0
    4aa0:	80 34       	cpi	r24, 0x40	; 64
    4aa2:	91 05       	cpc	r25, r1
    4aa4:	a1 05       	cpc	r26, r1
    4aa6:	b1 05       	cpc	r27, r1
    4aa8:	39 f4       	brne	.+14     	; 0x4ab8 <__pack_f+0x144>
    4aaa:	e7 fe       	sbrs	r14, 7
    4aac:	0d c0       	rjmp	.+26     	; 0x4ac8 <__pack_f+0x154>
    4aae:	80 e4       	ldi	r24, 0x40	; 64
    4ab0:	90 e0       	ldi	r25, 0x00	; 0
    4ab2:	a0 e0       	ldi	r26, 0x00	; 0
    4ab4:	b0 e0       	ldi	r27, 0x00	; 0
    4ab6:	04 c0       	rjmp	.+8      	; 0x4ac0 <__pack_f+0x14c>
    4ab8:	8f e3       	ldi	r24, 0x3F	; 63
    4aba:	90 e0       	ldi	r25, 0x00	; 0
    4abc:	a0 e0       	ldi	r26, 0x00	; 0
    4abe:	b0 e0       	ldi	r27, 0x00	; 0
    4ac0:	e8 0e       	add	r14, r24
    4ac2:	f9 1e       	adc	r15, r25
    4ac4:	0a 1f       	adc	r16, r26
    4ac6:	1b 1f       	adc	r17, r27
    4ac8:	17 ff       	sbrs	r17, 7
    4aca:	05 c0       	rjmp	.+10     	; 0x4ad6 <__pack_f+0x162>
    4acc:	16 95       	lsr	r17
    4ace:	07 95       	ror	r16
    4ad0:	f7 94       	ror	r15
    4ad2:	e7 94       	ror	r14
    4ad4:	31 96       	adiw	r30, 0x01	; 1
    4ad6:	87 e0       	ldi	r24, 0x07	; 7
    4ad8:	16 95       	lsr	r17
    4ada:	07 95       	ror	r16
    4adc:	f7 94       	ror	r15
    4ade:	e7 94       	ror	r14
    4ae0:	8a 95       	dec	r24
    4ae2:	d1 f7       	brne	.-12     	; 0x4ad8 <__pack_f+0x164>
    4ae4:	05 c0       	rjmp	.+10     	; 0x4af0 <__pack_f+0x17c>
    4ae6:	ee 24       	eor	r14, r14
    4ae8:	ff 24       	eor	r15, r15
    4aea:	87 01       	movw	r16, r14
    4aec:	ef ef       	ldi	r30, 0xFF	; 255
    4aee:	f0 e0       	ldi	r31, 0x00	; 0
    4af0:	6e 2f       	mov	r22, r30
    4af2:	67 95       	ror	r22
    4af4:	66 27       	eor	r22, r22
    4af6:	67 95       	ror	r22
    4af8:	90 2f       	mov	r25, r16
    4afa:	9f 77       	andi	r25, 0x7F	; 127
    4afc:	d7 94       	ror	r13
    4afe:	dd 24       	eor	r13, r13
    4b00:	d7 94       	ror	r13
    4b02:	8e 2f       	mov	r24, r30
    4b04:	86 95       	lsr	r24
    4b06:	49 2f       	mov	r20, r25
    4b08:	46 2b       	or	r20, r22
    4b0a:	58 2f       	mov	r21, r24
    4b0c:	5d 29       	or	r21, r13
    4b0e:	b7 01       	movw	r22, r14
    4b10:	ca 01       	movw	r24, r20
    4b12:	1f 91       	pop	r17
    4b14:	0f 91       	pop	r16
    4b16:	ff 90       	pop	r15
    4b18:	ef 90       	pop	r14
    4b1a:	df 90       	pop	r13
    4b1c:	08 95       	ret

00004b1e <__unpack_f>:
    4b1e:	fc 01       	movw	r30, r24
    4b20:	db 01       	movw	r26, r22
    4b22:	40 81       	ld	r20, Z
    4b24:	51 81       	ldd	r21, Z+1	; 0x01
    4b26:	22 81       	ldd	r18, Z+2	; 0x02
    4b28:	62 2f       	mov	r22, r18
    4b2a:	6f 77       	andi	r22, 0x7F	; 127
    4b2c:	70 e0       	ldi	r23, 0x00	; 0
    4b2e:	22 1f       	adc	r18, r18
    4b30:	22 27       	eor	r18, r18
    4b32:	22 1f       	adc	r18, r18
    4b34:	93 81       	ldd	r25, Z+3	; 0x03
    4b36:	89 2f       	mov	r24, r25
    4b38:	88 0f       	add	r24, r24
    4b3a:	82 2b       	or	r24, r18
    4b3c:	28 2f       	mov	r18, r24
    4b3e:	30 e0       	ldi	r19, 0x00	; 0
    4b40:	99 1f       	adc	r25, r25
    4b42:	99 27       	eor	r25, r25
    4b44:	99 1f       	adc	r25, r25
    4b46:	11 96       	adiw	r26, 0x01	; 1
    4b48:	9c 93       	st	X, r25
    4b4a:	11 97       	sbiw	r26, 0x01	; 1
    4b4c:	21 15       	cp	r18, r1
    4b4e:	31 05       	cpc	r19, r1
    4b50:	a9 f5       	brne	.+106    	; 0x4bbc <__unpack_f+0x9e>
    4b52:	41 15       	cp	r20, r1
    4b54:	51 05       	cpc	r21, r1
    4b56:	61 05       	cpc	r22, r1
    4b58:	71 05       	cpc	r23, r1
    4b5a:	11 f4       	brne	.+4      	; 0x4b60 <__unpack_f+0x42>
    4b5c:	82 e0       	ldi	r24, 0x02	; 2
    4b5e:	37 c0       	rjmp	.+110    	; 0x4bce <__unpack_f+0xb0>
    4b60:	82 e8       	ldi	r24, 0x82	; 130
    4b62:	9f ef       	ldi	r25, 0xFF	; 255
    4b64:	13 96       	adiw	r26, 0x03	; 3
    4b66:	9c 93       	st	X, r25
    4b68:	8e 93       	st	-X, r24
    4b6a:	12 97       	sbiw	r26, 0x02	; 2
    4b6c:	9a 01       	movw	r18, r20
    4b6e:	ab 01       	movw	r20, r22
    4b70:	67 e0       	ldi	r22, 0x07	; 7
    4b72:	22 0f       	add	r18, r18
    4b74:	33 1f       	adc	r19, r19
    4b76:	44 1f       	adc	r20, r20
    4b78:	55 1f       	adc	r21, r21
    4b7a:	6a 95       	dec	r22
    4b7c:	d1 f7       	brne	.-12     	; 0x4b72 <__unpack_f+0x54>
    4b7e:	83 e0       	ldi	r24, 0x03	; 3
    4b80:	8c 93       	st	X, r24
    4b82:	0d c0       	rjmp	.+26     	; 0x4b9e <__unpack_f+0x80>
    4b84:	22 0f       	add	r18, r18
    4b86:	33 1f       	adc	r19, r19
    4b88:	44 1f       	adc	r20, r20
    4b8a:	55 1f       	adc	r21, r21
    4b8c:	12 96       	adiw	r26, 0x02	; 2
    4b8e:	8d 91       	ld	r24, X+
    4b90:	9c 91       	ld	r25, X
    4b92:	13 97       	sbiw	r26, 0x03	; 3
    4b94:	01 97       	sbiw	r24, 0x01	; 1
    4b96:	13 96       	adiw	r26, 0x03	; 3
    4b98:	9c 93       	st	X, r25
    4b9a:	8e 93       	st	-X, r24
    4b9c:	12 97       	sbiw	r26, 0x02	; 2
    4b9e:	20 30       	cpi	r18, 0x00	; 0
    4ba0:	80 e0       	ldi	r24, 0x00	; 0
    4ba2:	38 07       	cpc	r19, r24
    4ba4:	80 e0       	ldi	r24, 0x00	; 0
    4ba6:	48 07       	cpc	r20, r24
    4ba8:	80 e4       	ldi	r24, 0x40	; 64
    4baa:	58 07       	cpc	r21, r24
    4bac:	58 f3       	brcs	.-42     	; 0x4b84 <__unpack_f+0x66>
    4bae:	14 96       	adiw	r26, 0x04	; 4
    4bb0:	2d 93       	st	X+, r18
    4bb2:	3d 93       	st	X+, r19
    4bb4:	4d 93       	st	X+, r20
    4bb6:	5c 93       	st	X, r21
    4bb8:	17 97       	sbiw	r26, 0x07	; 7
    4bba:	08 95       	ret
    4bbc:	2f 3f       	cpi	r18, 0xFF	; 255
    4bbe:	31 05       	cpc	r19, r1
    4bc0:	79 f4       	brne	.+30     	; 0x4be0 <__unpack_f+0xc2>
    4bc2:	41 15       	cp	r20, r1
    4bc4:	51 05       	cpc	r21, r1
    4bc6:	61 05       	cpc	r22, r1
    4bc8:	71 05       	cpc	r23, r1
    4bca:	19 f4       	brne	.+6      	; 0x4bd2 <__unpack_f+0xb4>
    4bcc:	84 e0       	ldi	r24, 0x04	; 4
    4bce:	8c 93       	st	X, r24
    4bd0:	08 95       	ret
    4bd2:	64 ff       	sbrs	r22, 4
    4bd4:	03 c0       	rjmp	.+6      	; 0x4bdc <__unpack_f+0xbe>
    4bd6:	81 e0       	ldi	r24, 0x01	; 1
    4bd8:	8c 93       	st	X, r24
    4bda:	12 c0       	rjmp	.+36     	; 0x4c00 <__unpack_f+0xe2>
    4bdc:	1c 92       	st	X, r1
    4bde:	10 c0       	rjmp	.+32     	; 0x4c00 <__unpack_f+0xe2>
    4be0:	2f 57       	subi	r18, 0x7F	; 127
    4be2:	30 40       	sbci	r19, 0x00	; 0
    4be4:	13 96       	adiw	r26, 0x03	; 3
    4be6:	3c 93       	st	X, r19
    4be8:	2e 93       	st	-X, r18
    4bea:	12 97       	sbiw	r26, 0x02	; 2
    4bec:	83 e0       	ldi	r24, 0x03	; 3
    4bee:	8c 93       	st	X, r24
    4bf0:	87 e0       	ldi	r24, 0x07	; 7
    4bf2:	44 0f       	add	r20, r20
    4bf4:	55 1f       	adc	r21, r21
    4bf6:	66 1f       	adc	r22, r22
    4bf8:	77 1f       	adc	r23, r23
    4bfa:	8a 95       	dec	r24
    4bfc:	d1 f7       	brne	.-12     	; 0x4bf2 <__unpack_f+0xd4>
    4bfe:	70 64       	ori	r23, 0x40	; 64
    4c00:	14 96       	adiw	r26, 0x04	; 4
    4c02:	4d 93       	st	X+, r20
    4c04:	5d 93       	st	X+, r21
    4c06:	6d 93       	st	X+, r22
    4c08:	7c 93       	st	X, r23
    4c0a:	17 97       	sbiw	r26, 0x07	; 7
    4c0c:	08 95       	ret

00004c0e <__fpcmp_parts_f>:
    4c0e:	1f 93       	push	r17
    4c10:	dc 01       	movw	r26, r24
    4c12:	fb 01       	movw	r30, r22
    4c14:	9c 91       	ld	r25, X
    4c16:	92 30       	cpi	r25, 0x02	; 2
    4c18:	08 f4       	brcc	.+2      	; 0x4c1c <__fpcmp_parts_f+0xe>
    4c1a:	47 c0       	rjmp	.+142    	; 0x4caa <__fpcmp_parts_f+0x9c>
    4c1c:	80 81       	ld	r24, Z
    4c1e:	82 30       	cpi	r24, 0x02	; 2
    4c20:	08 f4       	brcc	.+2      	; 0x4c24 <__fpcmp_parts_f+0x16>
    4c22:	43 c0       	rjmp	.+134    	; 0x4caa <__fpcmp_parts_f+0x9c>
    4c24:	94 30       	cpi	r25, 0x04	; 4
    4c26:	51 f4       	brne	.+20     	; 0x4c3c <__fpcmp_parts_f+0x2e>
    4c28:	11 96       	adiw	r26, 0x01	; 1
    4c2a:	1c 91       	ld	r17, X
    4c2c:	84 30       	cpi	r24, 0x04	; 4
    4c2e:	99 f5       	brne	.+102    	; 0x4c96 <__fpcmp_parts_f+0x88>
    4c30:	81 81       	ldd	r24, Z+1	; 0x01
    4c32:	68 2f       	mov	r22, r24
    4c34:	70 e0       	ldi	r23, 0x00	; 0
    4c36:	61 1b       	sub	r22, r17
    4c38:	71 09       	sbc	r23, r1
    4c3a:	3f c0       	rjmp	.+126    	; 0x4cba <__fpcmp_parts_f+0xac>
    4c3c:	84 30       	cpi	r24, 0x04	; 4
    4c3e:	21 f0       	breq	.+8      	; 0x4c48 <__fpcmp_parts_f+0x3a>
    4c40:	92 30       	cpi	r25, 0x02	; 2
    4c42:	31 f4       	brne	.+12     	; 0x4c50 <__fpcmp_parts_f+0x42>
    4c44:	82 30       	cpi	r24, 0x02	; 2
    4c46:	b9 f1       	breq	.+110    	; 0x4cb6 <__fpcmp_parts_f+0xa8>
    4c48:	81 81       	ldd	r24, Z+1	; 0x01
    4c4a:	88 23       	and	r24, r24
    4c4c:	89 f1       	breq	.+98     	; 0x4cb0 <__fpcmp_parts_f+0xa2>
    4c4e:	2d c0       	rjmp	.+90     	; 0x4caa <__fpcmp_parts_f+0x9c>
    4c50:	11 96       	adiw	r26, 0x01	; 1
    4c52:	1c 91       	ld	r17, X
    4c54:	11 97       	sbiw	r26, 0x01	; 1
    4c56:	82 30       	cpi	r24, 0x02	; 2
    4c58:	f1 f0       	breq	.+60     	; 0x4c96 <__fpcmp_parts_f+0x88>
    4c5a:	81 81       	ldd	r24, Z+1	; 0x01
    4c5c:	18 17       	cp	r17, r24
    4c5e:	d9 f4       	brne	.+54     	; 0x4c96 <__fpcmp_parts_f+0x88>
    4c60:	12 96       	adiw	r26, 0x02	; 2
    4c62:	2d 91       	ld	r18, X+
    4c64:	3c 91       	ld	r19, X
    4c66:	13 97       	sbiw	r26, 0x03	; 3
    4c68:	82 81       	ldd	r24, Z+2	; 0x02
    4c6a:	93 81       	ldd	r25, Z+3	; 0x03
    4c6c:	82 17       	cp	r24, r18
    4c6e:	93 07       	cpc	r25, r19
    4c70:	94 f0       	brlt	.+36     	; 0x4c96 <__fpcmp_parts_f+0x88>
    4c72:	28 17       	cp	r18, r24
    4c74:	39 07       	cpc	r19, r25
    4c76:	bc f0       	brlt	.+46     	; 0x4ca6 <__fpcmp_parts_f+0x98>
    4c78:	14 96       	adiw	r26, 0x04	; 4
    4c7a:	8d 91       	ld	r24, X+
    4c7c:	9d 91       	ld	r25, X+
    4c7e:	0d 90       	ld	r0, X+
    4c80:	bc 91       	ld	r27, X
    4c82:	a0 2d       	mov	r26, r0
    4c84:	24 81       	ldd	r18, Z+4	; 0x04
    4c86:	35 81       	ldd	r19, Z+5	; 0x05
    4c88:	46 81       	ldd	r20, Z+6	; 0x06
    4c8a:	57 81       	ldd	r21, Z+7	; 0x07
    4c8c:	28 17       	cp	r18, r24
    4c8e:	39 07       	cpc	r19, r25
    4c90:	4a 07       	cpc	r20, r26
    4c92:	5b 07       	cpc	r21, r27
    4c94:	18 f4       	brcc	.+6      	; 0x4c9c <__fpcmp_parts_f+0x8e>
    4c96:	11 23       	and	r17, r17
    4c98:	41 f0       	breq	.+16     	; 0x4caa <__fpcmp_parts_f+0x9c>
    4c9a:	0a c0       	rjmp	.+20     	; 0x4cb0 <__fpcmp_parts_f+0xa2>
    4c9c:	82 17       	cp	r24, r18
    4c9e:	93 07       	cpc	r25, r19
    4ca0:	a4 07       	cpc	r26, r20
    4ca2:	b5 07       	cpc	r27, r21
    4ca4:	40 f4       	brcc	.+16     	; 0x4cb6 <__fpcmp_parts_f+0xa8>
    4ca6:	11 23       	and	r17, r17
    4ca8:	19 f0       	breq	.+6      	; 0x4cb0 <__fpcmp_parts_f+0xa2>
    4caa:	61 e0       	ldi	r22, 0x01	; 1
    4cac:	70 e0       	ldi	r23, 0x00	; 0
    4cae:	05 c0       	rjmp	.+10     	; 0x4cba <__fpcmp_parts_f+0xac>
    4cb0:	6f ef       	ldi	r22, 0xFF	; 255
    4cb2:	7f ef       	ldi	r23, 0xFF	; 255
    4cb4:	02 c0       	rjmp	.+4      	; 0x4cba <__fpcmp_parts_f+0xac>
    4cb6:	60 e0       	ldi	r22, 0x00	; 0
    4cb8:	70 e0       	ldi	r23, 0x00	; 0
    4cba:	cb 01       	movw	r24, r22
    4cbc:	1f 91       	pop	r17
    4cbe:	08 95       	ret

00004cc0 <memcpy>:
    4cc0:	fb 01       	movw	r30, r22
    4cc2:	dc 01       	movw	r26, r24
    4cc4:	02 c0       	rjmp	.+4      	; 0x4cca <memcpy+0xa>
    4cc6:	01 90       	ld	r0, Z+
    4cc8:	0d 92       	st	X+, r0
    4cca:	41 50       	subi	r20, 0x01	; 1
    4ccc:	50 40       	sbci	r21, 0x00	; 0
    4cce:	d8 f7       	brcc	.-10     	; 0x4cc6 <memcpy+0x6>
    4cd0:	08 95       	ret

00004cd2 <memset>:
    4cd2:	dc 01       	movw	r26, r24
    4cd4:	01 c0       	rjmp	.+2      	; 0x4cd8 <memset+0x6>
    4cd6:	6d 93       	st	X+, r22
    4cd8:	41 50       	subi	r20, 0x01	; 1
    4cda:	50 40       	sbci	r21, 0x00	; 0
    4cdc:	e0 f7       	brcc	.-8      	; 0x4cd6 <memset+0x4>
    4cde:	08 95       	ret

00004ce0 <strncpy>:
    4ce0:	fb 01       	movw	r30, r22
    4ce2:	dc 01       	movw	r26, r24
    4ce4:	41 50       	subi	r20, 0x01	; 1
    4ce6:	50 40       	sbci	r21, 0x00	; 0
    4ce8:	48 f0       	brcs	.+18     	; 0x4cfc <strncpy+0x1c>
    4cea:	01 90       	ld	r0, Z+
    4cec:	0d 92       	st	X+, r0
    4cee:	00 20       	and	r0, r0
    4cf0:	c9 f7       	brne	.-14     	; 0x4ce4 <strncpy+0x4>
    4cf2:	01 c0       	rjmp	.+2      	; 0x4cf6 <strncpy+0x16>
    4cf4:	1d 92       	st	X+, r1
    4cf6:	41 50       	subi	r20, 0x01	; 1
    4cf8:	50 40       	sbci	r21, 0x00	; 0
    4cfa:	e0 f7       	brcc	.-8      	; 0x4cf4 <strncpy+0x14>
    4cfc:	08 95       	ret

00004cfe <__udivmodhi4>:
    4cfe:	aa 1b       	sub	r26, r26
    4d00:	bb 1b       	sub	r27, r27
    4d02:	51 e1       	ldi	r21, 0x11	; 17
    4d04:	07 c0       	rjmp	.+14     	; 0x4d14 <__udivmodhi4_ep>

00004d06 <__udivmodhi4_loop>:
    4d06:	aa 1f       	adc	r26, r26
    4d08:	bb 1f       	adc	r27, r27
    4d0a:	a6 17       	cp	r26, r22
    4d0c:	b7 07       	cpc	r27, r23
    4d0e:	10 f0       	brcs	.+4      	; 0x4d14 <__udivmodhi4_ep>
    4d10:	a6 1b       	sub	r26, r22
    4d12:	b7 0b       	sbc	r27, r23

00004d14 <__udivmodhi4_ep>:
    4d14:	88 1f       	adc	r24, r24
    4d16:	99 1f       	adc	r25, r25
    4d18:	5a 95       	dec	r21
    4d1a:	a9 f7       	brne	.-22     	; 0x4d06 <__udivmodhi4_loop>
    4d1c:	80 95       	com	r24
    4d1e:	90 95       	com	r25
    4d20:	bc 01       	movw	r22, r24
    4d22:	cd 01       	movw	r24, r26
    4d24:	08 95       	ret

00004d26 <__divmodhi4>:
    4d26:	97 fb       	bst	r25, 7
    4d28:	09 2e       	mov	r0, r25
    4d2a:	07 26       	eor	r0, r23
    4d2c:	0a d0       	rcall	.+20     	; 0x4d42 <__divmodhi4_neg1>
    4d2e:	77 fd       	sbrc	r23, 7
    4d30:	04 d0       	rcall	.+8      	; 0x4d3a <__divmodhi4_neg2>
    4d32:	e5 df       	rcall	.-54     	; 0x4cfe <__udivmodhi4>
    4d34:	06 d0       	rcall	.+12     	; 0x4d42 <__divmodhi4_neg1>
    4d36:	00 20       	and	r0, r0
    4d38:	1a f4       	brpl	.+6      	; 0x4d40 <__divmodhi4_exit>

00004d3a <__divmodhi4_neg2>:
    4d3a:	70 95       	com	r23
    4d3c:	61 95       	neg	r22
    4d3e:	7f 4f       	sbci	r23, 0xFF	; 255

00004d40 <__divmodhi4_exit>:
    4d40:	08 95       	ret

00004d42 <__divmodhi4_neg1>:
    4d42:	f6 f7       	brtc	.-4      	; 0x4d40 <__divmodhi4_exit>
    4d44:	90 95       	com	r25
    4d46:	81 95       	neg	r24
    4d48:	9f 4f       	sbci	r25, 0xFF	; 255
    4d4a:	08 95       	ret

00004d4c <__udivmodsi4>:
    4d4c:	a1 e2       	ldi	r26, 0x21	; 33
    4d4e:	1a 2e       	mov	r1, r26
    4d50:	aa 1b       	sub	r26, r26
    4d52:	bb 1b       	sub	r27, r27
    4d54:	fd 01       	movw	r30, r26
    4d56:	0d c0       	rjmp	.+26     	; 0x4d72 <__udivmodsi4_ep>

00004d58 <__udivmodsi4_loop>:
    4d58:	aa 1f       	adc	r26, r26
    4d5a:	bb 1f       	adc	r27, r27
    4d5c:	ee 1f       	adc	r30, r30
    4d5e:	ff 1f       	adc	r31, r31
    4d60:	a2 17       	cp	r26, r18
    4d62:	b3 07       	cpc	r27, r19
    4d64:	e4 07       	cpc	r30, r20
    4d66:	f5 07       	cpc	r31, r21
    4d68:	20 f0       	brcs	.+8      	; 0x4d72 <__udivmodsi4_ep>
    4d6a:	a2 1b       	sub	r26, r18
    4d6c:	b3 0b       	sbc	r27, r19
    4d6e:	e4 0b       	sbc	r30, r20
    4d70:	f5 0b       	sbc	r31, r21

00004d72 <__udivmodsi4_ep>:
    4d72:	66 1f       	adc	r22, r22
    4d74:	77 1f       	adc	r23, r23
    4d76:	88 1f       	adc	r24, r24
    4d78:	99 1f       	adc	r25, r25
    4d7a:	1a 94       	dec	r1
    4d7c:	69 f7       	brne	.-38     	; 0x4d58 <__udivmodsi4_loop>
    4d7e:	60 95       	com	r22
    4d80:	70 95       	com	r23
    4d82:	80 95       	com	r24
    4d84:	90 95       	com	r25
    4d86:	9b 01       	movw	r18, r22
    4d88:	ac 01       	movw	r20, r24
    4d8a:	bd 01       	movw	r22, r26
    4d8c:	cf 01       	movw	r24, r30
    4d8e:	08 95       	ret

00004d90 <__divmodsi4>:
    4d90:	97 fb       	bst	r25, 7
    4d92:	09 2e       	mov	r0, r25
    4d94:	05 26       	eor	r0, r21
    4d96:	0e d0       	rcall	.+28     	; 0x4db4 <__divmodsi4_neg1>
    4d98:	57 fd       	sbrc	r21, 7
    4d9a:	04 d0       	rcall	.+8      	; 0x4da4 <__divmodsi4_neg2>
    4d9c:	d7 df       	rcall	.-82     	; 0x4d4c <__udivmodsi4>
    4d9e:	0a d0       	rcall	.+20     	; 0x4db4 <__divmodsi4_neg1>
    4da0:	00 1c       	adc	r0, r0
    4da2:	38 f4       	brcc	.+14     	; 0x4db2 <__divmodsi4_exit>

00004da4 <__divmodsi4_neg2>:
    4da4:	50 95       	com	r21
    4da6:	40 95       	com	r20
    4da8:	30 95       	com	r19
    4daa:	21 95       	neg	r18
    4dac:	3f 4f       	sbci	r19, 0xFF	; 255
    4dae:	4f 4f       	sbci	r20, 0xFF	; 255
    4db0:	5f 4f       	sbci	r21, 0xFF	; 255

00004db2 <__divmodsi4_exit>:
    4db2:	08 95       	ret

00004db4 <__divmodsi4_neg1>:
    4db4:	f6 f7       	brtc	.-4      	; 0x4db2 <__divmodsi4_exit>
    4db6:	90 95       	com	r25
    4db8:	80 95       	com	r24
    4dba:	70 95       	com	r23
    4dbc:	61 95       	neg	r22
    4dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    4dc0:	8f 4f       	sbci	r24, 0xFF	; 255
    4dc2:	9f 4f       	sbci	r25, 0xFF	; 255
    4dc4:	08 95       	ret

00004dc6 <__prologue_saves__>:
    4dc6:	2f 92       	push	r2
    4dc8:	3f 92       	push	r3
    4dca:	4f 92       	push	r4
    4dcc:	5f 92       	push	r5
    4dce:	6f 92       	push	r6
    4dd0:	7f 92       	push	r7
    4dd2:	8f 92       	push	r8
    4dd4:	9f 92       	push	r9
    4dd6:	af 92       	push	r10
    4dd8:	bf 92       	push	r11
    4dda:	cf 92       	push	r12
    4ddc:	df 92       	push	r13
    4dde:	ef 92       	push	r14
    4de0:	ff 92       	push	r15
    4de2:	0f 93       	push	r16
    4de4:	1f 93       	push	r17
    4de6:	cf 93       	push	r28
    4de8:	df 93       	push	r29
    4dea:	cd b7       	in	r28, 0x3d	; 61
    4dec:	de b7       	in	r29, 0x3e	; 62
    4dee:	ca 1b       	sub	r28, r26
    4df0:	db 0b       	sbc	r29, r27
    4df2:	0f b6       	in	r0, 0x3f	; 63
    4df4:	f8 94       	cli
    4df6:	de bf       	out	0x3e, r29	; 62
    4df8:	0f be       	out	0x3f, r0	; 63
    4dfa:	cd bf       	out	0x3d, r28	; 61
    4dfc:	09 94       	ijmp

00004dfe <__epilogue_restores__>:
    4dfe:	2a 88       	ldd	r2, Y+18	; 0x12
    4e00:	39 88       	ldd	r3, Y+17	; 0x11
    4e02:	48 88       	ldd	r4, Y+16	; 0x10
    4e04:	5f 84       	ldd	r5, Y+15	; 0x0f
    4e06:	6e 84       	ldd	r6, Y+14	; 0x0e
    4e08:	7d 84       	ldd	r7, Y+13	; 0x0d
    4e0a:	8c 84       	ldd	r8, Y+12	; 0x0c
    4e0c:	9b 84       	ldd	r9, Y+11	; 0x0b
    4e0e:	aa 84       	ldd	r10, Y+10	; 0x0a
    4e10:	b9 84       	ldd	r11, Y+9	; 0x09
    4e12:	c8 84       	ldd	r12, Y+8	; 0x08
    4e14:	df 80       	ldd	r13, Y+7	; 0x07
    4e16:	ee 80       	ldd	r14, Y+6	; 0x06
    4e18:	fd 80       	ldd	r15, Y+5	; 0x05
    4e1a:	0c 81       	ldd	r16, Y+4	; 0x04
    4e1c:	1b 81       	ldd	r17, Y+3	; 0x03
    4e1e:	aa 81       	ldd	r26, Y+2	; 0x02
    4e20:	b9 81       	ldd	r27, Y+1	; 0x01
    4e22:	ce 0f       	add	r28, r30
    4e24:	d1 1d       	adc	r29, r1
    4e26:	0f b6       	in	r0, 0x3f	; 63
    4e28:	f8 94       	cli
    4e2a:	de bf       	out	0x3e, r29	; 62
    4e2c:	0f be       	out	0x3f, r0	; 63
    4e2e:	cd bf       	out	0x3d, r28	; 61
    4e30:	ed 01       	movw	r28, r26
    4e32:	08 95       	ret

00004e34 <_exit>:
    4e34:	f8 94       	cli

00004e36 <__stop_program>:
    4e36:	ff cf       	rjmp	.-2      	; 0x4e36 <__stop_program>
